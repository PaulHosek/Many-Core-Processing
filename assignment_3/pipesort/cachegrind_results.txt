--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         20971520 B, 64 B, 20-way associative
Command:          ./pipesort -l 6
Data file:        cachegrind.out.10874
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir      I1mr  ILmr  Dr      D1mr  DLmr  Dw     D1mw  DLmw  
--------------------------------------------------------------------------------
389,219 1,364 1,332 101,698 3,512 2,324 46,185 1,318 1,219  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir     I1mr ILmr Dr     D1mr  DLmr Dw     D1mw DLmw  file:function
--------------------------------------------------------------------------------
68,021   18   17 23,464   379  220 11,685   25   16  /usr/src/debug/glibc-2.17-c758a686/elf/dl-lookup.c:do_lookup_x
56,533   10   10 13,791 1,035  739     16    3    0  /usr/src/debug/glibc-2.17-c758a686/elf/dl-addr.c:_dl_addr
38,947   12   11  7,915   151  126  4,716   30   17  /usr/src/debug/glibc-2.17-c758a686/elf/dl-lookup.c:_dl_lookup_symbol_x
38,787    1    1 12,031   151   83      0    0    0  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/strcmp.S:strcmp
22,837    4    2  2,805     0    0      0    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/../sysdeps/generic/dl-hash.h:do_lookup_x
18,902    5    5  7,192   233  141  2,770   19   14  /usr/src/debug/glibc-2.17-c758a686/elf/dl-lookup.c:check_match.9525
16,385   24   24  5,216   639  610  1,537   34   28  /usr/src/debug/glibc-2.17-c758a686/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
10,354    2    2  2,682    11    0  1,536    1    1  /usr/src/debug/glibc-2.17-c758a686/elf/dl-misc.c:_dl_name_match_p
 9,769   15   15  1,765   129  105  1,497  242  236  /usr/src/debug/glibc-2.17-c758a686/elf/do-rel.h:_dl_relocate_object
 8,206    2    2  2,528     3    0  1,264    0    0  /usr/src/debug/glibc-2.17-c758a686/stdlib/random_r.c:random_r
 6,716    2    1     20     0    0  6,596  102  102  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-memset.S:memset
 5,677   17   17    720     3    2    899   56   56  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:_int_malloc
 3,840    1    1     12     0    0  1,524  192  192  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:arena_get2.isra.3
 3,542    2    2    884     4    3    149    0    0  /usr/src/debug/glibc-2.17-c758a686/nptl/../nptl/pthread_mutex_lock.c:pthread_mutex_lock
 2,523    4    3    741     2    0    147    0    0  /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_mutex_unlock.c:pthread_mutex_unlock
 2,470    5    5      8     1    0    346    2    2  /usr/src/debug/glibc-2.17-c758a686/stdlib/random_r.c:srandom_r
 2,388   14   14    615    20    0    257    0    0  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:_int_free
 2,216    1    1    687     0    0      7    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/dl-minimal.c:strsep
 2,202   60   59    680    18    7    462    3    2  /usr/src/debug/glibc-2.17-c758a686/stdio-common/vfprintf.c:vfprintf
 2,148   14   14    696    11    9    275   21   21  /usr/src/debug/glibc-2.17-c758a686/elf/dl-version.c:_dl_check_map_versions
 1,759   39   39    434     5    5    195   16   16  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:_dl_map_object_from_fd
 1,708    6    6    648    58    0    134    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-runtime.c:_dl_fixup
 1,701    5    5    237     3    1    171   16   16  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/memcpy.S:mempcpy
 1,688   38   38    362     2    1    157    2    2  /usr/src/debug/glibc-2.17-c758a686/elf/dl-deps.c:_dl_map_object_deps
 1,680    3    3    504     0    0    392    0    0  ???:push_bb
 1,680    2    2    720     1    1      0    0    0  /usr/src/debug////////glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S:pthread_cond_signal@@GLIBC_2.3.2
 1,680    1    1    616     0    0    448    0    0  ???:pop_bb
 1,568   16   16    538     2    2    180    3    3  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:open_path
 1,549    4    4    173     2    2      0    0    0  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-strlen.S:strlen
 1,478   14   14    366    11   11    108    4    4  /usr/src/debug/glibc-2.17-c758a686/string/../string/memcmp.c:bcmp
 1,458    4    4    221    18   18      0    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/dl-cache.c:_dl_cache_libcmp
 1,267   18   18    155     0    0     41    4    4  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:_dl_init_paths
 1,267   15   15    311    12   12    283    4    4  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:open_verify
 1,254    3    3    379     3    0    100    6    6  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:malloc
 1,217    7    7     95     5    5      0    0    0  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-strchr.S:index
 1,189    8    8    258     0    0    149    2    1  /usr/src/debug/glibc-2.17-c758a686/libio/fileops.c:_IO_file_xsputn@@GLIBC_2.2.5
 1,181    5    5    464    18   17    117    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/dl-version.c:match_symbol
 1,040    5    5    174     0    0    172    1    1  /usr/src/debug/glibc-2.17-c758a686/elf/dl-minimal.c:__libc_memalign
 1,029   47   36    858    20    0     72    1    1  ???:???
 1,025   69   69    199    10    9    132    3    3  /usr/src/debug/glibc-2.17-c758a686/stdio-common/printf_fp.c:__printf_fp_l
   960    4    4  1,152     1    0  1,200   62   41  /usr/src/debug////////glibc-2.17-c758a686/elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave
   958   67   67    211    23   13    116   13   12  /usr/src/debug/glibc-2.17-c758a686/elf/rtld.c:dl_main
   952   13   13    200     6    0    208   40   40  /usr/src/debug/glibc-2.17-c758a686/nptl/allocatestack.c:pthread_create@@GLIBC_2.2.5
   938    6    6    149     3    2    124   12   12  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/memcpy.S:memcpy
   913    7    7    144    23   23     85   18   18  /usr/src/debug/glibc-2.17-c758a686/elf/get-dynamic-info.h:_dl_map_object_from_fd
   904    2    2    164     0    0    118    0    0  /usr/src/debug/glibc-2.17-c758a686/stdlib/bsearch.c:bsearch
   883    5    5    192     0    0    162    4    4  /usr/src/debug/glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/wordsize-64/mmap.c:mmap
   849   23   23    191     0    0    143    9    9  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:_dl_map_object
   805    9    7    216     0    0    128    2    1  /usr/src/debug/glibc-2.17-c758a686/libio/fileops.c:_IO_file_overflow@@GLIBC_2.2.5
   796    8    8     90    12    0    210   12   12  ???:comp_thread
   793    3    3      9     0    0    263   33   32  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:malloc_consolidate
   790   12   12    142     5    5    142   27   27  /usr/src/debug/glibc-2.17-c758a686/elf/dl-object.c:_dl_new_object
   734    3    3    187     8    0      0    0    0  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:free
   729    6    6    225     7    0    117    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-tls.c:_dl_allocate_tls_init
   708    3    3     60     1    1     54    0    0  /usr/src/debug/glibc-2.17-c758a686/stdio-common/_itoa.c:_itoa_word
   680   10   10    175     2    0     62    0    0  /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c:calloc
   663   13   13    196     1    1     90   12   12  /usr/src/debug/glibc-2.17-c758a686/malloc/arena.c:arena_get2.isra.3
   655   12   12    219    30    0    133    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/dl-reloc.c:_dl_relocate_object
   641    4    4      9     0    0    320   64   64  /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/memset.S:__GI_memset
   613    2    2     51     0    0      0    0    0  /usr/src/debug/glibc-2.17-c758a686/elf/../string/bits/string2.h:handle_ld_preload
   611   16   16    120    17   17     56    1    1  /usr/src/debug/glibc-2.17-c758a686/elf/dl-cache.c:_dl_load_cache_lookup
   608    4    4    206    34    0     14    1    1  /usr/src/debug/glibc-2.17-c758a686/stdlib/getenv.c:getenv
   584    7    7    160     7    0    120   19   16  /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_create.c:start_thread
   536   15   15    105     0    0    111    4    4  /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c:fillin_rpath
   528    3    3    192     8    0    112    0    0  /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_cond_destroy.c:pthread_cond_destroy@@GLIBC_2.3.2
   488    5    5    160     3    0    184   16   16  /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_create.c:pthread_create@@GLIBC_2.2.5
   477    5    5    107     7    0     96    0    0  /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_join.c:pthread_join
   469    7    7    203    15    1     70    0    0  /usr/src/debug////////glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:pthread_cond_wait@@GLIBC_2.3.2
   416   11   11    113    16   14     28    5    5  /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-sysdep.c:_dl_sysdep_start
   407   11   11     28     0    0     40    0    0  /usr/src/debug/glibc-2.17-c758a686/string/../sysdeps/x86_64/cacheinfo.c:intel_check_word
   393    2    2    110     8    0     58    6    6  /usr/src/debug/glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/libc_pthread_init.c:__libc_pthread_init

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_join.c
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 33 ----------------------------------------
 .    .    .  .    .    .  .    .    .       there is no reason for a loop.  */
 .    .    .  .    .    .  .    .    .    (void) atomic_compare_and_exchange_bool_acq ((struct pthread **) arg, NULL,
 .    .    .  .    .    .  .    .    .  					       THREAD_SELF);
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  int
 .    .    .  .    .    .  .    .    .  pthread_join (pthread_t threadid, void **thread_return)
64    2    2  0    0    0 48    0    0  {
 .    .    .  .    .    .  .    .    .    struct pthread *pd = (struct pthread *) threadid;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Make sure the descriptor is valid.  */
24    0    0  8    1    0  0    0    0    if (INVALID_NOT_TERMINATED_TD_P (pd))
 .    .    .  .    .    .  .    .    .      /* Not a valid thread handle.  */
 .    .    .  .    .    .  .    .    .      return ESRCH;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Is the thread joinable?.  */
24    0    0  8    5    0  0    0    0    if (IS_DETACHED (pd))
 .    .    .  .    .    .  .    .    .      /* We cannot wait for the thread.  */
 8    0    0  0    0    0  0    0    0      return EINVAL;
 .    .    .  .    .    .  .    .    .  
 8    0    0  8    0    0  0    0    0    struct pthread *self = THREAD_SELF;
 .    .    .  .    .    .  .    .    .    int result = 0;
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  0    0    0    LIBC_PROBE (pthread_join, 1, threadid);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* During the wait we change to asynchronous cancellation.  If we
 .    .    .  .    .    .  .    .    .       are canceled the thread we are waiting for must be marked as
 .    .    .  .    .    .  .    .    .       un-wait-ed for again.  */
48    1    1  0    0    0  8    0    0    pthread_cleanup_push (cleanup, &pd->joinid);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Switch to asynchronous cancellation.  */
16    0    0  0    0    0  8    0    0    int oldtype = CANCEL_ASYNC ();
 .    .    .  .    .    .  .    .    .  
16    0    0  0    0    0  0    0    0    if ((pd == self
16    0    0  8    1    0  0    0    0         || (self->joinid == pd
 .    .    .  .    .    .  .    .    .  	   && (pd->cancelhandling
 .    .    .  .    .    .  .    .    .  	       & (CANCELING_BITMASK | CANCELED_BITMASK | EXITING_BITMASK
 .    .    .  .    .    .  .    .    .  		  | TERMINATED_BITMASK)) == 0))
 .    .    .  .    .    .  .    .    .        && !CANCEL_ENABLED_AND_CANCELED (self->cancelhandling))
 .    .    .  .    .    .  .    .    .      /* This is a deadlock situation.  The threads are waiting for each
 .    .    .  .    .    .  .    .    .         other to finish.  Note that this is a "may" error.  To be 100%
 .    .    .  .    .    .  .    .    .         sure we catch this error we would have to lock the data
 .    .    .  .    .    .  .    .    .         structures but it is not necessary.  In the unlikely case that
 .    .    .  .    .    .  .    .    .         two threads are really caught in this situation they will
 .    .    .  .    .    .  .    .    .         deadlock.  It is the programmer's problem to figure this
 .    .    .  .    .    .  .    .    .         out.  */
 .    .    .  .    .    .  .    .    .      result = EDEADLK;
 .    .    .  .    .    .  .    .    .    /* Wait for the thread to finish.  If it is already locked something
 .    .    .  .    .    .  .    .    .       is wrong.  There can only be one waiter.  */
24    0    0  8    0    0  0    0    0    else if (__builtin_expect (atomic_compare_and_exchange_bool_acq (&pd->joinid,
 .    .    .  .    .    .  .    .    .  								   self,
 .    .    .  .    .    .  .    .    .  								   NULL), 0))
 .    .    .  .    .    .  .    .    .      /* There is already somebody waiting for the thread.  */
 .    .    .  .    .    .  .    .    .      result = EINVAL;
 .    .    .  .    .    .  .    .    .    else
 .    .    .  .    .    .  .    .    .      /* Wait for the child.  */
53    1    1 11    0    0  0    0    0      lll_wait_tid (pd->tid);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Restore cancellation mode.  */
16    0    0  0    0    0  8    0    0    CANCEL_RESET (oldtype);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Remove the handler.  */
24    0    0  0    0    0  8    0    0    pthread_cleanup_pop (0);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    if (__builtin_expect (result == 0, 1))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* We mark the thread as terminated and as joined.  */
 8    0    0  0    0    0  8    0    0        pd->tid = -1;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Store the return value if the caller is interested.  */
16    0    0  0    0    0  0    0    0        if (thread_return != NULL)
 .    .    .  .    .    .  .    .    .  	*thread_return = pd->result;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Free the TCB.  */
24    1    1  0    0    0  8    0    0        __free_tcb (pd);
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  0    0    0    LIBC_PROBE (pthread_join_ret, 3, threadid, result, pd->result);
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  0    0    0    return result;
64    0    0 56    0    0  0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/memset.S
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 49 ----------------------------------------
 .    .    .  .    .    .  .    .    .  #if defined PIC && IS_IN (libc)
 .    .    .  .    .    .  .    .    .  ENTRY_CHK (__memset_chk)
 .    .    .  .    .    .  .    .    .  	cmpq	%rdx, %rcx
 .    .    .  .    .    .  .    .    .  	jb	HIDDEN_JUMPTARGET (__chk_fail)
 .    .    .  .    .    .  .    .    .  END_CHK (__memset_chk)
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  ENTRY (memset)
 9    1    1  0    0    0  0    0    0  	movd	%esi, %xmm8
 9    0    0  0    0    0  0    0    0  	movq	%rdi, %rax
 9    0    0  0    0    0  0    0    0  	punpcklbw	%xmm8, %xmm8
 9    0    0  0    0    0  0    0    0  	punpcklwd	%xmm8, %xmm8
 9    0    0  0    0    0  0    0    0  	pshufd	$0, %xmm8, %xmm8
 .    .    .  .    .    .  .    .    .  L(entry_from_bzero):
 9    0    0  0    0    0  0    0    0  	cmpq	$64, %rdx
 9    0    0  0    0    0  0    0    0  	ja	L(loop_start)
 1    0    0  0    0    0  0    0    0  	cmpq	$16, %rdx
 1    0    0  0    0    0  0    0    0  	jbe	L(less_16_bytes)
 1    0    0  0    0    0  0    0    0  	cmpq	$32, %rdx
 1    0    0  0    0    0  1    0    0  	movdqu	%xmm8, (%rdi)
 1    0    0  0    0    0  1    0    0  	movdqu	%xmm8, -16(%rdi,%rdx)
 1    0    0  0    0    0  0    0    0  	ja	L(between_32_64_bytes)
 .    .    .  .    .    .  .    .    .  L(return):
 .    .    .  .    .    .  .    .    .  	rep
 .    .    .  .    .    .  .    .    .  	ret
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	ALIGN (4)
 .    .    .  .    .    .  .    .    .  L(between_32_64_bytes):
 1    1    1  0    0    0  1    0    0  	movdqu	%xmm8, 16(%rdi)
 1    0    0  0    0    0  1    0    0  	movdqu	%xmm8, -32(%rdi,%rdx)
 1    0    0  1    0    0  0    0    0  	ret
 .    .    .  .    .    .  .    .    .  	ALIGN (4)
 .    .    .  .    .    .  .    .    .  L(loop_start):
 8    0    0  0    0    0  0    0    0  	leaq	64(%rdi), %rcx
 8    0    0  0    0    0  8    1    1  	movdqu	%xmm8, (%rdi)
 8    0    0  0    0    0  0    0    0  	andq	$-64, %rcx
 8    0    0  0    0    0  8    0    0  	movdqu	%xmm8, -16(%rdi,%rdx)
 8    0    0  0    0    0  8    6    6  	movdqu	%xmm8, 16(%rdi)
 8    0    0  0    0    0  8    1    1  	movdqu	%xmm8, -32(%rdi,%rdx)
 8    0    0  0    0    0  8    1    1  	movdqu	%xmm8, 32(%rdi)
 8    0    0  0    0    0  8    6    6  	movdqu	%xmm8, -48(%rdi,%rdx)
 8    1    1  0    0    0  8    0    0  	movdqu	%xmm8, 48(%rdi)
 8    0    0  0    0    0  8    1    1  	movdqu	%xmm8, -64(%rdi,%rdx)
 8    0    0  0    0    0  0    0    0  	addq	%rdi, %rdx
 8    0    0  0    0    0  0    0    0  	andq	$-64, %rdx
 8    0    0  0    0    0  0    0    0  	cmpq	%rdx, %rcx
16    0    0  0    0    0  0    0    0  	je	L(return)
 .    .    .  .    .    .  .    .    .  	ALIGN (4)
 .    .    .  .    .    .  .    .    .  L(loop):
63    0    0  0    0    0 63   48   48  	movdqa	%xmm8, (%rcx)
63    0    0  0    0    0 63    0    0  	movdqa	%xmm8, 16(%rcx)
63    0    0  0    0    0 63    0    0  	movdqa	%xmm8, 32(%rcx)
63    0    0  0    0    0 63    0    0  	movdqa	%xmm8, 48(%rcx)
63    0    0  0    0    0  0    0    0  	addq	$64, %rcx
63    0    0  0    0    0  0    0    0  	cmpq	%rcx, %rdx
63    0    0  0    0    0  0    0    0  	jne	L(loop)
 8    1    1  8    0    0  0    0    0  	rep
 .    .    .  .    .    .  .    .    .  	ret
 .    .    .  .    .    .  .    .    .  L(less_16_bytes):
 .    .    .  .    .    .  .    .    .  	movq %xmm8, %rcx
 .    .    .  .    .    .  .    .    .  	testb	$24, %dl
 .    .    .  .    .    .  .    .    .  	jne	L(between8_16bytes)
 .    .    .  .    .    .  .    .    .  	testb	$4, %dl
 .    .    .  .    .    .  .    .    .  	jne	L(between4_7bytes)
 .    .    .  .    .    .  .    .    .  	testb	$1, %dl
-- line 113 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/get-dynamic-info.h
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 21 ----------------------------------------
  .    .    .   .    .    .   .    .    .  #ifndef RESOLVE_MAP
  .    .    .   .    .    .   .    .    .  static
  .    .    .   .    .    .   .    .    .  #else
  .    .    .   .    .    .   .    .    .  auto
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  inline void __attribute__ ((unused, always_inline))
  .    .    .   .    .    .   .    .    .  elf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)
  .    .    .   .    .    .   .    .    .  {
  1    0    0   1    0    0   0    0    0    ElfW(Dyn) *dyn = l->l_ld;
  .    .    .   .    .    .   .    .    .    ElfW(Dyn) **info;
  .    .    .   .    .    .   .    .    .  #if __ELF_NATIVE_CLASS == 32
  .    .    .   .    .    .   .    .    .    typedef Elf32_Word d_tag_utype;
  .    .    .   .    .    .   .    .    .  #elif __ELF_NATIVE_CLASS == 64
  .    .    .   .    .    .   .    .    .    typedef Elf64_Xword d_tag_utype;
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifndef RTLD_BOOTSTRAP
  8    0    0   0    0    0   0    0    0    if (dyn == NULL)
  .    .    .   .    .    .   .    .    .      return;
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   0    0    0    info = l->l_info;
  .    .    .   .    .    .   .    .    .  
375    1    1 125   35   35   0    0    0    while (dyn->d_tag != DT_NULL)
  .    .    .   .    .    .   .    .    .      {
240    2    2   0    0    0   0    0    0        if ((d_tag_utype) dyn->d_tag < DT_NUM)
 28    0    0   0    0    0  14    4    4  	info[dyn->d_tag] = dyn;
  .    .    .   .    .    .   .    .    .        else if (dyn->d_tag >= DT_LOPROC &&
  .    .    .   .    .    .   .    .    .  	       dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
  .    .    .   .    .    .   .    .    .  	info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;
117    1    1   0    0    0   0    0    0        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
184    1    1   0    0    0 102   26   26  	info[VERSYMIDX (dyn->d_tag)] = dyn;
 16    2    2   0    0    0   0    0    0        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
  .    .    .   .    .    .   .    .    .  	info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
  5    0    0   0    0    0   0    0    0  	     + DT_VERSIONTAGNUM] = dyn;
 21    2    2   0    0    0   0    0    0        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
  .    .    .   .    .    .   .    .    .  	info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
  6    0    0   0    0    0   0    0    0  	     + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
 21    0    0   0    0    0   0    0    0        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
  4    1    1   0    0    0   0    0    0  	info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
 18    0    0   0    0    0   4    1    1  	     + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
120    0    0   0    0    0   0    0    0        ++dyn;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #define DL_RO_DYN_TEMP_CNT	8
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifndef DL_RO_DYN_SECTION
  .    .    .   .    .    .   .    .    .    /* Don't adjust .dynamic unnecessarily.  */
 11    1    1   1    0    0   0    0    0    if (l->l_addr != 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        ElfW(Addr) l_addr = l->l_addr;
  .    .    .   .    .    .   .    .    .        int cnt = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  # define ADJUST_DYN_INFO(tag) \
  .    .    .   .    .    .   .    .    .        do								      \
  .    .    .   .    .    .   .    .    .  	if (info[tag] != NULL)						      \
  .    .    .   .    .    .   .    .    .  	  {								      \
-- line 77 ----------------------------------------
-- line 81 ----------------------------------------
  .    .    .   .    .    .   .    .    .  		temp[cnt].d_un.d_ptr = info[tag]->d_un.d_ptr + l_addr;	      \
  .    .    .   .    .    .   .    .    .  		info[tag] = temp + cnt++;				      \
  .    .    .   .    .    .   .    .    .  	      }								      \
  .    .    .   .    .    .   .    .    .  	    else							      \
  .    .    .   .    .    .   .    .    .  	      info[tag]->d_un.d_ptr += l_addr;				      \
  .    .    .   .    .    .   .    .    .  	  }								      \
  .    .    .   .    .    .   .    .    .        while (0)
  .    .    .   .    .    .   .    .    .  
 15    1    1   7    0    0   0    0    0        ADJUST_DYN_INFO (DT_HASH);
 16    0    0   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_PLTGOT);
 16    1    1   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_STRTAB);
 16    0    0   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_SYMTAB);
  .    .    .   .    .    .   .    .    .  # if ! ELF_MACHINE_NO_RELA
 16    1    1   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_RELA);
  .    .    .   .    .    .   .    .    .  # endif
  .    .    .   .    .    .   .    .    .  # if ! ELF_MACHINE_NO_REL
  .    .    .   .    .    .   .    .    .        ADJUST_DYN_INFO (DT_REL);
  .    .    .   .    .    .   .    .    .  # endif
 16    0    0   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_JMPREL);
 15    0    0   7    1    1   0    0    0        ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));
 16    1    1   8    0    0   0    0    0        ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM
  .    .    .   .    .    .   .    .    .  		       + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);
  .    .    .   .    .    .   .    .    .  # undef ADJUST_DYN_INFO
  .    .    .   .    .    .   .    .    .        assert (cnt <= DL_RO_DYN_TEMP_CNT);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .    if (info[DT_PLTREL] != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #if ELF_MACHINE_NO_RELA
-- line 109 ----------------------------------------
-- line 128 ----------------------------------------
  .    .    .   .    .    .   .    .    .    assert (info[VERSYMIDX (DT_FLAGS_1)] == NULL
  .    .    .   .    .    .   .    .    .  	  || (info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val & ~DF_1_NOW) == 0);
  .    .    .   .    .    .   .    .    .    assert (info[DT_FLAGS] == NULL
  .    .    .   .    .    .   .    .    .  	  || (info[DT_FLAGS]->d_un.d_val & ~DF_BIND_NOW) == 0);
  .    .    .   .    .    .   .    .    .    /* Flags must not be set for ld.so.  */
  .    .    .   .    .    .   .    .    .    assert (info[DT_RUNPATH] == NULL);
  .    .    .   .    .    .   .    .    .    assert (info[DT_RPATH] == NULL);
  .    .    .   .    .    .   .    .    .  #else
 12    1    1   4    0    0   0    0    0    if (info[DT_FLAGS] != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Flags are used.  Translate to the old form where available.
  .    .    .   .    .    .   .    .    .  	 Since these l_info entries are only tested for NULL pointers it
  .    .    .   .    .    .   .    .    .  	 is ok if they point to the DT_FLAGS entry.  */
  4    0    0   2    0    0   2    0    0        l->l_flags = info[DT_FLAGS]->d_un.d_val;
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   0    0    0        if (l->l_flags & DF_SYMBOLIC)
  .    .    .   .    .    .   .    .    .  	info[DT_SYMBOLIC] = info[DT_FLAGS];
  4    0    0   0    0    0   0    0    0        if (l->l_flags & DF_TEXTREL)
  .    .    .   .    .    .   .    .    .  	info[DT_TEXTREL] = info[DT_FLAGS];
  4    0    0   0    0    0   0    0    0        if (l->l_flags & DF_BIND_NOW)
  2    0    0   0    0    0   2    0    0  	info[DT_BIND_NOW] = info[DT_FLAGS];
  .    .    .   .    .    .   .    .    .      }
 12    2    2   4    1    1   0    0    0    if (info[VERSYMIDX (DT_FLAGS_1)] != NULL)
  .    .    .   .    .    .   .    .    .      {
  6    0    0   3    0    0   3    0    0        l->l_flags_1 = info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Only DT_1_SUPPORTED_MASK bits are supported, and we would like
  .    .    .   .    .    .   .    .    .  	 to assert this, but we can't. Users have been setting
  .    .    .   .    .    .   .    .    .  	 unsupported DF_1_* flags for a long time and glibc has ignored
  .    .    .   .    .    .   .    .    .  	 them. Therefore to avoid breaking existing applications the
  .    .    .   .    .    .   .    .    .  	 best we can do is add a warning during debugging with the
  .    .    .   .    .    .   .    .    .  	 intent of notifying the user of the problem.  */
  6    0    0   3    0    0   0    0    0        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0)
  6    0    0   0    0    0   0    0    0  	  && l->l_flags_1 & ~DT_1_SUPPORTED_MASK)
  .    .    .   .    .    .   .    .    .  	_dl_debug_printf ("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n",
  .    .    .   .    .    .   .    .    .  			  l->l_flags_1 & ~DT_1_SUPPORTED_MASK);
  .    .    .   .    .    .   .    .    .  
  6    1    1   0    0    0   0    0    0        if (l->l_flags_1 & DF_1_NOW)
  4    0    0   2    0    0   2    0    0  	info[DT_BIND_NOW] = info[VERSYMIDX (DT_FLAGS_1)];
  .    .    .   .    .    .   .    .    .      }
  8    0    0   4    0    0   0    0    0    if (info[DT_RUNPATH] != NULL)
  .    .    .   .    .    .   .    .    .      /* If both RUNPATH and RPATH are given, the latter is ignored.  */
  .    .    .   .    .    .   .    .    .      info[DT_RPATH] = NULL;
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-runtime.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 58 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  DL_FIXUP_VALUE_TYPE
  .    .    .  .    .    .  .    .    .  __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE
  .    .    .  .    .    .  .    .    .  _dl_fixup (
  .    .    .  .    .    .  .    .    .  # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
  .    .    .  .    .    .  .    .    .  	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,
  .    .    .  .    .    .  .    .    .  # endif
  .    .    .  .    .    .  .    .    .  	   struct link_map *l, ElfW(Word) reloc_arg)
 72    1    1  0    0    0 24    0    0  {
  .    .    .  .    .    .  .    .    .    const ElfW(Sym) *const symtab
 24    0    0 24    2    0  0    0    0      = (const void *) D_PTR (l, l_info[DT_SYMTAB]);
 48    0    0 48    4    0  0    0    0    const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    const PLTREL *const reloc
120    1    1 48    6    0  0    0    0      = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);
120    0    0 48   16    0 24    0    0    const ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)];
 72    0    0 48    4    0  0    0    0    void *const rel_addr = (void *)(l->l_addr + reloc->r_offset);
  .    .    .  .    .    .  .    .    .    lookup_t result;
  .    .    .  .    .    .  .    .    .    DL_FIXUP_VALUE_TYPE value;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Sanity check that we're really looking at a PLT relocation.  */
  .    .    .  .    .    .  .    .    .    assert (ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .     /* Look up the target symbol.  If the normal lookup rules are not
  .    .    .  .    .    .  .    .    .        used don't look in the global scope.  */
 48    0    0 24    8    0  0    0    0    if (__builtin_expect (ELFW(ST_VISIBILITY) (sym->st_other), 0) == 0)
  .    .    .  .    .    .  .    .    .      {
  2    0    0  0    0    0  0    0    0        const struct r_found_version *version = NULL;
  .    .    .  .    .    .  .    .    .  
 72    0    0 24    2    0  0    0    0        if (l->l_info[VERSYMIDX (DT_VERSYM)] != NULL)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  const ElfW(Half) *vernum =
  .    .    .  .    .    .  .    .    .  	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);
 46    1    1 46    4    0  0    0    0  	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc->r_info)] & 0x7fff;
 92    0    0 23    1    0  0    0    0  	  version = &l->l_versions[ndx];
  .    .    .  .    .    .  .    .    .  	  if (version->hash == 0)
 92    0    0 23    5    0  0    0    0  	    version = NULL;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* We need to keep the scope around so do some locking.  This is
  .    .    .  .    .    .  .    .    .  	 not necessary for objects which cannot be unloaded or when
  .    .    .  .    .    .  .    .    .  	 we are not using any threads (yet).  */
 10    1    1  0    0    0  0    0    0        int flags = DL_LOOKUP_ADD_DEPENDENCY;
 72    0    0 24    2    0  0    0    0        if (!RTLD_SINGLE_THREAD_P)
  .    .    .  .    .    .  .    .    .  	{
 14    1    1  0    0    0 14    0    0  	  THREAD_GSCOPE_SET_FLAG ();
 28    0    0  0    0    0  0    0    0  	  flags |= DL_LOOKUP_GSCOPE_LOCK;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef RTLD_ENABLE_FOREIGN_CALL
  .    .    .  .    .    .  .    .    .        RTLD_ENABLE_FOREIGN_CALL;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
240    0    0 48    2    0 72    0    0        result = _dl_lookup_symbol_x (strtab + sym->st_name, l, &sym, l->l_scope,
  .    .    .  .    .    .  .    .    .  				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* We are done with the global scope.  */
 72    0    0 24    0    0  0    0    0        if (!RTLD_SINGLE_THREAD_P)
 56    0    0 28    0    0  0    0    0  	THREAD_GSCOPE_RESET_FLAG ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef RTLD_FINALIZE_FOREIGN_CALL
  .    .    .  .    .    .  .    .    .        RTLD_FINALIZE_FOREIGN_CALL;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Currently result contains the base load address (or link map)
  .    .    .  .    .    .  .    .    .  	 of the object that defines sym.  Now add in the symbol
  .    .    .  .    .    .  .    .    .  	 offset.  */
144    1    1 48    1    0  0    0    0        value = DL_FIXUP_MAKE_VALUE (result,
  .    .    .  .    .    .  .    .    .  				   sym ? (LOOKUP_VALUE_ADDRESS (result)
  .    .    .  .    .    .  .    .    .  					  + sym->st_value) : 0);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* We already found the symbol.  The module (and therefore its load
  .    .    .  .    .    .  .    .    .  	 address) is also known.  */
 24    0    0 24    0    0  0    0    0        value = DL_FIXUP_MAKE_VALUE (l, l->l_addr + sym->st_value);
  .    .    .  .    .    .  .    .    .        result = l;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* And now perhaps the relocation addend.  */
  .    .    .  .    .    .  .    .    .    value = elf_machine_plt_value (l, reloc, value);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    if (sym != NULL
 96    0    0 24    0    0  0    0    0        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0))
  .    .    .  .    .    .  .    .    .      value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Finally, fix up the plt itself.  */
 72    0    0 24    1    0  0    0    0    if (__builtin_expect (GLRO(dl_bind_not), 0))
  .    .    .  .    .    .  .    .    .      return value;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return elf_machine_fixup_plt (l, result, reloc, rel_addr, value);
 72    0    0 48    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef PROF
  .    .    .  .    .    .  .    .    .  DL_FIXUP_VALUE_TYPE
  .    .    .  .    .    .  .    .    .  __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE
  .    .    .  .    .    .  .    .    .  _dl_profile_fixup (
  .    .    .  .    .    .  .    .    .  #ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS
  .    .    .  .    .    .  .    .    .  		   ELF_MACHINE_RUNTIME_FIXUP_ARGS,
  .    .    .  .    .    .  .    .    .  #endif
-- line 157 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/libc_pthread_init.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 33 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .  extern int __libc_multiple_threads attribute_hidden;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  int *
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  __libc_pthread_init (unsigned long int *ptr, void (*reclaim) (void),
  .    .    .  .    .    .  .    .    .  		     const struct pthread_functions *functions)
  2    1    1  0    0    0  1    0    0  {
  .    .    .  .    .    .  .    .    .    /* Remember the pointer to the generation counter in libpthread.  */
  1    0    0  0    0    0  1    0    0    __fork_generation_pointer = ptr;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Called by a child after fork.  */
  6    0    0  0    0    0  1    0    0    __register_atfork (NULL, NULL, reclaim, NULL);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .    /* Copy the function pointers into an array in libc.  This enables
  .    .    .  .    .    .  .    .    .       access with just one memory reference but moreso, it prevents
  .    .    .  .    .    .  .    .    .       hijacking the function pointers with just one pointer change.  We
  .    .    .  .    .    .  .    .    .       "encrypt" the function pointers since we cannot write-protect the
  .    .    .  .    .    .  .    .    .       array easily enough.  */
  .    .    .  .    .    .  .    .    .    union ptrhack
-- line 54 ----------------------------------------
-- line 57 ----------------------------------------
  .    .    .  .    .    .  .    .    .  # define NPTRS (sizeof (struct pthread_functions) / sizeof (void *))
  .    .    .  .    .    .  .    .    .      void *parr[NPTRS];
  .    .    .  .    .    .  .    .    .    } __attribute__ ((may_alias)) const *src;
  .    .    .  .    .    .  .    .    .    union ptrhack *dest;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    src = (const void *) functions;
  .    .    .  .    .    .  .    .    .    dest = (void *) &__libc_pthread_functions;
  .    .    .  .    .    .  .    .    .  
164    0    0  0    0    0  0    0    0    for (size_t cnt = 0; cnt < NPTRS; ++cnt)
  .    .    .  .    .    .  .    .    .      {
 54    0    0 54    8    0  0    0    0        void *p = src->parr[cnt];
108    1    1 54    0    0  0    0    0        PTR_MANGLE (p);
 54    0    0  0    0    0 54    6    6        dest->parr[cnt] = p;
  .    .    .  .    .    .  .    .    .      }
  1    0    0  0    0    0  1    0    0    __libc_pthread_functions_init = 1;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef TLS_MULTIPLE_THREADS_IN_TCB
  .    .    .  .    .    .  .    .    .    return &__libc_multiple_threads;
  .    .    .  .    .    .  .    .    .  #endif
  3    0    0  2    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .  libc_freeres_fn (freeres_libptread)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    if (__libc_pthread_functions_init)
  .    .    .  .    .    .  .    .    .      PTHFCT_CALL (ptr_freeres, ());
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  #endif
-- line 85 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/elf/../sysdeps/x86_64/dl-trampoline.h
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 63 ----------------------------------------
 .    .    .   .    .    .   .    .    .  	.align 16
 .    .    .   .    .    .   .    .    .  	cfi_startproc
 .    .    .   .    .    .   .    .    .  _dl_runtime_resolve:
 .    .    .   .    .    .   .    .    .  	cfi_adjust_cfa_offset(16) # Incorporate PLT
 .    .    .   .    .    .   .    .    .  # if DL_RUNTIME_RESOLVE_REALIGN_STACK
 .    .    .   .    .    .   .    .    .  #  if LOCAL_STORAGE_AREA != 8
 .    .    .   .    .    .   .    .    .  #   error LOCAL_STORAGE_AREA must be 8
 .    .    .   .    .    .   .    .    .  #  endif
24    1    1   0    0    0  24    0    0  	pushq %rbx			# push subtracts stack by 8.
 .    .    .   .    .    .   .    .    .  	cfi_adjust_cfa_offset(8)
 .    .    .   .    .    .   .    .    .  	cfi_rel_offset(%rbx, 0)
24    0    0   0    0    0   0    0    0  	mov %RSP_LP, %RBX_LP
 .    .    .   .    .    .   .    .    .  	cfi_def_cfa_register(%rbx)
24    0    0   0    0    0   0    0    0  	and $-STATE_SAVE_ALIGNMENT, %RSP_LP
 .    .    .   .    .    .   .    .    .  # endif
 .    .    .   .    .    .   .    .    .  # ifdef REGISTER_SAVE_AREA
 .    .    .   .    .    .   .    .    .  	sub $REGISTER_SAVE_AREA, %RSP_LP
 .    .    .   .    .    .   .    .    .  #  if !DL_RUNTIME_RESOLVE_REALIGN_STACK
 .    .    .   .    .    .   .    .    .  	cfi_adjust_cfa_offset(REGISTER_SAVE_AREA)
 .    .    .   .    .    .   .    .    .  #  endif
 .    .    .   .    .    .   .    .    .  # else
 .    .    .   .    .    .   .    .    .  	# Allocate stack space of the required size to save the state.
 .    .    .   .    .    .   .    .    .  #  if IS_IN (rtld)
24    0    0  24    1    0   0    0    0  	sub _rtld_local_ro+RTLD_GLOBAL_RO_DL_X86_CPU_FEATURES_OFFSET+XSAVE_STATE_SIZE_OFFSET(%rip), %RSP_LP
 .    .    .   .    .    .   .    .    .  #  else
 .    .    .   .    .    .   .    .    .  	sub _dl_x86_cpu_features+XSAVE_STATE_SIZE_OFFSET(%rip), %RSP_LP
 .    .    .   .    .    .   .    .    .  #  endif
 .    .    .   .    .    .   .    .    .  # endif
 .    .    .   .    .    .   .    .    .  	# Preserve registers otherwise clobbered.
24    0    0   0    0    0  24    6    4  	movq %rax, REGISTER_SAVE_RAX(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rcx, REGISTER_SAVE_RCX(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, REGISTER_SAVE_RDX(%rsp)
24    1    1   0    0    0  24    0    0  	movq %rsi, REGISTER_SAVE_RSI(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdi, REGISTER_SAVE_RDI(%rsp)
24    0    0   0    0    0  24    0    0  	movq %r8, REGISTER_SAVE_R8(%rsp)
24    0    0   0    0    0  24    0    0  	movq %r9, REGISTER_SAVE_R9(%rsp)
 .    .    .   .    .    .   .    .    .  # ifdef USE_FXSAVE
 .    .    .   .    .    .   .    .    .  	fxsave STATE_SAVE_OFFSET(%rsp)
 .    .    .   .    .    .   .    .    .  # else
24    0    0   0    0    0   0    0    0  	movl $STATE_SAVE_MASK, %eax
24    0    0   0    0    0   0    0    0  	xorl %edx, %edx
 .    .    .   .    .    .   .    .    .  	# Clear the XSAVE Header.
 .    .    .   .    .    .   .    .    .  #  ifdef USE_XSAVE
24    0    0   0    0    0  24    4    2  	movq %rdx, (STATE_SAVE_OFFSET + 512)(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8)(%rsp)
 .    .    .   .    .    .   .    .    .  #  endif
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 2)(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 3)(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 4)(%rsp)
24    1    1   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 5)(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 6)(%rsp)
24    0    0   0    0    0  24    0    0  	movq %rdx, (STATE_SAVE_OFFSET + 512 + 8 * 7)(%rsp)
 .    .    .   .    .    .   .    .    .  #  ifdef USE_XSAVE
24    0    0  24    0    0 792   46   31  	xsave STATE_SAVE_OFFSET(%rsp)
 .    .    .   .    .    .   .    .    .  #  else
 .    .    .   .    .    .   .    .    .  	# Since glibc 2.23 requires only binutils 2.22 or later, xsavec
 .    .    .   .    .    .   .    .    .  	# may not be supported.  Use .byte directive instead.
 .    .    .   .    .    .   .    .    .  #   if STATE_SAVE_OFFSET != 0x40
 .    .    .   .    .    .   .    .    .  #    error STATE_SAVE_OFFSET != 0x40
 .    .    .   .    .    .   .    .    .  #   endif
 .    .    .   .    .    .   .    .    .  	# xsavec STATE_SAVE_OFFSET(%rsp)
 .    .    .   .    .    .   .    .    .  	.byte 0x0f, 0xc7, 0x64, 0x24, 0x40
 .    .    .   .    .    .   .    .    .  #  endif
 .    .    .   .    .    .   .    .    .  # endif
 .    .    .   .    .    .   .    .    .  	# Copy args pushed by PLT in register.
 .    .    .   .    .    .   .    .    .  	# %rdi: link_map, %rsi: reloc_index
24    0    0  24    0    0   0    0    0  	mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP
24    0    0  24    0    0   0    0    0  	mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP
24    0    0   0    0    0  24    6    4  	call _dl_fixup		# Call resolver.
24    0    0   0    0    0   0    0    0  	mov %RAX_LP, %R11_LP	# Save return value
 .    .    .   .    .    .   .    .    .  	# Get register content back.
 .    .    .   .    .    .   .    .    .  # ifdef USE_FXSAVE
 .    .    .   .    .    .   .    .    .  	fxrstor STATE_SAVE_OFFSET(%rsp)
 .    .    .   .    .    .   .    .    .  # else
24    0    0   0    0    0   0    0    0  	movl $STATE_SAVE_MASK, %eax
24    0    0   0    0    0   0    0    0  	xorl %edx, %edx
24    0    0 864    0    0   0    0    0  	xrstor STATE_SAVE_OFFSET(%rsp)
 .    .    .   .    .    .   .    .    .  # endif
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_R9(%rsp), %r9
24    1    1  24    0    0   0    0    0  	movq REGISTER_SAVE_R8(%rsp), %r8
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_RDI(%rsp), %rdi
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_RSI(%rsp), %rsi
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_RDX(%rsp), %rdx
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_RCX(%rsp), %rcx
24    0    0  24    0    0   0    0    0  	movq REGISTER_SAVE_RAX(%rsp), %rax
 .    .    .   .    .    .   .    .    .  # if DL_RUNTIME_RESOLVE_REALIGN_STACK
24    0    0   0    0    0   0    0    0  	mov %RBX_LP, %RSP_LP
 .    .    .   .    .    .   .    .    .  	cfi_def_cfa_register(%rsp)
24    0    0  24    0    0   0    0    0  	movq (%rsp), %rbx
 .    .    .   .    .    .   .    .    .  	cfi_restore(%rbx)
 .    .    .   .    .    .   .    .    .  # endif
 .    .    .   .    .    .   .    .    .  	# Adjust stack(PLT did 2 pushes)
24    0    0   0    0    0   0    0    0  	add $(LOCAL_STORAGE_AREA + 16), %RSP_LP
 .    .    .   .    .    .   .    .    .  	cfi_adjust_cfa_offset(-(LOCAL_STORAGE_AREA + 16))
 .    .    .   .    .    .   .    .    .  	# Preserve bound registers.
24    0    0   0    0    0   0    0    0  	PRESERVE_BND_REGS_PREFIX
 .    .    .   .    .    .   .    .    .  	jmp *%r11		# Jump to function address.
 .    .    .   .    .    .   .    .    .  	cfi_endproc
 .    .    .   .    .    .   .    .    .  	.size _dl_runtime_resolve, .-_dl_runtime_resolve
 .    .    .   .    .    .   .    .    .  #endif
 .    .    .   .    .    .   .    .    .  
 .    .    .   .    .    .   .    .    .  
 .    .    .   .    .    .   .    .    .  #if !defined PROF && defined _dl_runtime_profile
 .    .    .   .    .    .   .    .    .  # if (LR_VECTOR_OFFSET % VEC_SIZE) != 0
-- line 166 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdlib/getenv.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 26 ----------------------------------------
  .    .    .  .    .    .  .    .    .  /* Return the value of the environment variable NAME.  This implementation
  .    .    .  .    .    .  .    .    .     is tuned a bit in that it assumes no environment variable has an empty
  .    .    .  .    .    .  .    .    .     name which of course should always be true.  We have a special case for
  .    .    .  .    .    .  .    .    .     one character names so that for the general case we can assume at least
  .    .    .  .    .    .  .    .    .     two characters which we can access.  By doing this we can avoid using the
  .    .    .  .    .    .  .    .    .     `strncmp' most of the time.  */
  .    .    .  .    .    .  .    .    .  char *
  .    .    .  .    .    .  .    .    .  getenv (const char *name)
 16    1    1  0    0    0 12    0    0  {
  4    0    0  0    0    0  2    1    1    size_t len = strlen (name);
  .    .    .  .    .    .  .    .    .    char **ep;
  .    .    .  .    .    .  .    .    .    uint16_t name_start;
  .    .    .  .    .    .  .    .    .  
 14    1    1  6    1    0  0    0    0    if (__environ == NULL || name[0] == '\0')
  .    .    .  .    .    .  .    .    .      return NULL;
  .    .    .  .    .    .  .    .    .  
  4    0    0  2    0    0  0    0    0    if (name[1] == '\0')
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* The name of the variable consists of only one character.  Therefore
  .    .    .  .    .    .  .    .    .  	 the first two characters of the environment entry are this character
  .    .    .  .    .    .  .    .    .  	 and a '=' character.  */
  .    .    .  .    .    .  .    .    .  #if __BYTE_ORDER == __LITTLE_ENDIAN || !_STRING_ARCH_unaligned
  .    .    .  .    .    .  .    .    .        name_start = ('=' << 8) | *(const unsigned char *) name;
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .  # if __BYTE_ORDER == __BIG_ENDIAN
-- line 50 ----------------------------------------
-- line 63 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  	  if (name_start == ep_start)
  .    .    .  .    .    .  .    .    .  	    return &(*ep)[2];
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .  #if _STRING_ARCH_unaligned
  2    1    1  2    0    0  0    0    0        name_start = *(const uint16_t *) name;
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .        name_start = (((const unsigned char *) name)[0]
  .    .    .  .    .    .  .    .    .  		    | (((const unsigned char *) name)[1] << 8));
  .    .    .  .    .    .  .    .    .  #endif
  2    0    0  0    0    0  0    0    0        len -= 2;
  2    0    0  0    0    0  0    0    0        name += 2;
  .    .    .  .    .    .  .    .    .  
366    0    0 92    6    0  0    0    0        for (ep = __environ; *ep != NULL; ++ep)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  #if _STRING_ARCH_unaligned
  .    .    .  .    .    .  .    .    .  	  uint16_t ep_start = *(uint16_t *) *ep;
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .  	  uint16_t ep_start = (((unsigned char *) *ep)[0]
  .    .    .  .    .    .  .    .    .  			       | (((unsigned char *) *ep)[1] << 8));
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
180    1    1 90   27    0  0    0    0  	  if (name_start == ep_start && !strncmp (*ep + 2, name, len)
  .    .    .  .    .    .  .    .    .  	      && (*ep)[len + 2] == '=')
  .    .    .  .    .    .  .    .    .  	    return &(*ep)[len + 3];
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return NULL;
 18    0    0 14    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  libc_hidden_def (getenv)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../string/bits/string2.h
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 976 ----------------------------------------
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  __STRING_INLINE size_t __strcspn_c2 (const char *__s, int __reject1,
  .    .    .  .    .    .  .    .    .  				     int __reject2);
  .    .    .  .    .    .  .    .    .  __STRING_INLINE size_t
  .    .    .  .    .    .  .    .    .  __strcspn_c2 (const char *__s, int __reject1, int __reject2)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    size_t __result = 0;
407    2    2 51    0    0  0    0    0    while (__s[__result] != '\0' && __s[__result] != __reject1
105    0    0  0    0    0  0    0    0  	 && __s[__result] != __reject2)
101    0    0  0    0    0  0    0    0      ++__result;
  .    .    .  .    .    .  .    .    .    return __result;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  __STRING_INLINE size_t __strcspn_c3 (const char *__s, int __reject1,
  .    .    .  .    .    .  .    .    .  				     int __reject2, int __reject3);
  .    .    .  .    .    .  .    .    .  __STRING_INLINE size_t
  .    .    .  .    .    .  .    .    .  __strcspn_c3 (const char *__s, int __reject1, int __reject2,
  .    .    .  .    .    .  .    .    .  	      int __reject3)
-- line 994 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-cache.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 131 ----------------------------------------
  .    .    .   .    .    .  .    .    .        }									      \
  .    .    .   .    .    .  .    .    .    }									      \
  .    .    .   .    .    .  .    .    .  while (0)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  int
  .    .    .   .    .    .  .    .    .  internal_function
  .    .    .   .    .    .  .    .    .  _dl_cache_libcmp (const char *p1, const char *p2)
 57    1    1  38   18   18  0    0    0  {
202    1    1   0    0    0  0    0    0    while (*p1 != '\0')
  .    .    .   .    .    .  .    .    .      {
297    0    0   0    0    0  0    0    0        if (*p1 >= '0' && *p1 <= '9')
  .    .    .   .    .    .  .    .    .          {
103    0    0   0    0    0  0    0    0            if (*p2 >= '0' && *p2 <= '9')
  .    .    .   .    .    .  .    .    .              {
  .    .    .   .    .    .  .    .    .  	      /* Must compare this numerically.  */
  .    .    .   .    .    .  .    .    .  	      int val1;
  .    .    .   .    .    .  .    .    .  	      int val2;
  .    .    .   .    .    .  .    .    .  
  6    0    0   0    0    0  0    0    0  	      val1 = *p1++ - '0';
  4    0    0   0    0    0  0    0    0  	      val2 = *p2++ - '0';
  8    0    0   2    0    0  0    0    0  	      while (*p1 >= '0' && *p1 <= '9')
  .    .    .   .    .    .  .    .    .  	        val1 = val1 * 10 + *p1++ - '0';
 10    1    1   2    0    0  0    0    0  	      while (*p2 >= '0' && *p2 <= '9')
  .    .    .   .    .    .  .    .    .  	        val2 = val2 * 10 + *p2++ - '0';
  4    0    0   0    0    0  0    0    0  	      if (val1 != val2)
  .    .    .   .    .    .  .    .    .  		return val1 - val2;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	  else
  .    .    .   .    .    .  .    .    .              return 1;
  .    .    .   .    .    .  .    .    .          }
194    1    1   0    0    0  0    0    0        else if (*p2 >= '0' && *p2 <= '9')
  .    .    .   .    .    .  .    .    .          return -1;
354    0    0 160    0    0  0    0    0        else if (*p1 != *p2)
 17    0    0   0    0    0  0    0    0          return *p1 - *p2;
  .    .    .   .    .    .  .    .    .        else
  .    .    .   .    .    .  .    .    .  	{
 80    0    0   0    0    0  0    0    0  	  ++p1;
 80    0    0   0    0    0  0    0    0  	  ++p2;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .      }
  4    0    0   0    0    0  0    0    0    return *p1 - *p2;
 38    0    0  19    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* Look up NAME in ld.so.cache and return the file name stored there,
  .    .    .   .    .    .  .    .    .     or null if none is found. 
  .    .    .   .    .    .  .    .    .     The caller is responsible for freeing the returned string.  The ld.so.cache
  .    .    .   .    .    .  .    .    .     may be unmapped at any time by a completing recursive dlopen and
  .    .    .   .    .    .  .    .    .     this function must take care that it does not return references to
  .    .    .   .    .    .  .    .    .     any data in the mapping.  */
  .    .    .   .    .    .  .    .    .  char *
  .    .    .   .    .    .  .    .    .  internal_function
  .    .    .   .    .    .  .    .    .  _dl_load_cache_lookup (const char *name)
 18    1    1   0    0    0 12    0    0  {
  .    .    .   .    .    .  .    .    .    int left, right, middle;
  .    .    .   .    .    .  .    .    .    int cmpres;
  .    .    .   .    .    .  .    .    .    const char *cache_data;
  .    .    .   .    .    .  .    .    .    uint32_t cache_data_size;
  .    .    .   .    .    .  .    .    .    const char *best;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Print a message if the loading of libs is traced.  */
  4    1    1   2    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
  .    .    .   .    .    .  .    .    .      _dl_debug_printf (" search cache=%s\n", LD_SO_CACHE);
  .    .    .   .    .    .  .    .    .  
  6    0    0   2    0    0  0    0    0    if (cache == NULL)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Read the contents of the file.  */
  5    1    1   0    0    0  1    1    1        void *file = _dl_sysdep_read_whole_file (LD_SO_CACHE, &cachesize,
  .    .    .   .    .    .  .    .    .  					       PROT_READ);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* We can handle three different cache file formats here:
  .    .    .   .    .    .  .    .    .  	 - the old libc5/glibc2.0/2.1 format
  .    .    .   .    .    .  .    .    .  	 - the old format with the new format in it
  .    .    .   .    .    .  .    .    .  	 - only the new format
  .    .    .   .    .    .  .    .    .  	 The following checks if the cache contains any of these formats.  */
  5    0    0   1    0    0  0    0    0        if (file != MAP_FAILED && cachesize > sizeof *cache
  6    1    1   0    0    0  1    0    0  	  && memcmp (file, CACHEMAGIC, sizeof CACHEMAGIC - 1) == 0)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  size_t offset;
  .    .    .   .    .    .  .    .    .  	  /* Looks ok.  */
  1    0    0   0    0    0  1    0    0  	  cache = file;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  /* Check for new version.  */
  4    0    0   1    0    0  0    0    0  	  offset = ALIGN_CACHE (sizeof (struct cache_file)
  .    .    .   .    .    .  .    .    .  				+ cache->nlibs * sizeof (struct file_entry));
  .    .    .   .    .    .  .    .    .  
  2    0    0   0    0    0  1    0    0  	  cache_new = (struct cache_file_new *) ((void *) cache + offset);
  3    0    0   0    0    0  0    0    0  	  if (cachesize < (offset + sizeof (struct cache_file_new))
  5    1    1   0    0    0  1    0    0  	      || memcmp (cache_new->magic, CACHEMAGIC_VERSION_NEW,
  .    .    .   .    .    .  .    .    .  			 sizeof CACHEMAGIC_VERSION_NEW - 1) != 0)
  2    0    0   0    0    0  0    0    0  	    cache_new = (void *) -1;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .        else if (file != MAP_FAILED && cachesize > sizeof *cache_new
  .    .    .   .    .    .  .    .    .  	       && memcmp (file, CACHEMAGIC_VERSION_NEW,
  .    .    .   .    .    .  .    .    .  			  sizeof CACHEMAGIC_VERSION_NEW - 1) == 0)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  cache_new = file;
  .    .    .   .    .    .  .    .    .  	  cache = file;
  .    .    .   .    .    .  .    .    .  	}
-- line 230 ----------------------------------------
-- line 233 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	  if (file != MAP_FAILED)
  .    .    .   .    .    .  .    .    .  	    __munmap (file, cachesize);
  .    .    .   .    .    .  .    .    .  	  cache = (void *) -1;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        assert (cache != NULL);
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  5    0    0   3    0    0  0    0    0    if (cache == (void *) -1)
  .    .    .   .    .    .  .    .    .      /* Previously looked for the cache file and didn't find it.  */
  .    .    .   .    .    .  .    .    .      return NULL;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    best = NULL;
  .    .    .   .    .    .  .    .    .  
  4    0    0   0    0    0  0    0    0    if (cache_new != (void *) -1)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        uint64_t platform;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* This is where the strings start.  */
  .    .    .   .    .    .  .    .    .        cache_data = (const char *) cache_new;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Now we can compute how large the string table is.  */
 10    0    0   4    0    0  4    0    0        cache_data_size = (const char *) cache + cachesize - cache_data;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        platform = _dl_string_platform (GLRO(dl_platform));
  .    .    .   .    .    .  .    .    .        if (platform != (uint64_t) -1)
  .    .    .   .    .    .  .    .    .  	platform = 1ULL << platform;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #define _DL_HWCAP_TLS_MASK (1LL << 63)
 12    1    1   6    0    0  4    0    0        uint64_t hwcap_exclude = ~((GLRO(dl_hwcap) & GLRO(dl_hwcap_mask))
 10    1    1   6    0    0  2    0    0  				 | _DL_HWCAP_PLATFORM | _DL_HWCAP_TLS_MASK);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Only accept hwcap if it's for the right platform.  */
  .    .    .   .    .    .  .    .    .  #define HWCAP_CHECK \
  .    .    .   .    .    .  .    .    .        if (lib->hwcap & hwcap_exclude)					      \
  .    .    .   .    .    .  .    .    .  	continue;							      \
  .    .    .   .    .    .  .    .    .        if (GLRO(dl_osversion) && lib->osversion > GLRO(dl_osversion))	      \
  .    .    .   .    .    .  .    .    .  	continue;							      \
  .    .    .   .    .    .  .    .    .        if (_DL_PLATFORMS_COUNT						      \
  .    .    .   .    .    .  .    .    .  	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != 0			      \
  .    .    .   .    .    .  .    .    .  	  && (lib->hwcap & _DL_HWCAP_PLATFORM) != platform)		      \
  .    .    .   .    .    .  .    .    .  	continue
435    6    6  77   17   17 23    0    0        SEARCH_CACHE (cache_new);
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .    else
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* This is where the strings start.  */
  .    .    .   .    .    .  .    .    .        cache_data = (const char *) &cache->libs[cache->nlibs];
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Now we can compute how large the string table is.  */
  .    .    .   .    .    .  .    .    .        cache_data_size = (const char *) cache + cachesize - cache_data;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #undef HWCAP_CHECK
  .    .    .   .    .    .  .    .    .  #define HWCAP_CHECK do {} while (0)
  .    .    .   .    .    .  .    .    .        SEARCH_CACHE (cache);
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Print our result if wanted.  */
  4    1    1   2    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0)
  .    .    .   .    .    .  .    .    .        && best != NULL)
  .    .    .   .    .    .  .    .    .      _dl_debug_printf ("  trying file=%s\n", best);
  .    .    .   .    .    .  .    .    .  
  4    0    0   0    0    0  0    0    0    if (best == NULL)
  .    .    .   .    .    .  .    .    .      return NULL;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* The double copy is *required* since malloc may be interposed
  .    .    .   .    .    .  .    .    .       and call dlopen itself whose completion would unmap the data
  .    .    .   .    .    .  .    .    .       we are accessing. Therefore we must make the copy of the
  .    .    .   .    .    .  .    .    .       mapping data without using malloc.  */
  .    .    .   .    .    .  .    .    .    char *temp;
 40    1    1   2    0    0  2    0    0    temp = alloca (strlen (best) + 1);
  6    0    0   0    0    0  2    0    0    strcpy (temp, best);
  4    1    1   0    0    0  2    0    0    return strdup (temp);
 16    0    0  14    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifndef MAP_COPY
  .    .    .   .    .    .  .    .    .  /* If the system does not support MAP_COPY we cannot leave the file open
  .    .    .   .    .    .  .    .    .     all the time since this would create problems when the file is replaced.
  .    .    .   .    .    .  .    .    .     Therefore we provide this function to close the file and open it again
  .    .    .   .    .    .  .    .    .     once needed.  */
  .    .    .   .    .    .  .    .    .  void
  .    .    .   .    .    .  .    .    .  _dl_unload_cache (void)
  1    0    0   0    0    0  0    0    0  {
  4    1    1   1    1    0  0    0    0    if (cache != NULL && cache != (struct cache_file *) -1)
  .    .    .   .    .    .  .    .    .      {
  2    1    0   1    1    0  1    0    0        __munmap (cache, cachesize);
  1    0    0   0    0    0  1    0    0        cache = NULL;
  .    .    .   .    .    .  .    .    .      }
  2    0    0   1    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/allocatestack.c
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 127 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  /* Check whether the stack is still used or not.  */
 .    .    .  .    .    .  .    .    .  #define FREE_P(descr) ((descr)->tid <= 0)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  static void
 .    .    .  .    .    .  .    .    .  stack_list_del (list_t *elem)
 .    .    .  .    .    .  .    .    .  {
 8    0    0  0    0    0  8    0    0    in_flight_stack = (uintptr_t) elem;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    list_del (elem);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  8    0    0    in_flight_stack = 0;
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  static void
 .    .    .  .    .    .  .    .    .  stack_list_add (list_t *elem, list_t *list)
 .    .    .  .    .    .  .    .    .  {
48    1    1  0    0    0 16    0    0    in_flight_stack = (uintptr_t) elem | 1;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    list_add (elem, list);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
 .    .    .  .    .    .  .    .    .  
16    1    1  0    0    0 16    0    0    in_flight_stack = 0;
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  /* We create a double linked list of all cache entries.  Double linked
 .    .    .  .    .    .  .    .    .     because this allows removing entries from the end.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  /* Get a stack frame from the cache.  We have to match by size since
-- line 166 ----------------------------------------
-- line 167 ----------------------------------------
 .    .    .  .    .    .  .    .    .     some blocks might be too small or far too large.  */
 .    .    .  .    .    .  .    .    .  static struct pthread *
 .    .    .  .    .    .  .    .    .  get_cached_stack (size_t *sizep, void **memp)
 .    .    .  .    .    .  .    .    .  {
 .    .    .  .    .    .  .    .    .    size_t size = *sizep;
 .    .    .  .    .    .  .    .    .    struct pthread *result = NULL;
 .    .    .  .    .    .  .    .    .    list_t *entry;
 .    .    .  .    .    .  .    .    .  
32    0    0  8    1    0  0    0    0    lll_lock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Search the cache for a matching entry.  We search for the
 .    .    .  .    .    .  .    .    .       smallest stack which has at least the required size.  Note that
 .    .    .  .    .    .  .    .    .       in normal situations the size of all allocated stacks is the
 .    .    .  .    .    .  .    .    .       same.  As the very least there are only a few different sizes.
 .    .    .  .    .    .  .    .    .       Therefore this loop will exit early most of the time with an
 .    .    .  .    .    .  .    .    .       exact match.  */
32    1    1  8    1    0  0    0    0    list_for_each (entry, &stack_cache)
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        struct pthread *curr;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        curr = list_entry (entry, struct pthread, list);
 .    .    .  .    .    .  .    .    .        if (FREE_P (curr) && curr->stackblock_size >= size)
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  	  if (curr->stackblock_size == size)
 .    .    .  .    .    .  .    .    .  	    {
-- line 191 ----------------------------------------
-- line 200 ----------------------------------------
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    if (__builtin_expect (result == NULL, 0)
 .    .    .  .    .    .  .    .    .        /* Make sure the size difference is not too excessive.  In that
 .    .    .  .    .    .  .    .    .  	 case we do not use the block.  */
 .    .    .  .    .    .  .    .    .        || __builtin_expect (result->stackblock_size > 4 * size, 0))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* Release the lock.  */
16    1    1 16    0    0  0    0    0        lll_unlock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        return NULL;
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Don't allow setxid until cloned.  */
 .    .    .  .    .    .  .    .    .    result->setxid_futex = -1;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Dequeue the entry.  */
-- line 216 ----------------------------------------
-- line 296 ----------------------------------------
 .    .    .  .    .    .  .    .    .  __attribute ((always_inline))
 .    .    .  .    .    .  .    .    .  queue_stack (struct pthread *stack)
 .    .    .  .    .    .  .    .    .  {
 .    .    .  .    .    .  .    .    .    /* We unconditionally add the stack to the list.  The memory may
 .    .    .  .    .    .  .    .    .       still be in use but it will not be reused until the kernel marks
 .    .    .  .    .    .  .    .    .       the stack as not used anymore.  */
 .    .    .  .    .    .  .    .    .    stack_list_add (&stack->list, &stack_cache);
 .    .    .  .    .    .  .    .    .  
24    0    0 16    0    0  8    0    0    stack_cache_actsize += stack->stackblock_size;
16    0    0  0    0    0  0    0    0    if (__builtin_expect (stack_cache_actsize > stack_cache_maxsize, 0))
 .    .    .  .    .    .  .    .    .      __free_stacks (stack_cache_maxsize);
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  static int
 .    .    .  .    .    .  .    .    .  internal_function
 .    .    .  .    .    .  .    .    .  change_stack_perm (struct pthread *pd
 .    .    .  .    .    .  .    .    .  #ifdef NEED_SEPARATE_REGISTER_STACK
-- line 313 ----------------------------------------
-- line 337 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  static int
 .    .    .  .    .    .  .    .    .  allocate_stack (const struct pthread_attr *attr, struct pthread **pdp,
 .    .    .  .    .    .  .    .    .  		ALLOCATE_STACK_PARMS)
 .    .    .  .    .    .  .    .    .  {
 .    .    .  .    .    .  .    .    .    struct pthread *pd;
 .    .    .  .    .    .  .    .    .    size_t size;
24    0    0  0    0    0  8    0    0    size_t pagesize_m1 = __getpagesize () - 1;
 .    .    .  .    .    .  .    .    .    void *stacktop;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    assert (attr != NULL);
 .    .    .  .    .    .  .    .    .    assert (powerof2 (pagesize_m1 + 1));
 .    .    .  .    .    .  .    .    .    assert (TCB_ALIGNMENT >= STACK_ALIGN);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Get the stack size from the attribute if it is set.  Otherwise we
 .    .    .  .    .    .  .    .    .       use the default we determined at start time.  */
24    0    0  8    1    0  0    0    0    size = attr->stacksize ?: __default_pthread_attr.stacksize;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Get memory for the stack.  */
16    0    0  8    0    0  0    0    0    if (__builtin_expect (attr->flags & ATTR_FLAG_STACKADDR, 0))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        uintptr_t adj;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* If the user also specified the size of the stack make sure it
 .    .    .  .    .    .  .    .    .  	 is large enough.  */
 .    .    .  .    .    .  .    .    .        if (attr->stacksize != 0
 .    .    .  .    .    .  .    .    .  	  && attr->stacksize < (__static_tls_size + MINIMAL_REST_STACK))
 8    0    0  0    0    0  0    0    0  	return EINVAL;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Adjust stack size for alignment of the TLS block.  */
 .    .    .  .    .    .  .    .    .  #if TLS_TCB_AT_TP
 .    .    .  .    .    .  .    .    .        adj = ((uintptr_t) attr->stackaddr - TLS_TCB_SIZE)
 .    .    .  .    .    .  .    .    .  	    & __static_tls_align_m1;
 .    .    .  .    .    .  .    .    .        assert (size > adj + TLS_TCB_SIZE);
 .    .    .  .    .    .  .    .    .  #elif TLS_DTV_AT_TP
 .    .    .  .    .    .  .    .    .        adj = ((uintptr_t) attr->stackaddr - __static_tls_size)
-- line 373 ----------------------------------------
-- line 444 ----------------------------------------
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .    else
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* Allocate some anonymous memory.  If possible use the cache.  */
 .    .    .  .    .    .  .    .    .        size_t guardsize;
 .    .    .  .    .    .  .    .    .        size_t reqsize;
 .    .    .  .    .    .  .    .    .        void *mem;
 .    .    .  .    .    .  .    .    .        const int prot = (PROT_READ | PROT_WRITE
80    0    0 16    1    0  0    0    0  			| ((GL(dl_stack_flags) & PF_X) ? PROT_EXEC : 0));
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Adjust the stack size for alignment.  */
24    2    2  8    1    0  0    0    0        size &= ~__static_tls_align_m1;
 .    .    .  .    .    .  .    .    .        assert (size != 0);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Make sure the size of the stack is enough for the guard and
 .    .    .  .    .    .  .    .    .  	 eventually the thread descriptor.  */
40    0    0  8    0    0  0    0    0        guardsize = (attr->guardsize + pagesize_m1) & ~pagesize_m1;
32    0    0  0    0    0  0    0    0        if (guardsize < attr->guardsize || size + guardsize < guardsize)
 .    .    .  .    .    .  .    .    .  	/* Arithmetic overflow.  */
 .    .    .  .    .    .  .    .    .  	return EINVAL;
 .    .    .  .    .    .  .    .    .        size += guardsize;
16    0    0  0    0    0  0    0    0        if (__builtin_expect (size < ((guardsize + __static_tls_size
24    0    0  8    0    0  0    0    0  				     + MINIMAL_REST_STACK + pagesize_m1)
 8    0    0  0    0    0  0    0    0  				    & ~pagesize_m1),
 .    .    .  .    .    .  .    .    .  			    0))
 .    .    .  .    .    .  .    .    .  	/* The stack is too small (or the guard too large).  */
 .    .    .  .    .    .  .    .    .  	return EINVAL;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Try to get a stack from the cache.  */
 .    .    .  .    .    .  .    .    .        reqsize = size;
 .    .    .  .    .    .  .    .    .        pd = get_cached_stack (&size, &mem);
 .    .    .  .    .    .  .    .    .        if (pd == NULL)
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  	  /* To avoid aliasing effects on a larger scale than pages we
 .    .    .  .    .    .  .    .    .  	     adjust the allocated stack size if necessary.  This way
 .    .    .  .    .    .  .    .    .  	     allocations directly following each other will not have
 .    .    .  .    .    .  .    .    .  	     aliasing problems.  */
 .    .    .  .    .    .  .    .    .  #if MULTI_PAGE_ALIASING != 0
32    0    0  0    0    0  8    0    0  	  if ((size % MULTI_PAGE_ALIASING) == 0)
 .    .    .  .    .    .  .    .    .  	    size += pagesize_m1 + 1;
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
64    0    0  0    0    0 24    0    0  	  mem = mmap (NULL, size, prot,
 .    .    .  .    .    .  .    .    .  		      MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
 .    .    .  .    .    .  .    .    .  
24    1    1  8    0    0  0    0    0  	  if (__builtin_expect (mem == MAP_FAILED, 0))
 .    .    .  .    .    .  .    .    .  	    return errno;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* SIZE is guaranteed to be greater than zero.
 .    .    .  .    .    .  .    .    .  	     So we can never get a null pointer back from mmap.  */
 .    .    .  .    .    .  .    .    .  	  assert (mem != NULL);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Place the thread descriptor at the end of the stack.  */
 .    .    .  .    .    .  .    .    .  #if TLS_TCB_AT_TP
24    0    0  8    0    0  8    0    0  	  pd = (struct pthread *) ((char *) mem + size) - 1;
 .    .    .  .    .    .  .    .    .  #elif TLS_DTV_AT_TP
 .    .    .  .    .    .  .    .    .  	  pd = (struct pthread *) ((((uintptr_t) mem + size
 .    .    .  .    .    .  .    .    .  				    - __static_tls_size)
 .    .    .  .    .    .  .    .    .  				    & ~__static_tls_align_m1)
 .    .    .  .    .    .  .    .    .  				   - TLS_PRE_TCB_SIZE);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Remember the stack-related values.  */
 8    0    0  0    0    0  8    8    8  	  pd->stackblock = mem;
 8    0    0  0    0    0  8    0    0  	  pd->stackblock_size = size;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* We allocated the first block thread-specific data array.
 .    .    .  .    .    .  .    .    .  	     This address will not change for the lifetime of this
 .    .    .  .    .    .  .    .    .  	     descriptor.  */
16    1    1  0    0    0  8    8    8  	  pd->specific[0] = pd->specific_1stblock;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* This is at least the second thread.  */
 8    0    0  0    0    0  8    8    8  	  pd->header.multiple_threads = 1;
 .    .    .  .    .    .  .    .    .  #ifndef TLS_MULTIPLE_THREADS_IN_TCB
24    0    0  8    1    0 16    0    0  	  __pthread_multiple_threads = *__libc_multiple_threads_ptr = 1;
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #ifndef __ASSUME_PRIVATE_FUTEX
 .    .    .  .    .    .  .    .    .  	  /* The thread must know when private futexes are supported.  */
 .    .    .  .    .    .  .    .    .  	  pd->header.private_futex = THREAD_GETMEM (THREAD_SELF,
 .    .    .  .    .    .  .    .    .  						    header.private_futex);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #ifdef NEED_DL_SYSINFO
 .    .    .  .    .    .  .    .    .  	  /* Copy the sysinfo value from the parent.  */
 .    .    .  .    .    .  .    .    .  	  THREAD_SYSINFO(pd) = THREAD_SELF_SYSINFO;
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Don't allow setxid until cloned.  */
 8    0    0  0    0    0  8    8    8  	  pd->setxid_futex = -1;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* The process ID is also the same as that of the caller.  */
16    0    0  8    0    0  8    8    8  	  pd->pid = THREAD_GETMEM (THREAD_SELF, pid);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Allocate the DTV for this thread.  */
40    1    1  8    0    0  8    0    0  	  if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
 .    .    .  .    .    .  .    .    .  	    {
 .    .    .  .    .    .  .    .    .  	      /* Something went wrong.  */
 .    .    .  .    .    .  .    .    .  	      assert (errno == ENOMEM);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	      /* Free the stack memory we just allocated.  */
 .    .    .  .    .    .  .    .    .  	      (void) munmap (mem, size);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	      return errno;
 .    .    .  .    .    .  .    .    .  	    }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Prepare to modify global data.  */
32    0    0  8    0    0  0    0    0  	  lll_lock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* And add to the list of stacks in use.  */
 8    0    0  0    0    0  0    0    0  	  stack_list_add (&pd->list, &stack_used);
 .    .    .  .    .    .  .    .    .  
16    0    0 16    0    0  0    0    0  	  lll_unlock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* There might have been a race.  Another thread might have
 .    .    .  .    .    .  .    .    .  	     caused the stacks to get exec permission while this new
 .    .    .  .    .    .  .    .    .  	     stack was prepared.  Detect if this was possible and
 .    .    .  .    .    .  .    .    .  	     change the permission if necessary.  */
32    1    1 16    0    0  0    0    0  	  if (__builtin_expect ((GL(dl_stack_flags) & PF_X) != 0
 .    .    .  .    .    .  .    .    .  				&& (prot & PROT_EXEC) == 0, 0))
 .    .    .  .    .    .  .    .    .  	    {
 .    .    .  .    .    .  .    .    .  	      int err = change_stack_perm (pd
 .    .    .  .    .    .  .    .    .  #ifdef NEED_SEPARATE_REGISTER_STACK
 .    .    .  .    .    .  .    .    .  					   , ~pagesize_m1
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  					   );
 .    .    .  .    .    .  .    .    .  	      if (err != 0)
-- line 572 ----------------------------------------
-- line 583 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	     zeroed.  This means we do not have to initialize fields
 .    .    .  .    .    .  .    .    .  	     with initial value zero.  This is specifically true for
 .    .    .  .    .    .  .    .    .  	     the 'tid' field which is always set back to zero once the
 .    .    .  .    .    .  .    .    .  	     stack is not used anymore and for the 'guardsize' field
 .    .    .  .    .    .  .    .    .  	     which will be read next.  */
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Create or resize the guard area if necessary.  */
24    1    1  8    0    0  0    0    0        if (__builtin_expect (guardsize > pd->guardsize, 0))
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  #ifdef NEED_SEPARATE_REGISTER_STACK
 .    .    .  .    .    .  .    .    .  	  char *guard = mem + (((size - guardsize) / 2) & ~pagesize_m1);
 .    .    .  .    .    .  .    .    .  #elif _STACK_GROWS_DOWN
 .    .    .  .    .    .  .    .    .  	  char *guard = mem;
 .    .    .  .    .    .  .    .    .  # elif _STACK_GROWS_UP
 .    .    .  .    .    .  .    .    .  	  char *guard = (char *) (((uintptr_t) pd - guardsize) & ~pagesize_m1);
 .    .    .  .    .    .  .    .    .  #endif
64    1    1 16    0    0 16    0    0  	  if (mprotect (guard, guardsize, PROT_NONE) != 0)
 .    .    .  .    .    .  .    .    .  	    {
 .    .    .  .    .    .  .    .    .  	    mprot_error:
 .    .    .  .    .    .  .    .    .  	      lll_lock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	      /* Remove the thread from the list.  */
 .    .    .  .    .    .  .    .    .  	      stack_list_del (&pd->list);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	      lll_unlock (stack_cache_lock, LLL_PRIVATE);
-- line 608 ----------------------------------------
-- line 644 ----------------------------------------
 .    .    .  .    .    .  .    .    .  			prot) != 0)
 .    .    .  .    .    .  .    .    .  	    goto mprot_error;
 .    .    .  .    .    .  .    .    .  #elif _STACK_GROWS_UP
 .    .    .  .    .    .  .    .    .  	  if (mprotect ((char *) pd - pd->guardsize,
 .    .    .  .    .    .  .    .    .  			pd->guardsize - guardsize, prot) != 0)
 .    .    .  .    .    .  .    .    .  	    goto mprot_error;
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
16    1    1  0    0    0  8    0    0  	  pd->guardsize = guardsize;
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .        /* The pthread_getattr_np() calls need to get passed the size
 .    .    .  .    .    .  .    .    .  	 requested in the attribute, regardless of how large the
 .    .    .  .    .    .  .    .    .  	 actually used guardsize is.  */
 8    1    1  0    0    0  8    0    0        pd->reported_guardsize = guardsize;
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Initialize the lock.  We have to do this unconditionally since the
 .    .    .  .    .    .  .    .    .       stillborn thread could be canceled while the lock is taken.  */
 8    0    0  0    0    0  8    0    0    pd->lock = LLL_LOCK_INITIALIZER;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* The robust mutex lists also need to be initialized
 .    .    .  .    .    .  .    .    .       unconditionally because the cleanup for the previous stack owner
 .    .    .  .    .    .  .    .    .       might have happened in the kernel.  */
 8    0    0  0    0    0  8    0    0    pd->robust_head.futex_offset = (offsetof (pthread_mutex_t, __data.__lock)
 .    .    .  .    .    .  .    .    .  				  - offsetof (pthread_mutex_t,
 .    .    .  .    .    .  .    .    .  					      __data.__list.__next));
 8    0    0  0    0    0  8    0    0    pd->robust_head.list_op_pending = NULL;
 .    .    .  .    .    .  .    .    .  #ifdef __PTHREAD_MUTEX_HAVE_PREV
16    1    1  0    0    0  8    0    0    pd->robust_prev = &pd->robust_head;
 .    .    .  .    .    .  .    .    .  #endif
 8    0    0  0    0    0  8    0    0    pd->robust_head.list = &pd->robust_head;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* We place the thread descriptor at the end of the stack.  */
 .    .    .  .    .    .  .    .    .    *pdp = pd;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #if TLS_TCB_AT_TP
 .    .    .  .    .    .  .    .    .    /* The stack begins before the TCB and the static TLS block.  */
24    0    0  8    0    0  0    0    0    stacktop = ((char *) (pd + 1) - __static_tls_size);
 .    .    .  .    .    .  .    .    .  #elif TLS_DTV_AT_TP
 .    .    .  .    .    .  .    .    .    stacktop = (char *) (pd - 1);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #ifdef NEED_SEPARATE_REGISTER_STACK
 .    .    .  .    .    .  .    .    .    *stack = pd->stackblock;
 .    .    .  .    .    .  .    .    .    *stacksize = stacktop - *stack;
 .    .    .  .    .    .  .    .    .  #elif _STACK_GROWS_DOWN
-- line 689 ----------------------------------------
-- line 695 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    return 0;
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  void
 .    .    .  .    .    .  .    .    .  internal_function
 .    .    .  .    .    .  .    .    .  __deallocate_stack (struct pthread *pd)
16    1    1  0    0    0  0    0    0  {
32    0    0  8    0    0  0    0    0    lll_lock (stack_cache_lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Remove the thread from the list of threads with user defined
 .    .    .  .    .    .  .    .    .       stacks.  */
 8    1    1  0    0    0  0    0    0    stack_list_del (&pd->list);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Not much to do.  Just free the mmap()ed memory.  Note that we do
 .    .    .  .    .    .  .    .    .       not reset the 'used' flag in the 'tid' field.  This is done by
 .    .    .  .    .    .  .    .    .       the kernel.  If no thread has been created yet this field is
 .    .    .  .    .    .  .    .    .       still zero.  */
16    0    0  8    0    0  0    0    0    if (__builtin_expect (! pd->user_stack, 1))
 .    .    .  .    .    .  .    .    .      (void) queue_stack (pd);
 .    .    .  .    .    .  .    .    .    else
 .    .    .  .    .    .  .    .    .      /* Free the memory associated with the ELF TLS.  */
 .    .    .  .    .    .  .    .    .      _dl_deallocate_tls (TLS_TPADJ (pd), false);
 .    .    .  .    .    .  .    .    .  
16    0    0 16    0    0  0    0    0    lll_unlock (stack_cache_lock, LLL_PRIVATE);
16    0    0  8    0    0  0    0    0  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  int
 .    .    .  .    .    .  .    .    .  internal_function
 .    .    .  .    .    .  .    .    .  __make_stacks_executable (void **stack_endp)
 .    .    .  .    .    .  .    .    .  {
 .    .    .  .    .    .  .    .    .    /* First the main thread's stack.  */
 .    .    .  .    .    .  .    .    .    int err = _dl_make_stack_executable (stack_endp);
-- line 729 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdio-common/_itoa.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 160 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  char *
  .    .    .  .    .    .  .    .    .  _itoa_word (_ITOA_WORD_TYPE value, char *buflim,
  .    .    .  .    .    .  .    .    .  	    unsigned int base, int upper_case)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    const char *digits = (upper_case
  .    .    .  .    .    .  .    .    .  			? _itoa_upper_digits
 24    2    2  0    0    0  0    0    0  			: _itoa_lower_digits);
  .    .    .  .    .    .  .    .    .  
 12    0    0  0    0    0  0    0    0    switch (base)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .  #define SPECIAL(Base)							      \
  .    .    .  .    .    .  .    .    .      case Base:								      \
  .    .    .  .    .    .  .    .    .        do								      \
  .    .    .  .    .    .  .    .    .  	*--buflim = digits[value % Base];				      \
  .    .    .  .    .    .  .    .    .        while ((value /= Base) != 0);					      \
  .    .    .  .    .    .  .    .    .        break
  .    .    .  .    .    .  .    .    .  
660    1    1 54    1    1 54    0    0        SPECIAL (10);
  .    .    .  .    .    .  .    .    .        SPECIAL (16);
  .    .    .  .    .    .  .    .    .        SPECIAL (8);
  .    .    .  .    .    .  .    .    .      default:
  .    .    .  .    .    .  .    .    .        do
  .    .    .  .    .    .  .    .    .  	*--buflim = digits[value % base];
  .    .    .  .    .    .  .    .    .        while ((value /= base) != 0);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    return buflim;
 12    0    0  6    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  #undef SPECIAL
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if _ITOA_NEEDED
  .    .    .  .    .    .  .    .    .  char *
  .    .    .  .    .    .  .    .    .  _itoa (unsigned long long int value, char *buflim, unsigned int base,
  .    .    .  .    .    .  .    .    .         int upper_case)
  .    .    .  .    .    .  .    .    .  {
-- line 196 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/malloc/malloc.c
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr  D1mr DLmr Dw    D1mw DLmw 

-- line 1827 ----------------------------------------
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void malloc_init_state(mstate av)
    .    .    .   .    .    .     .    .    .  {
    .    .    .   .    .    .     .    .    .    int     i;
    .    .    .   .    .    .     .    .    .    mbinptr bin;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Establish circular links for normal bins */
1,905    1    1   0    0    0     0    0    0    for (i = 1; i < NBINS; ++i) {
    .    .    .   .    .    .     .    .    .      bin = bin_at(av,i);
2,667    0    0   0    0    0 1,778  223  223      bin->fd = bin->bk = bin;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if MORECORE_CONTIGUOUS
   21    0    0   0    0    0     0    0    0    if (av != &main_arena)
    .    .    .   .    .    .     .    .    .  #endif
    6    0    0   6    0    0     0    0    0      set_noncontiguous(av);
    .    .    .   .    .    .     .    .    .    if (av == &main_arena)
    3    1    1   1    0    0     1    0    0      set_max_fast(DEFAULT_MXFAST);
    8    0    0   6    0    0     1    0    0    av->flags |= FASTCHUNKS_BIT;
    .    .    .   .    .    .     .    .    .  
    1    0    0   0    0    0     1    1    1    av->top            = initial_top(av);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .     Other internal utilities operating on mstates
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void*  sysmalloc(INTERNAL_SIZE_T, mstate);
    .    .    .   .    .    .     .    .    .  static int      systrim(size_t, mstate);
-- line 1856 ----------------------------------------
-- line 1900 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /* ------------------ Testing support ----------------------------------*/
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static int perturb_byte;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static inline void
    .    .    .   .    .    .     .    .    .  alloc_perturb (char *p, size_t n)
    .    .    .   .    .    .     .    .    .  {
  196    1    1  40    0    0     0    0    0    if (__glibc_unlikely (perturb_byte))
    .    .    .   .    .    .     .    .    .      memset (p, perturb_byte ^ 0xff, n);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static inline void
    .    .    .   .    .    .     .    .    .  free_perturb (char *p, size_t n)
    .    .    .   .    .    .     .    .    .  {
   93    0    0  31    0    0     0    0    0    if (__glibc_unlikely (perturb_byte))
    .    .    .   .    .    .     .    .    .      memset (p, perturb_byte, n);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #include <stap-probe.h>
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /* ------------------- Support for multiple arenas -------------------- */
-- line 1923 ----------------------------------------
-- line 2278 ----------------------------------------
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    sysmalloc handles malloc cases requiring more memory from the system.
    .    .    .   .    .    .     .    .    .    On entry, it is assumed that av->top does not have enough
    .    .    .   .    .    .     .    .    .    space to service request for nb bytes, thus requiring that av->top
    .    .    .   .    .    .     .    .    .    be extended or replaced.
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void* sysmalloc(INTERNAL_SIZE_T nb, mstate av)
    9    1    1   0    0    0     6    0    0  {
    .    .    .   .    .    .     .    .    .    mchunkptr       old_top;        /* incoming value of av->top */
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T old_size;       /* its size */
    .    .    .   .    .    .     .    .    .    char*           old_end;        /* its end address */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    long            size;           /* arg to first MORECORE or mmap call */
    .    .    .   .    .    .     .    .    .    char*           brk;            /* return value from MORECORE */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    long            correction;     /* arg to 2nd MORECORE call */
-- line 2294 ----------------------------------------
-- line 2299 ----------------------------------------
    .    .    .   .    .    .     .    .    .    char*           aligned_brk;    /* aligned offset into brk */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    mchunkptr       p;              /* the allocated/returned chunk */
    .    .    .   .    .    .     .    .    .    mchunkptr       remainder;      /* remainder from allocation */
    .    .    .   .    .    .     .    .    .    unsigned long   remainder_size; /* its size */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    unsigned long   sum;            /* for updating stats */
    .    .    .   .    .    .     .    .    .  
    3    1    1   2    2    0     0    0    0    size_t          pagemask  = GLRO(dl_pagesize) - 1;
    .    .    .   .    .    .     .    .    .    bool            tried_mmap = false;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If have mmap, and the request size meets the mmap threshold, and
    .    .    .   .    .    .     .    .    .      the system supports mmap, and there are few enough currently
    .    .    .   .    .    .     .    .    .      allocated mmapped regions, try to directly map this request
    .    .    .   .    .    .     .    .    .      rather than expanding top.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    2    0    0   0    0    0     0    0    0    if (av == NULL
    3    0    0   1    1    1     1    1    0        || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
    .    .    .   .    .    .     .    .    .  	  && (mp_.n_mmaps < mp_.n_mmaps_max))) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      char* mm;             /* return value from mmap call*/
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    try_mmap:
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        Round up size to nearest page.  For mmapped chunks, the overhead
    .    .    .   .    .    .     .    .    .        is one SIZE_SZ unit larger than for normal chunks, because there
-- line 2327 ----------------------------------------
-- line 2390 ----------------------------------------
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* There are no usable arenas and mmap also failed.  */
    .    .    .   .    .    .     .    .    .    if (av == NULL)
    .    .    .   .    .    .     .    .    .      return 0;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Record incoming configuration of top */
    .    .    .   .    .    .     .    .    .  
    1    0    0   1    0    0     0    0    0    old_top  = av->top;
    2    0    0   1    0    0     0    0    0    old_size = chunksize(old_top);
    1    0    0   0    0    0     0    0    0    old_end  = (char*)(chunk_at_offset(old_top, old_size));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    brk = snd_brk = (char*)(MORECORE_FAILURE);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .       If not the first time through, we require old_size to be
    .    .    .   .    .    .     .    .    .       at least MINSIZE and to have prev_inuse set.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
-- line 2408 ----------------------------------------
-- line 2410 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	 ((unsigned long) (old_size) >= MINSIZE &&
    .    .    .   .    .    .     .    .    .  	  prev_inuse(old_top) &&
    .    .    .   .    .    .     .    .    .  	  ((unsigned long)old_end & pagemask) == 0));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Precondition: not enough current space to satisfy nb request */
    .    .    .   .    .    .     .    .    .    assert((unsigned long)(old_size) < (unsigned long)(nb + MINSIZE));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    3    0    0   0    0    0     0    0    0    if (av != &main_arena) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      heap_info *old_heap, *heap;
    .    .    .   .    .    .     .    .    .      size_t old_heap_size;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* First try to extend the current heap. */
    .    .    .   .    .    .     .    .    .      old_heap = heap_for_ptr(old_top);
    .    .    .   .    .    .     .    .    .      old_heap_size = old_heap->size;
    .    .    .   .    .    .     .    .    .      if ((long) (MINSIZE + nb - old_size) > 0
-- line 2426 ----------------------------------------
-- line 2461 ----------------------------------------
    .    .    .   .    .    .     .    .    .        /* We can at least try to use to mmap memory.  */
    .    .    .   .    .    .     .    .    .        goto try_mmap;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    } else { /* av == main_arena */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Request enough space for nb + pad + overhead */
    .    .    .   .    .    .     .    .    .  
    7    2    2   2    0    0     0    0    0    size = nb + mp_.top_pad + MINSIZE;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If contiguous, we can subtract out existing space that we hope to
    .    .    .   .    .    .     .    .    .      combine with new space. We add it back later only if
    .    .    .   .    .    .     .    .    .      we don't actually get contiguous space.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    if (contiguous(av))
-- line 2477 ----------------------------------------
-- line 2480 ----------------------------------------
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      Round to a multiple of page size.
    .    .    .   .    .    .     .    .    .      If MORECORE is not contiguous, this ensures that we only call it
    .    .    .   .    .    .     .    .    .      with whole-page arguments.  And if MORECORE is contiguous and
    .    .    .   .    .    .     .    .    .      this is not first time through, this preserves page-alignment of
    .    .    .   .    .    .     .    .    .      previous calls. Otherwise, we correct to page-align below.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    5    0    0   0    0    0     0    0    0    size = (size + pagemask) & ~pagemask;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      Don't try to call MORECORE if argument is so big as to appear
    .    .    .   .    .    .     .    .    .      negative. Note that since mmap takes size_t arg, it may succeed
    .    .    .   .    .    .     .    .    .      below even if we cannot call MORECORE.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    2    0    0   0    0    0     0    0    0    if (size > 0) {
    7    1    1   2    1    0     4    0    0      brk = (char*)(MORECORE(size));
    2    0    0   1    0    0     0    0    0      LIBC_PROBE (memory_sbrk_more, 2, brk, size);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    4    1    1   2    0    0     0    0    0    if (brk != (char*)(MORECORE_FAILURE)) {
    .    .    .   .    .    .     .    .    .      /* Call the `morecore' hook if necessary.  */
    2    0    0   2    1    1     0    0    0      void (*hook) (void) = force_reg (__after_morecore_hook);
    2    0    0   0    0    0     0    0    0      if (__builtin_expect (hook != NULL, 0))
    .    .    .   .    .    .     .    .    .        (*hook) ();
    .    .    .   .    .    .     .    .    .    } else {
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If have mmap, try using it as a backup when MORECORE fails or
    .    .    .   .    .    .     .    .    .      cannot be used. This is worth doing on systems that have "holes" in
    .    .    .   .    .    .     .    .    .      address space, so sbrk cannot extend to give contiguous space, but
    .    .    .   .    .    .     .    .    .      space is available elsewhere.  Note that we ignore mmap max count
    .    .    .   .    .    .     .    .    .      and threshold limits, since the space will not be used as a
-- line 2512 ----------------------------------------
-- line 2514 ----------------------------------------
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* Cannot merge with old top, so add its size back in */
    .    .    .   .    .    .     .    .    .      if (contiguous(av))
    .    .    .   .    .    .     .    .    .        size = (size + old_size + pagemask) & ~pagemask;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* If we are relying on mmap as backup, then use larger units */
    .    .    .   .    .    .     .    .    .      if ((unsigned long)(size) < (unsigned long)(MMAP_AS_MORECORE_SIZE))
    2    0    0   0    0    0     0    0    0        size = MMAP_AS_MORECORE_SIZE;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* Don't try if size wraps around 0 */
    .    .    .   .    .    .     .    .    .      if ((unsigned long)(size) > (unsigned long)(nb)) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        char *mbrk = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE, 0));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        if (mbrk != MAP_FAILED) {
    .    .    .   .    .    .     .    .    .  
-- line 2530 ----------------------------------------
-- line 2539 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	   bridge regions.
    .    .    .   .    .    .     .    .    .  	*/
    .    .    .   .    .    .     .    .    .  	set_noncontiguous(av);
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    if (brk != (char*)(MORECORE_FAILURE)) {
    2    0    0   1    1    1     0    0    0      if (mp_.sbrk_base == 0)
    5    1    1   0    0    0     2    0    0        mp_.sbrk_base = brk;
    3    1    1   1    0    0     1    0    0      av->system_mem += size;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        If MORECORE extends previous space, we can likewise extend top size.
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .  
    2    0    0   0    0    0     0    0    0      if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE))
    .    .    .   .    .    .     .    .    .        set_head(old_top, (size + old_size) | PREV_INUSE);
    .    .    .   .    .    .     .    .    .  
    8    2    2   1    0    0     0    0    0      else if (contiguous(av) && old_size && brk < old_end) {
    .    .    .   .    .    .     .    .    .        /* Oops!  Someone else killed our space..  Can't touch anything.  */
    .    .    .   .    .    .     .    .    .        mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .        malloc_printerr (3, "break adjusted to free malloc space", brk, av);
    .    .    .   .    .    .     .    .    .        mutex_lock(&av->mutex);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        Otherwise, make adjustments:
-- line 2566 ----------------------------------------
-- line 2592 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/* Count foreign sbrk as system_mem.  */
    .    .    .   .    .    .     .    .    .  	if (old_size)
    .    .    .   .    .    .     .    .    .  	  av->system_mem += brk - old_end;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/* Guarantee alignment of first new chunk made from this space */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    3    0    0   0    0    0     0    0    0  	if (front_misalign > 0) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	  /*
    .    .    .   .    .    .     .    .    .  	    Skip over some bytes to arrive at an aligned position.
    .    .    .   .    .    .     .    .    .  	    We don't need to specially mark these wasted front bytes.
    .    .    .   .    .    .     .    .    .  	    They will never be accessed anyway because
    .    .    .   .    .    .     .    .    .  	    prev_inuse of av->top (and any chunk created from its start)
    .    .    .   .    .    .     .    .    .  	    is always true after initialization.
    .    .    .   .    .    .     .    .    .  	  */
-- line 2608 ----------------------------------------
-- line 2611 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	  aligned_brk += correction;
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/*
    .    .    .   .    .    .     .    .    .  	  If this isn't adjacent to existing space, then we will not
    .    .    .   .    .    .     .    .    .  	  be able to merge with old_top space, so must add to 2nd request.
    .    .    .   .    .    .     .    .    .  	*/
    .    .    .   .    .    .     .    .    .  
    1    0    0   0    0    0     0    0    0  	correction += old_size;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/* Extend the end address to hit a page boundary */
    2    1    1   0    0    0     0    0    0  	end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);
    5    0    0   0    0    0     1    0    0  	correction += ((end_misalign + pagemask) & ~pagemask) - end_misalign;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	assert(correction >= 0);
    3    0    0   2    0    0     1    0    0  	snd_brk = (char*)(MORECORE(correction));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/*
    .    .    .   .    .    .     .    .    .  	  If can't allocate correction, try to at least find out current
    .    .    .   .    .    .     .    .    .  	  brk.  It might be enough to proceed without failing.
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	  Note that if second sbrk did NOT fail, we assume that space
    .    .    .   .    .    .     .    .    .  	  is contiguous with first sbrk. This is a safe assumption unless
    .    .    .   .    .    .     .    .    .  	  program is multithreaded but doesn't use locks and a foreign sbrk
    .    .    .   .    .    .     .    .    .  	  occurred between our first and second calls.
    .    .    .   .    .    .     .    .    .  	*/
    .    .    .   .    .    .     .    .    .  
    3    0    0   1    0    0     0    0    0  	if (snd_brk == (char*)(MORECORE_FAILURE)) {
    .    .    .   .    .    .     .    .    .  	  correction = 0;
    .    .    .   .    .    .     .    .    .  	  snd_brk = (char*)(MORECORE(0));
    .    .    .   .    .    .     .    .    .  	} else {
    .    .    .   .    .    .     .    .    .  	  /* Call the `morecore' hook if necessary.  */
    2    0    0   2    0    0     0    0    0  	  void (*hook) (void) = force_reg (__after_morecore_hook);
    4    1    1   2    0    0     0    0    0  	  if (__builtin_expect (hook != NULL, 0))
    .    .    .   .    .    .     .    .    .  	    (*hook) ();
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* handle non-contiguous cases */
    .    .    .   .    .    .     .    .    .        else {
    .    .    .   .    .    .     .    .    .  	if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
    .    .    .   .    .    .     .    .    .  	  /* MORECORE/mmap must correctly align */
-- line 2652 ----------------------------------------
-- line 2670 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	/* Find out current end of memory */
    .    .    .   .    .    .     .    .    .  	if (snd_brk == (char*)(MORECORE_FAILURE)) {
    .    .    .   .    .    .     .    .    .  	  snd_brk = (char*)(MORECORE(0));
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* Adjust top based on results of second sbrk */
    .    .    .   .    .    .     .    .    .        if (snd_brk != (char*)(MORECORE_FAILURE)) {
    1    0    0   0    0    0     1    0    0  	av->top = (mchunkptr)aligned_brk;
    4    0    0   0    0    0     1    1    1  	set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
    3    0    0   0    0    0     1    0    0  	av->system_mem += correction;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	/*
    .    .    .   .    .    .     .    .    .  	  If not the first time through, we either have a
    .    .    .   .    .    .     .    .    .  	  gap due to foreign sbrk or a non-contiguous region.  Insert a
    .    .    .   .    .    .     .    .    .  	  double fencepost at old_top to prevent consolidation with space
    .    .    .   .    .    .     .    .    .  	  we don't own. These fenceposts are artificial chunks that are
    .    .    .   .    .    .     .    .    .  	  marked as inuse and are in any case too small to use.  We need
    .    .    .   .    .    .     .    .    .  	  two to make sizes and alignments work out.
    .    .    .   .    .    .     .    .    .  	*/
    .    .    .   .    .    .     .    .    .  
    2    0    0   0    0    0     0    0    0  	if (old_size != 0) {
    .    .    .   .    .    .     .    .    .  	  /*
    .    .    .   .    .    .     .    .    .  	     Shrink old_top to insert fenceposts, keeping size a
    .    .    .   .    .    .     .    .    .  	     multiple of MALLOC_ALIGNMENT. We know there is at least
    .    .    .   .    .    .     .    .    .  	     enough space in old_top to do this.
    .    .    .   .    .    .     .    .    .  	  */
    .    .    .   .    .    .     .    .    .  	  old_size = (old_size - 4*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
    .    .    .   .    .    .     .    .    .  	  set_head(old_top, old_size | PREV_INUSE);
    .    .    .   .    .    .     .    .    .  
-- line 2699 ----------------------------------------
-- line 2716 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    } /* if (av !=  &main_arena) */
    .    .    .   .    .    .     .    .    .  
    2    1    1   1    0    0     0    0    0    if ((unsigned long)av->system_mem > (unsigned long)(av->max_system_mem))
    2    1    1   0    0    0     1    0    0      av->max_system_mem = av->system_mem;
    .    .    .   .    .    .     .    .    .    check_malloc_state(av);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* finally, do the allocation */
    .    .    .   .    .    .     .    .    .    p = av->top;
    2    0    0   1    0    0     0    0    0    size = chunksize(p);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* check that one of the above allocation paths succeeded */
    3    0    0   0    0    0     0    0    0    if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
    1    0    0   0    0    0     0    0    0      remainder_size = size - nb;
    1    0    0   0    0    0     0    0    0      remainder = chunk_at_offset(p, nb);
    1    0    0   0    0    0     1    0    0      av->top = remainder;
    7    0    0   0    0    0     1    0    0      set_head(p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));
    2    0    0   0    0    0     1    1    1      set_head(remainder, remainder_size | PREV_INUSE);
    .    .    .   .    .    .     .    .    .      check_malloced_chunk(av, p, nb);
    1    0    0   0    0    0     0    0    0      return chunk2mem(p);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* catch all failure paths */
    .    .    .   .    .    .     .    .    .    __set_errno (ENOMEM);
    .    .    .   .    .    .     .    .    .    return 0;
    8    0    0   7    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    systrim is an inverse of sorts to sysmalloc.  It gives memory back
    .    .    .   .    .    .     .    .    .    to the system (via negative arguments to sbrk) if there is unused
    .    .    .   .    .    .     .    .    .    memory at the `high' end of the malloc pool. It is called
    .    .    .   .    .    .     .    .    .    automatically by free() when top space exceeds the trim
    .    .    .   .    .    .     .    .    .    threshold. It is also called by the public malloc_trim routine.  It
-- line 2754 ----------------------------------------
-- line 2837 ----------------------------------------
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    mp_.n_mmaps--;
    .    .    .   .    .    .     .    .    .    mp_.mmapped_mem -= total_size;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* If munmap failed the process virtual memory address space is in a
    .    .    .   .    .    .     .    .    .       bad shape.  Just leave the block hanging around, the process will
    .    .    .   .    .    .     .    .    .       terminate shortly anyway since not much can be done.  */
   22    1    1  22    0    0     0    0    0    __munmap((char *)block, total_size);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if HAVE_MREMAP
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static mchunkptr
    .    .    .   .    .    .     .    .    .  internal_function
    .    .    .   .    .    .     .    .    .  mremap_chunk(mchunkptr p, size_t new_size)
    .    .    .   .    .    .     .    .    .  {
-- line 2853 ----------------------------------------
-- line 2886 ----------------------------------------
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #endif /* HAVE_MREMAP */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*------------------------ Public wrappers. --------------------------------*/
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  void*
    .    .    .   .    .    .     .    .    .  __libc_malloc(size_t bytes)
  124    1    1   0    0    0    62    0    0  {
    .    .    .   .    .    .     .    .    .    mstate ar_ptr;
    .    .    .   .    .    .     .    .    .    void *victim;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    __malloc_ptr_t (*hook) (size_t, const __malloc_ptr_t)
   62    0    0  62    2    0     0    0    0      = force_reg (__malloc_hook);
   62    0    0   0    0    0     0    0    0    if (__builtin_expect (hook != NULL, 0))
    .    .    .   .    .    .     .    .    .      return (*hook)(bytes, RETURN_ADDRESS (0));
    .    .    .   .    .    .     .    .    .  
  389    1    1 134    1    0     7    6    6    arena_get(ar_ptr, bytes);
    .    .    .   .    .    .     .    .    .  
  124    1    1   0    0    0    31    0    0    victim = _int_malloc(ar_ptr, bytes);
    .    .    .   .    .    .     .    .    .    /* Retry with another arena only if we were able to find a usable arena
    .    .    .   .    .    .     .    .    .       before.  */
  124    0    0   0    0    0     0    0    0    if (!victim && ar_ptr != NULL) {
    .    .    .   .    .    .     .    .    .      LIBC_PROBE (memory_malloc_retry, 1, bytes);
    .    .    .   .    .    .     .    .    .      ar_ptr = arena_get_retry(ar_ptr, bytes);
    .    .    .   .    .    .     .    .    .      victim = _int_malloc (ar_ptr, bytes);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
   62    0    0   0    0    0     0    0    0    if (ar_ptr != NULL)
  152    0    0  90    0    0     0    0    0      (void)mutex_unlock(&ar_ptr->mutex);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
    .    .    .   .    .    .     .    .    .  	 ar_ptr == arena_for_chunk(mem2chunk(victim)));
    .    .    .   .    .    .     .    .    .    return victim;
  155    0    0  93    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  libc_hidden_def(__libc_malloc)
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  void
    .    .    .   .    .    .     .    .    .  __libc_free(void* mem)
    .    .    .   .    .    .     .    .    .  {
    .    .    .   .    .    .     .    .    .    mstate ar_ptr;
    .    .    .   .    .    .     .    .    .    mchunkptr p;                          /* chunk corresponding to mem */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    void (*hook) (__malloc_ptr_t, const __malloc_ptr_t)
  106    1    1 106    1    0     0    0    0      = force_reg (__free_hook);
  106    0    0   0    0    0     0    0    0    if (__builtin_expect (hook != NULL, 0)) {
    .    .    .   .    .    .     .    .    .      (*hook)(mem, RETURN_ADDRESS (0));
    .    .    .   .    .    .     .    .    .      return;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
  106    0    0   0    0    0     0    0    0    if (mem == 0)                              /* free(0) has no effect */
    .    .    .   .    .    .     .    .    .      return;
    .    .    .   .    .    .     .    .    .  
   31    1    1   0    0    0     0    0    0    p = mem2chunk(mem);
    .    .    .   .    .    .     .    .    .  
   93    0    0  31    2    0     0    0    0    if (chunk_is_mmapped(p))                       /* release mmapped memory. */
    .    .    .   .    .    .     .    .    .    {
    .    .    .   .    .    .     .    .    .      /* see if the dynamic brk/mmap threshold needs adjusting */
    .    .    .   .    .    .     .    .    .      if (!mp_.no_dyn_threshold
    .    .    .   .    .    .     .    .    .  	&& p->size > mp_.mmap_threshold
    .    .    .   .    .    .     .    .    .  	&& p->size <= DEFAULT_MMAP_THRESHOLD_MAX)
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	mp_.mmap_threshold = chunksize (p);
    .    .    .   .    .    .     .    .    .  	mp_.trim_threshold = 2 * mp_.mmap_threshold;
    .    .    .   .    .    .     .    .    .  	LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
    .    .    .   .    .    .     .    .    .  		    mp_.mmap_threshold, mp_.trim_threshold);
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      munmap_chunk(p);
    .    .    .   .    .    .     .    .    .      return;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
  177    0    0  28    5    0     0    0    0    ar_ptr = arena_for_chunk(p);
   93    0    0   0    0    0     0    0    0    _int_free(ar_ptr, p, 0);
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  libc_hidden_def (__libc_free)
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  void*
    .    .    .   .    .    .     .    .    .  __libc_realloc(void* oldmem, size_t bytes)
    .    .    .   .    .    .     .    .    .  {
    .    .    .   .    .    .     .    .    .    mstate ar_ptr;
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T    nb;      /* padded request size */
-- line 2966 ----------------------------------------
-- line 3171 ----------------------------------------
    .    .    .   .    .    .     .    .    .    assert(!p || chunk_is_mmapped(mem2chunk(p)) ||
    .    .    .   .    .    .     .    .    .  	 ar_ptr == arena_for_chunk(mem2chunk(p)));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    return p;
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  void*
    .    .    .   .    .    .     .    .    .  __libc_calloc(size_t n, size_t elem_size)
   45    1    1   0    0    0    45    0    0  {
    .    .    .   .    .    .     .    .    .    mstate av;
    .    .    .   .    .    .     .    .    .    mchunkptr oldtop, p;
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;
    .    .    .   .    .    .     .    .    .    void* mem;
    .    .    .   .    .    .     .    .    .    unsigned long clearsize;
    .    .    .   .    .    .     .    .    .    unsigned long nclears;
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T* d;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* size_t is unsigned so the behavior on overflow is defined.  */
   18    0    0   0    0    0     0    0    0    bytes = n * elem_size;
    .    .    .   .    .    .     .    .    .  #define HALF_INTERNAL_SIZE_T \
    .    .    .   .    .    .     .    .    .    (((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))
   45    1    1   0    0    0     0    0    0    if (__builtin_expect ((n | elem_size) >= HALF_INTERNAL_SIZE_T, 0)) {
    .    .    .   .    .    .     .    .    .      if (elem_size != 0 && bytes / elem_size != n) {
    .    .    .   .    .    .     .    .    .        __set_errno (ENOMEM);
    .    .    .   .    .    .     .    .    .        return 0;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    __malloc_ptr_t (*hook) __MALLOC_PMT ((size_t, const __malloc_ptr_t)) =
   18    0    0  18    1    0     0    0    0      force_reg (__malloc_hook);
   18    0    0   0    0    0     0    0    0    if (__builtin_expect (hook != NULL, 0)) {
    .    .    .   .    .    .     .    .    .      sz = bytes;
    3    1    1   1    0    0     1    0    0      mem = (*hook)(sz, RETURN_ADDRESS (0));
    2    0    0   0    0    0     0    0    0      if(mem == 0)
    .    .    .   .    .    .     .    .    .        return 0;
    4    1    1   0    0    0     0    0    0      return memset(mem, 0, sz);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    sz = bytes;
    .    .    .   .    .    .     .    .    .  
  104    1    1  40    0    0     0    0    0    arena_get(av, sz);
    .    .    .   .    .    .     .    .    .    if(av)
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* Check if we hand out the top chunk, in which case there may be no
    .    .    .   .    .    .     .    .    .  	 need to clear. */
    .    .    .   .    .    .     .    .    .  #if MORECORE_CLEARS
    8    0    0   8    0    0     0    0    0        oldtop = top(av);
   16    0    0   8    0    0     0    0    0        oldtopsize = chunksize(top(av));
    .    .    .   .    .    .     .    .    .  # if MORECORE_CLEARS < 2
    .    .    .   .    .    .     .    .    .        /* Only newly allocated memory is guaranteed to be cleared.  */
    .    .    .   .    .    .     .    .    .        if (av == &main_arena &&
    .    .    .   .    .    .     .    .    .  	  oldtopsize < mp_.sbrk_base + av->max_system_mem - (char *)oldtop)
    .    .    .   .    .    .     .    .    .  	oldtopsize = (mp_.sbrk_base + av->max_system_mem - (char *)oldtop);
    .    .    .   .    .    .     .    .    .  # endif
   24    0    0   0    0    0     0    0    0        if (av != &main_arena)
    .    .    .   .    .    .     .    .    .  	{
   14    0    0   0    0    0     0    0    0  	  heap_info *heap = heap_for_ptr (oldtop);
   28    0    0   7    0    0     0    0    0  	  if (oldtopsize < ((char *) heap + heap->mprotect_size -
    .    .    .   .    .    .     .    .    .  			    (char *) oldtop))
    .    .    .   .    .    .     .    .    .  	    oldtopsize = (char *) heap + heap->mprotect_size - (char *) oldtop;
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    else
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        /* No usable arenas.  */
    .    .    .   .    .    .     .    .    .        oldtop = 0;
    .    .    .   .    .    .     .    .    .        oldtopsize = 0;
    .    .    .   .    .    .     .    .    .      }
   32    1    1   0    0    0     8    0    0    mem = _int_malloc(av, sz);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    assert(!mem || chunk_is_mmapped(mem2chunk(mem)) ||
    .    .    .   .    .    .     .    .    .  	 av == arena_for_chunk(mem2chunk(mem)));
    .    .    .   .    .    .     .    .    .  
   16    0    0   0    0    0     0    0    0    if (mem == 0 && av != NULL) {
    .    .    .   .    .    .     .    .    .      LIBC_PROBE (memory_calloc_retry, 1, sz);
    .    .    .   .    .    .     .    .    .      av = arena_get_retry (av, sz);
    .    .    .   .    .    .     .    .    .      mem = _int_malloc(av, sz);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    if (av != NULL)
   40    0    0  24    0    0     0    0    0      (void)mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Allocation failed even after a retry.  */
   16    1    1   0    0    0     0    0    0    if (mem == 0)
    .    .    .   .    .    .     .    .    .      return 0;
    .    .    .   .    .    .     .    .    .  
    8    0    0   0    0    0     0    0    0    p = mem2chunk(mem);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Two optional cases in which clearing not necessary */
   24    0    0   8    0    0     0    0    0    if (chunk_is_mmapped (p))
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        if (__builtin_expect (perturb_byte, 0))
    .    .    .   .    .    .     .    .    .  	MALLOC_ZERO (mem, sz);
    .    .    .   .    .    .     .    .    .        return mem;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    8    0    0   0    0    0     0    0    0    csz = chunksize(p);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if MORECORE_CLEARS
   64    2    2   8    0    0     0    0    0    if (perturb_byte == 0 && (p == oldtop && csz > oldtopsize)) {
    .    .    .   .    .    .     .    .    .      /* clear only the bytes from non-freshly-sbrked memory */
    .    .    .   .    .    .     .    .    .      csz = oldtopsize;
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Unroll clear of <= 36 bytes (72 if 8byte sizes).  We know that
    .    .    .   .    .    .     .    .    .       contents have an odd number of INTERNAL_SIZE_T-sized words;
    .    .    .   .    .    .     .    .    .       minimally 3.  */
    .    .    .   .    .    .     .    .    .    d = (INTERNAL_SIZE_T*)mem;
    8    0    0   0    0    0     0    0    0    clearsize = csz - SIZE_SZ;
   16    1    1   0    0    0     0    0    0    nclears = clearsize / sizeof(INTERNAL_SIZE_T);
    .    .    .   .    .    .     .    .    .    assert(nclears >= 3);
    .    .    .   .    .    .     .    .    .  
   16    0    0   0    0    0     0    0    0    if (nclears > 9)
   24    0    0   0    0    0     8    0    0      MALLOC_ZERO(d, clearsize);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    else {
    .    .    .   .    .    .     .    .    .      *(d+0) = 0;
    .    .    .   .    .    .     .    .    .      *(d+1) = 0;
    .    .    .   .    .    .     .    .    .      *(d+2) = 0;
    .    .    .   .    .    .     .    .    .      if (nclears > 4) {
    .    .    .   .    .    .     .    .    .        *(d+3) = 0;
    .    .    .   .    .    .     .    .    .        *(d+4) = 0;
-- line 3296 ----------------------------------------
-- line 3301 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	  *(d+7) = 0;
    .    .    .   .    .    .     .    .    .  	  *(d+8) = 0;
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    return mem;
   61    0    0  53    1    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    ------------------------------ malloc ------------------------------
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void*
    .    .    .   .    .    .     .    .    .  _int_malloc(mstate av, size_t bytes)
  351    1    1   0    0    0   234    0    0  {
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T nb;               /* normalized request size */
    .    .    .   .    .    .     .    .    .    unsigned int    idx;              /* associated bin index */
    .    .    .   .    .    .     .    .    .    mbinptr         bin;              /* associated bin */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    mchunkptr       victim;           /* inspected/selected chunk */
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T size;             /* its size */
    .    .    .   .    .    .     .    .    .    int             victim_index;     /* its bin index */
    .    .    .   .    .    .     .    .    .  
-- line 3325 ----------------------------------------
-- line 3339 ----------------------------------------
    .    .    .   .    .    .     .    .    .      Convert request size to internal form by adding SIZE_SZ bytes
    .    .    .   .    .    .     .    .    .      overhead plus possibly more to obtain necessary alignment and/or
    .    .    .   .    .    .     .    .    .      to obtain a size of at least MINSIZE, the smallest allocatable
    .    .    .   .    .    .     .    .    .      size. Also, checked_request2size traps (returning 0) request sizes
    .    .    .   .    .    .     .    .    .      that are so large that they wrap around zero when padded and
    .    .    .   .    .    .     .    .    .      aligned.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
  390    1    1   0    0    0     0    0    0    checked_request2size(bytes, nb);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from
    .    .    .   .    .    .     .    .    .       mmap.  */
   78    0    0   0    0    0     0    0    0    if (__glibc_unlikely (av == NULL))
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        void *p = sysmalloc (nb, av);
    .    .    .   .    .    .     .    .    .        if (p != NULL)
    .    .    .   .    .    .     .    .    .         alloc_perturb (p, bytes);
    .    .    .   .    .    .     .    .    .        return p;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If the size qualifies as a fastbin, first check corresponding bin.
    .    .    .   .    .    .     .    .    .      This code is safe to execute even if av is not yet initialized, so we
    .    .    .   .    .    .     .    .    .      can try it without checking, which saves some time on this fast path.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
   78    0    0  39    1    1     0    0    0    if ((unsigned long)(nb) <= (unsigned long)(get_max_fast ())) {
   66    0    0   0    0    0     0    0    0      idx = fastbin_index(nb);
   66    0    0   0    0    0     0    0    0      mfastbinptr* fb = &fastbin (av, idx);
   22    0    0  22    0    0     0    0    0      mchunkptr pp = *fb;
    .    .    .   .    .    .     .    .    .      do
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	victim = pp;
   44    0    0   0    0    0     0    0    0  	if (victim == NULL)
    .    .    .   .    .    .     .    .    .  	  break;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      while ((pp = catomic_compare_and_exchange_val_acq (fb, victim->fd, victim))
    .    .    .   .    .    .     .    .    .  	   != victim);
    .    .    .   .    .    .     .    .    .      if (victim != 0) {
    .    .    .   .    .    .     .    .    .        if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
    .    .    .   .    .    .     .    .    .  	{
    .    .    .   .    .    .     .    .    .  	  errstr = "malloc(): memory corruption (fast)";
-- line 3380 ----------------------------------------
-- line 3394 ----------------------------------------
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If a small request, check regular bin.  Since these "smallbins"
    .    .    .   .    .    .     .    .    .      hold one size each, no searching within bins is necessary.
    .    .    .   .    .    .     .    .    .      (For a large request, we need to wait until unsorted chunks are
    .    .    .   .    .    .     .    .    .      processed to find best fit. But for small ones, fits are exact
    .    .    .   .    .    .     .    .    .      anyway, so we can check now, which is faster.)
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
   78    1    1   0    0    0     0    0    0    if (in_smallbin_range(nb)) {
   78    0    0   0    0    0     0    0    0      idx = smallbin_index(nb);
   78    0    0   0    0    0     0    0    0      bin = bin_at(av,idx);
    .    .    .   .    .    .     .    .    .  
  117    0    0  39    1    1     0    0    0      if ( (victim = last(bin)) != bin) {
    2    0    0   0    0    0     0    0    0        if (victim == 0) /* initialization check */
    7    1    1   2    0    0     3    0    0  	malloc_consolidate(av);
    .    .    .   .    .    .     .    .    .        else {
    .    .    .   .    .    .     .    .    .  	bck = victim->bk;
    .    .    .   .    .    .     .    .    .  	if (__builtin_expect (bck->fd != victim, 0))
    .    .    .   .    .    .     .    .    .  	  {
    .    .    .   .    .    .     .    .    .  	    errstr = "malloc(): smallbin double linked list corrupted";
    .    .    .   .    .    .     .    .    .  	    goto errout;
    .    .    .   .    .    .     .    .    .  	  }
    .    .    .   .    .    .     .    .    .  	set_inuse_bit_at_offset(victim, nb);
-- line 3416 ----------------------------------------
-- line 3455 ----------------------------------------
    .    .    .   .    .    .     .    .    .      near the end of malloc that we should have consolidated, so must
    .    .    .   .    .    .     .    .    .      do so and retry. This happens at most once, and only when we would
    .    .    .   .    .    .     .    .    .      otherwise need to expand memory to service a "small" request.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    for(;;) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      int iters = 0;
  195    1    1  39    0    0     0    0    0      while ( (victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
    .    .    .   .    .    .     .    .    .        bck = victim->bk;
    .    .    .   .    .    .     .    .    .        if (__builtin_expect (victim->size <= 2 * SIZE_SZ, 0)
    .    .    .   .    .    .     .    .    .  	  || __builtin_expect (victim->size > av->system_mem, 0))
    .    .    .   .    .    .     .    .    .  	{
    .    .    .   .    .    .     .    .    .  	  mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .  	  malloc_printerr (check_action, "malloc(): memory corruption",
    .    .    .   .    .    .     .    .    .  			   chunk2mem (victim), av);
    .    .    .   .    .    .     .    .    .  	  mutex_lock(&av->mutex);
-- line 3471 ----------------------------------------
-- line 3585 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	break;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        If a large request, scan through the chunks of current bin in
    .    .    .   .    .    .     .    .    .        sorted order to find smallest that fits.  Use the skip list for this.
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .  
   78    1    1   0    0    0     0    0    0      if (!in_smallbin_range(nb)) {
    .    .    .   .    .    .     .    .    .        bin = bin_at(av, idx);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* skip scan if empty or largest chunk is too small */
    .    .    .   .    .    .     .    .    .        if ((victim = first(bin)) != bin &&
    .    .    .   .    .    .     .    .    .  	  (unsigned long)(victim->size) >= (unsigned long)(nb)) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	victim = victim->bk_nextsize;
    .    .    .   .    .    .     .    .    .  	while (((unsigned long)(size = chunksize(victim)) <
-- line 3601 ----------------------------------------
-- line 3655 ----------------------------------------
    .    .    .   .    .    .     .    .    .        (with ties going to approximately the least recently used) chunk
    .    .    .   .    .    .     .    .    .        that fits is selected.
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        The bitmap avoids needing to check that most blocks are nonempty.
    .    .    .   .    .    .     .    .    .        The particular case of skipping all bins during warm-up phases
    .    .    .   .    .    .     .    .    .        when no chunks have been returned yet is faster than it might look.
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .  
   39    1    1   0    0    0     0    0    0      ++idx;
   78    0    0   0    0    0     0    0    0      bin = bin_at(av,idx);
   78    0    0   0    0    0     0    0    0      block = idx2block(idx);
   78    0    0  39    0    0     0    0    0      map = av->binmap[block];
   78    0    0   0    0    0     0    0    0      bit = idx2bit(idx);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      for (;;) {
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* Skip rest of block if there are no more set bits in this block.  */
  156    0    0   0    0    0     0    0    0        if (bit > map || bit == 0) {
    .    .    .   .    .    .     .    .    .  	do {
  312    0    0   0    0    0     0    0    0  	  if (++block >= BINMAPSIZE)  /* out of bins */
    .    .    .   .    .    .     .    .    .  	    goto use_top;
  405    1    1 109    1    0     0    0    0  	} while ( (map = av->binmap[block]) == 0);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	bin = bin_at(av, (block << BINMAPSHIFT));
    .    .    .   .    .    .     .    .    .  	bit = 1;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* Advance to bin with set bit. There must be one. */
    .    .    .   .    .    .     .    .    .        while ((bit & map) == 0) {
    .    .    .   .    .    .     .    .    .  	bin = next_bin(bin);
-- line 3684 ----------------------------------------
-- line 3763 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        We require that av->top always exists (i.e., has size >=
    .    .    .   .    .    .     .    .    .        MINSIZE) after initialization, so if it would otherwise be
    .    .    .   .    .    .     .    .    .        exhausted by current request, it is replenished. (The main
    .    .    .   .    .    .     .    .    .        reason for ensuring it exists is that we may need MINSIZE space
    .    .    .   .    .    .     .    .    .        to put in fenceposts in sysmalloc.)
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .  
   39    0    0  39    0    0     0    0    0      victim = av->top;
   78    0    0  39    0    0     0    0    0      size = chunksize(victim);
    .    .    .   .    .    .     .    .    .  
  117    1    1   0    0    0     0    0    0      if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
   38    0    0   0    0    0     0    0    0        remainder_size = size - nb;
   76    0    0   0    0    0     0    0    0        remainder = chunk_at_offset(victim, nb);
   38    0    0   0    0    0    38    0    0        av->top = remainder;
  304    1    1   0    0    0    38    0    0        set_head(victim, nb | PREV_INUSE |
    .    .    .   .    .    .     .    .    .  	       (av != &main_arena ? NON_MAIN_ARENA : 0));
   76    0    0   0    0    0    38   30   30        set_head(remainder, remainder_size | PREV_INUSE);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        check_malloced_chunk(av, victim, nb);
   38    1    1   0    0    0     0    0    0        void *p = chunk2mem(victim);
    .    .    .   .    .    .     .    .    .        alloc_perturb (p, bytes);
    .    .    .   .    .    .     .    .    .        return p;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* When we are using atomic ops to free fast chunks we can get
    .    .    .   .    .    .     .    .    .         here for all block sizes.  */
    2    0    0   1    0    0     0    0    0      else if (have_fastchunks(av)) {
    .    .    .   .    .    .     .    .    .        malloc_consolidate(av);
    .    .    .   .    .    .     .    .    .        /* restore original bin index */
    .    .    .   .    .    .     .    .    .        if (in_smallbin_range(nb))
  156    1    1   0    0    0    39    0    0  	idx = smallbin_index(nb);
    .    .    .   .    .    .     .    .    .        else
  975    1    1   0    0    0   390   13   13  	idx = largebin_index(nb);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .         Otherwise, relay to handle system-dependent cases
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .      else {
    5    1    1   0    0    0     2    0    0        void *p = sysmalloc(nb, av);
    2    0    0   0    0    0     0    0    0        if (p != NULL)
    .    .    .   .    .    .     .    .    .  	alloc_perturb (p, bytes);
    .    .    .   .    .    .     .    .    .        return p;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
  312    1    1 273    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    ------------------------------ free ------------------------------
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void
    .    .    .   .    .    .     .    .    .  _int_free(mstate av, mchunkptr p, int have_lock)
  310    1    1   0    0    0   186    0    0  {
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T size;        /* its size */
    .    .    .   .    .    .     .    .    .    mfastbinptr*    fb;          /* associated fastbin */
    .    .    .   .    .    .     .    .    .    mchunkptr       nextchunk;   /* next contiguous chunk */
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T nextsize;    /* its size */
    .    .    .   .    .    .     .    .    .    int             nextinuse;   /* true if nextchunk is used */
    .    .    .   .    .    .     .    .    .    INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */
    .    .    .   .    .    .     .    .    .    mchunkptr       bck;         /* misc temp for linking */
    .    .    .   .    .    .     .    .    .    mchunkptr       fwd;         /* misc temp for linking */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    const char *errstr = NULL;
    8    0    0   0    0    0     0    0    0    int locked = 0;
    .    .    .   .    .    .     .    .    .  
   93    0    0  31    0    0     0    0    0    size = chunksize(p);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* Little security check which won't hurt performance: the
    .    .    .   .    .    .     .    .    .       allocator never wrapps around at the end of the address space.
    .    .    .   .    .    .     .    .    .       Therefore we can exclude some size values which might appear
    .    .    .   .    .    .     .    .    .       here by accident or by "design" from some intruder.  */
  124    1    1   0    0    0     0    0    0    if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)
   62    0    0   0    0    0     0    0    0        || __builtin_expect (misaligned_chunk (p), 0))
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        errstr = "free(): invalid pointer";
    .    .    .   .    .    .     .    .    .      errout:
    .    .    .   .    .    .     .    .    .        if (have_lock || locked)
    .    .    .   .    .    .     .    .    .  	(void)mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .        malloc_printerr (check_action, errstr, chunk2mem(p), av);
    .    .    .   .    .    .     .    .    .        if (have_lock)
    .    .    .   .    .    .     .    .    .  	mutex_lock(&av->mutex);
    .    .    .   .    .    .     .    .    .        return;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    /* We know that each chunk is at least MINSIZE bytes in size or a
    .    .    .   .    .    .     .    .    .       multiple of MALLOC_ALIGNMENT.  */
  124    0    0   0    0    0     0    0    0    if (__builtin_expect (size < MINSIZE || !aligned_OK (size), 0))
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        errstr = "free(): invalid size";
    .    .    .   .    .    .     .    .    .        goto errout;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    check_inuse_chunk(av, p);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If eligible, place chunk on a fastbin so it can be found
    .    .    .   .    .    .     .    .    .      and used quickly in malloc.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
   62    0    0  31    0    0     0    0    0    if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if TRIM_FASTBINS
    .    .    .   .    .    .     .    .    .        /*
    .    .    .   .    .    .     .    .    .  	If TRIM_FASTBINS set, don't place chunks
    .    .    .   .    .    .     .    .    .  	bordering top into fastbins
    .    .    .   .    .    .     .    .    .        */
    .    .    .   .    .    .     .    .    .        && (chunk_at_offset(p, size) != av->top)
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .        ) {
    .    .    .   .    .    .     .    .    .  
   92    0    0  23    4    0     0    0    0      if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
   69    1    1  23    0    0     0    0    0  	|| __builtin_expect (chunksize (chunk_at_offset (p, size))
    .    .    .   .    .    .     .    .    .  			     >= av->system_mem, 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	/* We might not have a lock at this point and concurrent modifications
    .    .    .   .    .    .     .    .    .  	   of system_mem might have let to a false positive.  Redo the test
    .    .    .   .    .    .     .    .    .  	   after getting the lock.  */
    .    .    .   .    .    .     .    .    .  	if (have_lock
    .    .    .   .    .    .     .    .    .  	    || ({ assert (locked == 0);
    .    .    .   .    .    .     .    .    .  		  mutex_lock(&av->mutex);
-- line 3883 ----------------------------------------
-- line 3891 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	  }
    .    .    .   .    .    .     .    .    .  	if (! have_lock)
    .    .    .   .    .    .     .    .    .  	  {
    .    .    .   .    .    .     .    .    .  	    (void)mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .  	    locked = 0;
    .    .    .   .    .    .     .    .    .  	  }
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
   23    0    0   0    0    0     0    0    0      free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
    .    .    .   .    .    .     .    .    .  
   69    0    0  69    6    0     0    0    0      set_fastchunks(av);
   46    0    0   0    0    0     0    0    0      unsigned int idx = fastbin_index(size);
   46    1    1   0    0    0     0    0    0      fb = &fastbin (av, idx);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
   23    0    0  23    0    0     0    0    0      mchunkptr old = *fb, old2;
   69    0    0   0    0    0     0    0    0      unsigned int old_idx = ~0u;
    .    .    .   .    .    .     .    .    .      do
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	/* Check that the top of the bin is not the record we are going to add
    .    .    .   .    .    .     .    .    .  	   (i.e., double free).  */
   69    0    0   0    0    0     0    0    0  	if (__builtin_expect (old == p, 0))
    .    .    .   .    .    .     .    .    .  	  {
    .    .    .   .    .    .     .    .    .  	    errstr = "double free or corruption (fasttop)";
    .    .    .   .    .    .     .    .    .  	    goto errout;
    .    .    .   .    .    .     .    .    .  	  }
    .    .    .   .    .    .     .    .    .  	/* Check that size of fastbin chunk at the top is the same as
    .    .    .   .    .    .     .    .    .  	   size of the chunk that we are adding.  We can dereference OLD
    .    .    .   .    .    .     .    .    .  	   only if we have the lock, otherwise it might have already been
    .    .    .   .    .    .     .    .    .  	   deallocated.  See use of OLD_IDX below for the actual check.  */
   64    0    0   0    0    0     0    0    0  	if (have_lock && old != NULL)
    .    .    .   .    .    .     .    .    .  	  old_idx = fastbin_index(chunksize(old));
   23    1    1   0    0    0    23    0    0  	p->fd = old2 = old;
    .    .    .   .    .    .     .    .    .        }
  138    0    0  46    0    0     0    0    0      while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);
    .    .    .   .    .    .     .    .    .  
   64    0    0   0    0    0     0    0    0      if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	errstr = "invalid fastbin entry (free)";
    .    .    .   .    .    .     .    .    .  	goto errout;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      Consolidate other non-mmapped chunks as they arrive.
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
   16    1    1   0    0    0     0    0    0    else if (!chunk_is_mmapped(p)) {
   16    0    0   0    0    0     0    0    0      if (! have_lock) {
   56    1    1  16    0    0     0    0    0        (void)mutex_lock(&av->mutex);
   16    1    1   0    0    0     0    0    0        locked = 1;
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    8    0    0   0    0    0     0    0    0      nextchunk = chunk_at_offset(p, size);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* Lightweight tests: check whether the block is already the
    .    .    .   .    .    .     .    .    .         top block.  */
   24    0    0   8    5    0     0    0    0      if (__builtin_expect (p == av->top, 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	errstr = "double free or corruption (top)";
    .    .    .   .    .    .     .    .    .  	goto errout;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      /* Or whether the next chunk is beyond the boundaries of the arena.  */
   18    1    1   8    0    0     0    0    0      if (__builtin_expect (contiguous (av)
    .    .    .   .    .    .     .    .    .  			  && (char *) nextchunk
    3    1    1   1    1    0     0    0    0  			  >= ((char *) av->top + chunksize(av->top)), 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	errstr = "double free or corruption (out)";
    .    .    .   .    .    .     .    .    .  	goto errout;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      /* Or whether the block is actually not marked used.  */
   24    0    0   8    0    0     0    0    0      if (__builtin_expect (!prev_inuse(nextchunk), 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	errstr = "double free or corruption (!prev)";
    .    .    .   .    .    .     .    .    .  	goto errout;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
   16    1    1   0    0    0     0    0    0      nextsize = chunksize(nextchunk);
   16    0    0   0    0    0     0    0    0      if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)
   16    0    0   8    0    0     0    0    0  	|| __builtin_expect (nextsize >= av->system_mem, 0))
    .    .    .   .    .    .     .    .    .        {
    .    .    .   .    .    .     .    .    .  	errstr = "free(): invalid next size (normal)";
    .    .    .   .    .    .     .    .    .  	goto errout;
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /* consolidate backward */
   16    0    0   8    0    0     0    0    0      if (!prev_inuse(p)) {
    .    .    .   .    .    .     .    .    .        prevsize = p->prev_size;
    .    .    .   .    .    .     .    .    .        size += prevsize;
    .    .    .   .    .    .     .    .    .        p = chunk_at_offset(p, -((long) prevsize));
    .    .    .   .    .    .     .    .    .        unlink(av, p, bck, fwd);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
   16    1    1   8    0    0     0    0    0      if (nextchunk != av->top) {
    .    .    .   .    .    .     .    .    .        /* get and clear inuse bit */
    .    .    .   .    .    .     .    .    .        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /* consolidate forward */
   16    0    0   8    0    0     0    0    0        if (!nextinuse) {
    .    .    .   .    .    .     .    .    .  	unlink(av, nextchunk, bck, fwd);
    .    .    .   .    .    .     .    .    .  	size += nextsize;
    .    .    .   .    .    .     .    .    .        } else
    8    0    0   8    0    0     0    0    0  	clear_inuse_bit_at_offset(nextchunk, 0);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        /*
    .    .    .   .    .    .     .    .    .  	Place the chunk in unsorted chunk list. Chunks are
    .    .    .   .    .    .     .    .    .  	not placed into regular bins until after they have
    .    .    .   .    .    .     .    .    .  	been given one chance to be used in malloc.
    .    .    .   .    .    .     .    .    .        */
    .    .    .   .    .    .     .    .    .  
    8    0    0   0    0    0     0    0    0        bck = unsorted_chunks(av);
    8    0    0   8    4    0     0    0    0        fwd = bck->fd;
   16    0    0   8    0    0     0    0    0        if (__builtin_expect (fwd->bk != bck, 0))
    .    .    .   .    .    .     .    .    .  	{
    .    .    .   .    .    .     .    .    .  	  errstr = "free(): corrupted unsorted chunks";
    .    .    .   .    .    .     .    .    .  	  goto errout;
    .    .    .   .    .    .     .    .    .  	}
    8    0    0   0    0    0     8    0    0        p->fd = fwd;
    8    0    0   0    0    0     8    0    0        p->bk = bck;
   16    1    1   0    0    0     0    0    0        if (!in_smallbin_range(size))
    .    .    .   .    .    .     .    .    .  	{
    .    .    .   .    .    .     .    .    .  	  p->fd_nextsize = NULL;
    .    .    .   .    .    .     .    .    .  	  p->bk_nextsize = NULL;
    .    .    .   .    .    .     .    .    .  	}
    8    0    0   0    0    0     8    0    0        bck->fd = p;
    8    0    0   0    0    0     8    0    0        fwd->bk = p;
    .    .    .   .    .    .     .    .    .  
   24    0    0   0    0    0     8    0    0        set_head(p, size | PREV_INUSE);
    8    0    0   0    0    0     8    0    0        set_foot(p, size);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        check_free_chunk(av, p);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        If the chunk borders the current high end of memory,
    .    .    .   .    .    .     .    .    .        consolidate into top
    .    .    .   .    .    .     .    .    .      */
-- line 4029 ----------------------------------------
-- line 4043 ----------------------------------------
    .    .    .   .    .    .     .    .    .        Unless max_fast is 0, we don't know if there are fastbins
    .    .    .   .    .    .     .    .    .        bordering top, so we cannot tell for sure whether threshold
    .    .    .   .    .    .     .    .    .        has been reached unless fastbins are consolidated.  But we
    .    .    .   .    .    .     .    .    .        don't want to consolidate on each free.  As a compromise,
    .    .    .   .    .    .     .    .    .        consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
    .    .    .   .    .    .     .    .    .        is reached.
    .    .    .   .    .    .     .    .    .      */
    .    .    .   .    .    .     .    .    .  
   16    0    0   0    0    0     0    0    0      if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
    .    .    .   .    .    .     .    .    .        if (have_fastchunks(av))
    .    .    .   .    .    .     .    .    .  	malloc_consolidate(av);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        if (av == &main_arena) {
    .    .    .   .    .    .     .    .    .  #ifndef MORECORE_CANNOT_TRIM
    .    .    .   .    .    .     .    .    .  	if ((unsigned long)(chunksize(av->top)) >=
    .    .    .   .    .    .     .    .    .  	    (unsigned long)(mp_.trim_threshold))
    .    .    .   .    .    .     .    .    .  	  systrim(mp_.top_pad, av);
-- line 4059 ----------------------------------------
-- line 4063 ----------------------------------------
    .    .    .   .    .    .     .    .    .  	   large, because the corresponding heap might go away.  */
    .    .    .   .    .    .     .    .    .  	heap_info *heap = heap_for_ptr(top(av));
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  	assert(heap->ar_ptr == av);
    .    .    .   .    .    .     .    .    .  	heap_trim(heap, mp_.top_pad);
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .  
   16    1    1   0    0    0     0    0    0      if (! have_lock) {
    .    .    .   .    .    .     .    .    .        assert (locked);
   40    0    0  24    0    0     0    0    0        (void)mutex_unlock(&av->mutex);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If the chunk was allocated via mmap, release via munmap().
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    else {
    .    .    .   .    .    .     .    .    .      munmap_chunk (p);
    .    .    .   .    .    .     .    .    .    }
  248    0    0 217    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    ------------------------- malloc_consolidate -------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    malloc_consolidate is a specialized version of free() that tears
    .    .    .   .    .    .     .    .    .    down chunks held in fastbins.  Free itself cannot be used for this
    .    .    .   .    .    .     .    .    .    purpose since, among other things, it might place chunks back onto
    .    .    .   .    .    .     .    .    .    fastbins.  So, instead, we need to use a minor variant of the same
-- line 4091 ----------------------------------------
-- line 4092 ----------------------------------------
    .    .    .   .    .    .     .    .    .    code.
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    Also, because this routine needs to be called the first time through
    .    .    .   .    .    .     .    .    .    malloc anyway, it turns out to be the perfect place to trigger
    .    .    .   .    .    .     .    .    .    initialization code.
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  static void malloc_consolidate(mstate av)
    8    1    1   0    0    0     6    1    0  {
    .    .    .   .    .    .     .    .    .    mfastbinptr*    fb;                 /* current fastbin being consolidated */
    .    .    .   .    .    .     .    .    .    mfastbinptr*    maxfb;              /* last fastbin (for loop control) */
    .    .    .   .    .    .     .    .    .    mchunkptr       p;                  /* current chunk being consolidated */
    .    .    .   .    .    .     .    .    .    mchunkptr       nextp;              /* next chunk to consolidate */
    .    .    .   .    .    .     .    .    .    mchunkptr       unsorted_bin;       /* bin header */
    .    .    .   .    .    .     .    .    .    mchunkptr       first_unsorted;     /* chunk to link to */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /* These have same use as in free() */
-- line 4108 ----------------------------------------
-- line 4114 ----------------------------------------
    .    .    .   .    .    .     .    .    .    mchunkptr       bck;
    .    .    .   .    .    .     .    .    .    mchunkptr       fwd;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    /*
    .    .    .   .    .    .     .    .    .      If max_fast is 0, we know that av hasn't
    .    .    .   .    .    .     .    .    .      yet been initialized, in which case do so below
    .    .    .   .    .    .     .    .    .    */
    .    .    .   .    .    .     .    .    .  
    5    0    0   1    0    0     0    0    0    if (get_max_fast () != 0) {
    .    .    .   .    .    .     .    .    .      clear_fastchunks(av);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      unsorted_bin = unsorted_chunks(av);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .      /*
    .    .    .   .    .    .     .    .    .        Remove each chunk from fast bin and consolidate it, placing it
    .    .    .   .    .    .     .    .    .        then in unsorted bin. Among other reasons for doing this,
    .    .    .   .    .    .     .    .    .        placing in unsorted bin avoids needing to calculate actual bins
-- line 4130 ----------------------------------------
-- line 4187 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        }
    .    .    .   .    .    .     .    .    .      } while (fb++ != maxfb);
    .    .    .   .    .    .     .    .    .    }
    .    .    .   .    .    .     .    .    .    else {
    .    .    .   .    .    .     .    .    .      malloc_init_state(av);
    .    .    .   .    .    .     .    .    .      check_malloc_state(av);
    .    .    .   .    .    .     .    .    .    }
    9    1    1   7    0    0     0    0    0  }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  /*
    .    .    .   .    .    .     .    .    .    ------------------------------ realloc ------------------------------
    .    .    .   .    .    .     .    .    .  */
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  void*
    .    .    .   .    .    .     .    .    .  _int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,
    .    .    .   .    .    .     .    .    .  	     INTERNAL_SIZE_T nb)
-- line 4203 ----------------------------------------
-- line 4955 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .    if ((action & 5) == 5)
    .    .    .   .    .    .     .    .    .      __libc_message (action & 2, "%s\n", str);
    .    .    .   .    .    .     .    .    .    else if (action & 1)
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        char buf[2 * sizeof (uintptr_t) + 1];
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        buf[sizeof (buf) - 1] = '\0';
  156    0    0   0    0    0    78    0    0        char *cp = _itoa_word ((uintptr_t) ptr, &buf[sizeof (buf) - 1], 16, 0);
    .    .    .   .    .    .     .    .    .        while (cp > buf)
  117    1    1  39    0    0    39   13   13  	*--cp = '0';
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .        __libc_message (action & 2, "*** Error in `%s': %s: 0x%s ***\n",
    .    .    .   .    .    .     .    .    .  		      __libc_argv[0] ?: "<unknown>", str, cp);
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    else if (action & 2)
    .    .    .   .    .    .     .    .    .      abort ();
    .    .    .   .    .    .     .    .    .  }
    .    .    .   .    .    .     .    .    .  
-- line 4973 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_create.c
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 102 ----------------------------------------
 .    .    .  .    .    .  .    .    .  void
 .    .    .  .    .    .  .    .    .  attribute_hidden
 .    .    .  .    .    .  .    .    .  __nptl_deallocate_tsd (void)
 .    .    .  .    .    .  .    .    .  {
 .    .    .  .    .    .  .    .    .    struct pthread *self = THREAD_SELF;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Maybe no data was ever allocated.  This happens often so we have
 .    .    .  .    .    .  .    .    .       a flag for this.  */
32    1    1  8    0    0  0    0    0    if (THREAD_GETMEM (self, specific_used))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        size_t round;
 .    .    .  .    .    .  .    .    .        size_t cnt;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        round = 0;
 .    .    .  .    .    .  .    .    .        do
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  	  size_t idx;
-- line 118 ----------------------------------------
-- line 184 ----------------------------------------
 .    .    .  .    .    .  .    .    .  		 descriptor.  */
 .    .    .  .    .    .  .    .    .  	      free (level2);
 .    .    .  .    .    .  .    .    .  	      THREAD_SETMEM_NC (self, specific, cnt, NULL);
 .    .    .  .    .    .  .    .    .  	    }
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        THREAD_SETMEM (self, specific_used, false);
 .    .    .  .    .    .  .    .    .      }
 8    1    1  8    0    0  0    0    0  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  /* Deallocate a thread's stack after optionally making sure the thread
 .    .    .  .    .    .  .    .    .     descriptor is still valid.  */
 .    .    .  .    .    .  .    .    .  void
 .    .    .  .    .    .  .    .    .  internal_function
 .    .    .  .    .    .  .    .    .  __free_tcb (struct pthread *pd)
16    1    1  0    0    0  8    0    0  {
 .    .    .  .    .    .  .    .    .    /* The thread is exiting now.  */
32    0    0 16    2    0  0    0    0    if (__builtin_expect (atomic_bit_test_set (&pd->cancelhandling,
 .    .    .  .    .    .  .    .    .  					     TERMINATED_BIT) == 0, 1))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* Remove the descriptor from the list.  */
 .    .    .  .    .    .  .    .    .        if (DEBUGGING_P && __find_in_stack_list (pd) == NULL)
 .    .    .  .    .    .  .    .    .  	/* Something is really wrong.  The descriptor for a still
 .    .    .  .    .    .  .    .    .  	   running thread is gone.  */
 .    .    .  .    .    .  .    .    .  	abort ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Free TPP data.  */
24    0    0  8    1    0  0    0    0        if (__builtin_expect (pd->tpp != NULL, 0))
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  	  struct priority_protection_data *tpp = pd->tpp;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  pd->tpp = NULL;
 .    .    .  .    .    .  .    .    .  	  free (tpp);
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Queue the stack memory block for reuse and exit the process.  The
 .    .    .  .    .    .  .    .    .  	 kernel will signal via writing to the address returned by
 .    .    .  .    .    .  .    .    .  	 QUEUE-STACK when the stack is available.  */
16    0    0  0    0    0  0    0    0        __deallocate_stack (pd);
 .    .    .  .    .    .  .    .    .      }
 8    0    0  8    0    0  0    0    0  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  static int
 .    .    .  .    .    .  .    .    .  start_thread (void *arg)
32    1    1  0    0    0 16    8    8  {
 .    .    .  .    .    .  .    .    .    struct pthread *pd = (struct pthread *) arg;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #if HP_TIMING_AVAIL
 .    .    .  .    .    .  .    .    .    /* Remember the time when the thread was started.  */
 .    .    .  .    .    .  .    .    .    hp_timing_t now;
32    0    0  0    0    0  0    0    0    HP_TIMING_NOW (now);
 8    1    1  0    0    0  8    0    0    THREAD_SETMEM (pd, cpuclock_offset, now);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Initialize resolver state pointer.  */
24    0    0  8    1    0  8    0    0    __resp = &pd->res;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Initialize pointers to locale data.  */
 8    0    0  0    0    0  8    0    0    __ctype_init ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Allow setxid from now onwards.  */
32    0    0 16    0    0  0    0    0    if (__builtin_expect (atomic_exchange_acq (&pd->setxid_futex, 0) == -2, 0))
 .    .    .  .    .    .  .    .    .      lll_futex_wake (&pd->setxid_futex, 1, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #ifdef __NR_set_robust_list
 .    .    .  .    .    .  .    .    .  # ifndef __ASSUME_SET_ROBUST_LIST
 .    .    .  .    .    .  .    .    .    if (__set_robust_list_avail >= 0)
 .    .    .  .    .    .  .    .    .  # endif
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        INTERNAL_SYSCALL_DECL (err);
 .    .    .  .    .    .  .    .    .        /* This call should never fail because the initial call in init.c
 .    .    .  .    .    .  .    .    .  	 succeeded.  */
40    1    1  8    0    0  0    0    0        INTERNAL_SYSCALL (set_robust_list, err, 2, &pd->robust_head,
 .    .    .  .    .    .  .    .    .  			sizeof (struct robust_list_head));
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* If the parent was running cancellation handlers while creating
 .    .    .  .    .    .  .    .    .       the thread the new thread inherited the signal mask.  Reset the
 .    .    .  .    .    .  .    .    .       cancellation signal mask.  */
16    0    0  8    0    0  0    0    0    if (__builtin_expect (pd->parent_cancelhandling & CANCELING_BITMASK, 0))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        INTERNAL_SYSCALL_DECL (err);
 .    .    .  .    .    .  .    .    .        sigset_t mask;
 .    .    .  .    .    .  .    .    .        __sigemptyset (&mask);
 .    .    .  .    .    .  .    .    .        __sigaddset (&mask, SIGCANCEL);
 .    .    .  .    .    .  .    .    .        (void) INTERNAL_SYSCALL (rt_sigprocmask, err, 4, SIG_UNBLOCK, &mask,
 .    .    .  .    .    .  .    .    .  			       NULL, _NSIG / 8);
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* This is where the try/finally block should be created.  For
 .    .    .  .    .    .  .    .    .       compilers without that support we do use setjmp.  */
 .    .    .  .    .    .  .    .    .    struct pthread_unwind_buf unwind_buf;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* No previous handlers.  */
 8    0    0  0    0    0  8    8    8    unwind_buf.priv.data.prev = NULL;
 8    0    0  0    0    0  8    0    0    unwind_buf.priv.data.cleanup = NULL;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    int not_first_call;
24    0    0  0    0    0  8    0    0    not_first_call = setjmp ((struct __jmp_buf_tag *) unwind_buf.cancel_jmp_buf);
16    0    0  0    0    0  0    0    0    if (__builtin_expect (! not_first_call, 1))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* Store the new cleanup handler info.  */
16    1    1  0    0    0  8    0    0        THREAD_SETMEM (pd, cleanup_jmp_buf, &unwind_buf);
 .    .    .  .    .    .  .    .    .  
24    0    0 16    0    0  0    0    0        if (__builtin_expect (pd->stopped_start, 0))
 .    .    .  .    .    .  .    .    .  	{
 .    .    .  .    .    .  .    .    .  	  int oldtype = CANCEL_ASYNC ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  /* Get the lock the parent locked to force synchronization.  */
 .    .    .  .    .    .  .    .    .  	  lll_lock (pd->lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  	  /* And give it up right away.  */
 .    .    .  .    .    .  .    .    .  	  lll_unlock (pd->lock, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  CANCEL_RESET (oldtype);
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  0    0    0        LIBC_PROBE (pthread_start, 3, (pthread_t) pd, pd->start_routine, pd->arg);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Run the code the user provided.  */
 .    .    .  .    .    .  .    .    .  #ifdef CALL_THREAD_FCT
24    0    0 16    0    0 16    3    0        THREAD_SETMEM (pd, result, CALL_THREAD_FCT (pd));
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .        THREAD_SETMEM (pd, result, pd->start_routine (pd->arg));
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Run the destructor for the thread-local data.  */
 8    0    0  0    0    0  8    0    0    __nptl_deallocate_tsd ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Clean up any state libc stored in thread-local variables.  */
 8    0    0  0    0    0  8    0    0    __libc_thread_freeres ();
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* If this is the last thread we terminate the process now.  We
 .    .    .  .    .    .  .    .    .       do not notify the debugger, it might just irritate it if there
 .    .    .  .    .    .  .    .    .       is no thread left.  */
32    1    1 16    0    0  0    0    0    if (__builtin_expect (atomic_decrement_and_test (&__nptl_nthreads), 0))
 .    .    .  .    .    .  .    .    .      /* This was the last thread.  */
 .    .    .  .    .    .  .    .    .      exit (0);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Report the death of the thread if this is wanted.  */
24    0    0 16    0    0  0    0    0    if (__builtin_expect (pd->report_events, 0))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* See whether TD_DEATH is in any of the mask.  */
 .    .    .  .    .    .  .    .    .        const int idx = __td_eventword (TD_DEATH);
 .    .    .  .    .    .  .    .    .        const uint32_t mask = __td_eventmask (TD_DEATH);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        if ((mask & (__nptl_threads_events.event_bits[idx]
 .    .    .  .    .    .  .    .    .  		   | pd->eventbuf.eventmask.event_bits[idx])) != 0)
 .    .    .  .    .    .  .    .    .  	{
-- line 335 ----------------------------------------
-- line 349 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	  /* Now call the function to signal the event.  */
 .    .    .  .    .    .  .    .    .  	  __nptl_death_event ();
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* The thread is exiting now.  Don't set this bit until after we've hit
 .    .    .  .    .    .  .    .    .       the event-reporting breakpoint, so that td_thr_get_info on us while at
 .    .    .  .    .    .  .    .    .       the breakpoint reports TD_THR_RUN state rather than TD_THR_ZOMBIE.  */
16    0    0 24    0    0  0    0    0    atomic_bit_set (&pd->cancelhandling, EXITING_BIT);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #ifndef __ASSUME_SET_ROBUST_LIST
 .    .    .  .    .    .  .    .    .    /* If this thread has any robust mutexes locked, handle them now.  */
 .    .    .  .    .    .  .    .    .  # ifdef __PTHREAD_MUTEX_HAVE_PREV
 .    .    .  .    .    .  .    .    .    void *robust = pd->robust_head.list;
 .    .    .  .    .    .  .    .    .  # else
 .    .    .  .    .    .  .    .    .    __pthread_slist_t *robust = pd->robust_list.__next;
 .    .    .  .    .    .  .    .    .  # endif
-- line 365 ----------------------------------------
-- line 384 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	  lll_robust_dead (this->__lock, /* XYZ */ LLL_SHARED);
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .        while (robust != (void *) &pd->robust_head);
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Mark the memory of the stack as usable to the kernel.  We free
 .    .    .  .    .    .  .    .    .       everything except for the space used for the TCB itself.  */
24    0    0  0    0    0  8    0    0    size_t pagesize_m1 = __getpagesize () - 1;
 .    .    .  .    .    .  .    .    .  #ifdef _STACK_GROWS_DOWN
 .    .    .  .    .    .  .    .    .    char *sp = CURRENT_STACK_FRAME;
40    1    1  8    6    0  0    0    0    size_t freesize = (sp - (char *) pd->stackblock) & ~pagesize_m1;
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  # error "to do"
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .    assert (freesize < pd->stackblock_size);
16    0    0  0    0    0  0    0    0    if (freesize > PTHREAD_STACK_MIN)
32    1    1  0    0    0  8    0    0      __madvise (pd->stackblock, freesize - PTHREAD_STACK_MIN, MADV_DONTNEED);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* If the thread is detached free the TCB.  */
24    0    0 16    0    0  0    0    0    if (IS_DETACHED (pd))
 .    .    .  .    .    .  .    .    .      /* Free the TCB.  */
 .    .    .  .    .    .  .    .    .      __free_tcb (pd);
16    0    0  8    0    0  0    0    0    else if (__builtin_expect (pd->cancelhandling & SETXID_BITMASK, 0))
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        /* Some other thread might call any of the setXid functions and expect
 .    .    .  .    .    .  .    .    .  	 us to reply.  In this case wait until we did that.  */
 .    .    .  .    .    .  .    .    .        do
 .    .    .  .    .    .  .    .    .  	lll_futex_wait (&pd->setxid_futex, 0, LLL_PRIVATE);
 .    .    .  .    .    .  .    .    .        while (pd->cancelhandling & SETXID_BITMASK);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Reset the value so that the stack can be reused.  */
-- line 415 ----------------------------------------
-- line 419 ----------------------------------------
 .    .    .  .    .    .  .    .    .    /* We cannot call '_exit' here.  '_exit' will terminate the process.
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .       The 'exit' implementation in the kernel will signal when the
 .    .    .  .    .    .  .    .    .       process is really dead since 'clone' got passed the CLONE_CHILD_CLEARTID
 .    .    .  .    .    .  .    .    .       flag.  The 'tid' field in the TCB will be set to zero.
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .       The exit code is zero since in case all threads exit by calling
 .    .    .  .    .    .  .    .    .       'pthread_exit' the exit status must be 0 (zero).  */
24    0    0  0    0    0  0    0    0    __exit_thread_inline (0);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* NOTREACHED */
 .    .    .  .    .    .  .    .    .    return 0;
 .    .    .  .    .    .  .    .    .  }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  int
 .    .    .  .    .    .  .    .    .  __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr,
 .    .    .  .    .    .  .    .    .  		      void *(*start_routine) (void *), void *arg)
88    2    2  0    0    0 72    0    0  {
 .    .    .  .    .    .  .    .    .    STACK_VARIABLES;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    const struct pthread_attr *iattr = (struct pthread_attr *) attr;
24    0    0  0    0    0  0    0    0    if (iattr == NULL)
 .    .    .  .    .    .  .    .    .      /* Is this the best idea?  On NUMA machines this could mean
 .    .    .  .    .    .  .    .    .         accessing far-away memory.  */
 .    .    .  .    .    .  .    .    .      iattr = &__default_pthread_attr;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    struct pthread *pd = NULL;
 .    .    .  .    .    .  .    .    .    int err = ALLOCATE_STACK (iattr, &pd);
 .    .    .  .    .    .  .    .    .    if (__builtin_expect (err != 0, 0))
 .    .    .  .    .    .  .    .    .      /* Something went wrong.  Maybe a parameter of the attributes is
-- line 449 ----------------------------------------
-- line 453 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Initialize the TCB.  All initializations with zero should be
 .    .    .  .    .    .  .    .    .       performed in 'get_cached_stack'.  This way we avoid doing this if
 .    .    .  .    .    .  .    .    .       the stack freshly allocated with 'mmap'.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #if TLS_TCB_AT_TP
 .    .    .  .    .    .  .    .    .    /* Reference to the TCB itself.  */
 8    0    0  0    0    0  8    0    0    pd->header.self = pd;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Self-reference for TLS.  */
 8    0    0  0    0    0  8    0    0    pd->header.tcb = pd;
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Store the address of the start routine and the parameter.  Since
 .    .    .  .    .    .  .    .    .       we do not start the function directly the stillborn thread will
 .    .    .  .    .    .  .    .    .       get the information from its thread descriptor.  */
16    0    0  8    0    0  8    8    8    pd->start_routine = start_routine;
16    1    1  8    0    0  8    0    0    pd->arg = arg;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Copy the thread attribute flags.  */
 8    0    0  8    0    0  0    0    0    struct pthread *self = THREAD_SELF;
32    0    0  8    0    0  8    8    8    pd->flags = ((iattr->flags & ~(ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET))
24    0    0  8    1    0  0    0    0  	       | (self->flags & (ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET)));
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Initialize the field for the ID of the thread which is waiting
 .    .    .  .    .    .  .    .    .       for us.  This is a self-reference in case the thread is created
 .    .    .  .    .    .  .    .    .       detached.  */
32    0    0  0    0    0  8    0    0    pd->joinid = iattr->flags & ATTR_FLAG_DETACHSTATE ? pd : NULL;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* The debug events are inherited from the parent.  */
48    1    1 24    1    0 24    0    0    pd->eventbuf = self->eventbuf;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Copy the parent's scheduling parameters.  The flags will say what
 .    .    .  .    .    .  .    .    .       is valid and what is not.  */
16    0    0  8    1    0  8    0    0    pd->schedpolicy = self->schedpolicy;
16    0    0  8    0    0  8    0    0    pd->schedparam = self->schedparam;
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Copy the stack guard canary.  */
 .    .    .  .    .    .  .    .    .  #ifdef THREAD_COPY_STACK_GUARD
16    0    0  8    0    0  8    0    0    THREAD_COPY_STACK_GUARD (pd);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Copy the pointer guard value.  */
 .    .    .  .    .    .  .    .    .  #ifdef THREAD_COPY_POINTER_GUARD
16    1    1  8    0    0  8    0    0    THREAD_COPY_POINTER_GUARD (pd);
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Determine scheduling parameters for the thread.  */
16    0    0  0    0    0  0    0    0    if (attr != NULL
 .    .    .  .    .    .  .    .    .        && __builtin_expect ((iattr->flags & ATTR_FLAG_NOTINHERITSCHED) != 0, 0)
 .    .    .  .    .    .  .    .    .        && (iattr->flags & (ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET)) != 0)
 .    .    .  .    .    .  .    .    .      {
 .    .    .  .    .    .  .    .    .        INTERNAL_SYSCALL_DECL (scerr);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* Use the scheduling parameters the user provided.  */
 .    .    .  .    .    .  .    .    .        if (iattr->flags & ATTR_FLAG_POLICY_SET)
 .    .    .  .    .    .  .    .    .  	pd->schedpolicy = iattr->schedpolicy;
-- line 511 ----------------------------------------
-- line 540 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  __deallocate_stack (pd);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	  return EINVAL;
 .    .    .  .    .    .  .    .    .  	}
 .    .    .  .    .    .  .    .    .      }
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Pass the descriptor to the caller.  */
16    0    0  8    0    0  8    0    0    *newthread = (pthread_t) pd;
 .    .    .  .    .    .  .    .    .  
 8    0    0  0    0    0  0    0    0    LIBC_PROBE (pthread_create, 4, newthread, attr, start_routine, arg);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .    /* Start the thread.  */
 8    0    0  0    0    0  0    0    0    return create_thread (pd, iattr, STACK_VARIABLES_ARGS);
72    0    0 56    0    0  0    0    0  }
 .    .    .  .    .    .  .    .    .  versioned_symbol (libpthread, __pthread_create_2_1, pthread_create, GLIBC_2_1);
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #if SHLIB_COMPAT(libpthread, GLIBC_2_0, GLIBC_2_1)
 .    .    .  .    .    .  .    .    .  int
 .    .    .  .    .    .  .    .    .  __pthread_create_2_0 (pthread_t *newthread, const pthread_attr_t *attr,
 .    .    .  .    .    .  .    .    .  		      void *(*start_routine) (void *), void *arg)
 .    .    .  .    .    .  .    .    .  {
-- line 562 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdlib/bsearch.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 18 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #include <stdlib.h>
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Perform a binary search for KEY in BASE which has NMEMB elements
  .    .    .  .    .    .  .    .    .     of SIZE bytes each.  The comparisons are done by (*COMPAR)().  */
  .    .    .  .    .    .  .    .    .  void *
  .    .    .  .    .    .  .    .    .  bsearch (const void *key, const void *base, size_t nmemb, size_t size,
  .    .    .  .    .    .  .    .    .  	 int (*compar) (const void *, const void *))
 96    1    1  0    0    0 64    0    0  {
  .    .    .  .    .    .  .    .    .    size_t l, u, idx;
  .    .    .  .    .    .  .    .    .    const void *p;
  .    .    .  .    .    .  .    .    .    int comparison;
  .    .    .  .    .    .  .    .    .  
  8    0    0  0    0    0  0    0    0    l = 0;
  .    .    .  .    .    .  .    .    .    u = nmemb;
124    0    0  0    0    0  0    0    0    while (l < u)
  .    .    .  .    .    .  .    .    .      {
108    0    0  0    0    0  0    0    0        idx = (l + u) / 2;
162    0    0 54    0    0  0    0    0        p = (void *) (((const char *) base) + (idx * size));
162    1    1 54    0    0 54    0    0        comparison = (*compar) (key, p);
108    0    0  0    0    0  0    0    0        if (comparison < 0)
 44    0    0  0    0    0  0    0    0  	u = idx;
 10    0    0  0    0    0  0    0    0        else if (comparison > 0)
 10    0    0  0    0    0  0    0    0  	l = idx + 1;
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	return (void *) p;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  8    0    0  0    0    0  0    0    0    return NULL;
 64    0    0 56    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  libc_hidden_def (bsearch)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-reloc.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 140 ----------------------------------------
  .    .    .   .    .    .  .    .    .    memset (__mempcpy (dest, map->l_tls_initimage, map->l_tls_initimage_size),
  .    .    .   .    .    .  .    .    .  	  '\0', map->l_tls_blocksize - map->l_tls_initimage_size);
  .    .    .   .    .    .  .    .    .  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  void
  .    .    .   .    .    .  .    .    .  _dl_relocate_object (struct link_map *l, struct r_scope_elem *scope[],
  .    .    .   .    .    .  .    .    .  		     int reloc_mode, int consider_profiling)
 60    1    1   0    0    0 40    0    0  {
  .    .    .   .    .    .  .    .    .    struct textrels
  .    .    .   .    .    .  .    .    .    {
  .    .    .   .    .    .  .    .    .      caddr_t start;
  .    .    .   .    .    .  .    .    .      size_t len;
  .    .    .   .    .    .  .    .    .      int prot;
  .    .    .   .    .    .  .    .    .      struct textrels *next;
  5    0    0   0    0    0  5    0    0    } *textrels = NULL;
  .    .    .   .    .    .  .    .    .    /* Initialize it to make the compiler happy.  */
  .    .    .   .    .    .  .    .    .    const char *errstring = NULL;
  4    0    0   0    0    0  0    0    0    int lazy = reloc_mode & RTLD_LAZY;
 25    1    1   0    0    0 15    0    0    int skip_ifunc = reloc_mode & __RTLD_NOIFUNC;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifdef SHARED
  .    .    .   .    .    .  .    .    .    /* If we are auditing, install the same handlers we need for profiling.  */
 10    0    0   0    0    0  0    0    0    if ((reloc_mode & __RTLD_AUDIT) == 0)
 20    1    1  10    2    0  0    0    0      consider_profiling |= GLRO(dl_audit) != NULL;
  .    .    .   .    .    .  .    .    .  #elif defined PROF
  .    .    .   .    .    .  .    .    .    /* Never use dynamic linker profiling for gprof profiling code.  */
  .    .    .   .    .    .  .    .    .  # define consider_profiling 0
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
 10    0    0   5    0    0  0    0    0    if (l->l_relocated)
  .    .    .   .    .    .  .    .    .      return;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* If DT_BIND_NOW is set relocate all references in this object.  We
  .    .    .   .    .    .  .    .    .       do not do this if we are profiling, of course.  */
  .    .    .   .    .    .  .    .    .    // XXX Correct for auditing?
 15    0    0   5    0    0  0    0    0    if (!consider_profiling
 10    1    1   5    4    0  0    0    0        && __builtin_expect (l->l_info[DT_BIND_NOW] != NULL, 0))
  3    0    0   0    0    0  0    0    0      lazy = 0;
  .    .    .   .    .    .  .    .    .  
 10    0    0   5    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_RELOC, 0))
  .    .    .   .    .    .  .    .    .      _dl_debug_printf ("\nrelocation processing: %s%s\n",
  .    .    .   .    .    .  .    .    .  		      l->l_name[0] ? l->l_name : rtld_progname,
  .    .    .   .    .    .  .    .    .  		      lazy ? " (lazy)" : "");
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* DT_TEXTREL is now in level 2 and might phase out at some time.
  .    .    .   .    .    .  .    .    .       But we rewrite the DT_FLAGS entry to a DT_TEXTREL entry to make
  .    .    .   .    .    .  .    .    .       testing easier and therefore it will be available at all time.  */
 10    1    1   5    1    0  0    0    0    if (__builtin_expect (l->l_info[DT_TEXTREL] != NULL, 0))
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Bletch.  We must make read-only segments writable
  .    .    .   .    .    .  .    .    .  	 long enough to relocate them.  */
  .    .    .   .    .    .  .    .    .        const ElfW(Phdr) *ph;
  .    .    .   .    .    .  .    .    .        for (ph = l->l_phdr; ph < &l->l_phdr[l->l_phnum]; ++ph)
  .    .    .   .    .    .  .    .    .  	if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0)
  .    .    .   .    .    .  .    .    .  	  {
  .    .    .   .    .    .  .    .    .  	    struct textrels *newp;
-- line 196 ----------------------------------------
-- line 225 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	    textrels = newp;
  .    .    .   .    .    .  .    .    .  	  }
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    {
  .    .    .   .    .    .  .    .    .      /* Do the actual relocation of the object's GOT and other data.  */
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .      /* String table object symbols.  */
 15    0    0  10    0    0  5    0    0      const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .      /* This macro is used as a callback from the ELF_DYNAMIC_RELOCATE code.  */
  .    .    .   .    .    .  .    .    .  #define RESOLVE_MAP(ref, version, r_type) \
  .    .    .   .    .    .  .    .    .      (ELFW(ST_BIND) ((*ref)->st_info) != STB_LOCAL			      \
  .    .    .   .    .    .  .    .    .       ? ((__builtin_expect ((*ref) == l->l_lookup_cache.sym, 0)		      \
  .    .    .   .    .    .  .    .    .  	 && elf_machine_type_class (r_type) == l->l_lookup_cache.type_class)  \
  .    .    .   .    .    .  .    .    .  	? (bump_num_cache_relocations (),				      \
  .    .    .   .    .    .  .    .    .  	   (*ref) = l->l_lookup_cache.ret,				      \
-- line 241 ----------------------------------------
-- line 251 ----------------------------------------
  .    .    .   .    .    .  .    .    .  					scope, v, _tc,			      \
  .    .    .   .    .    .  .    .    .  					DL_LOOKUP_ADD_DEPENDENCY, NULL);      \
  .    .    .   .    .    .  .    .    .  	     l->l_lookup_cache.ret = (*ref);				      \
  .    .    .   .    .    .  .    .    .  	     l->l_lookup_cache.value = _lr; }))				      \
  .    .    .   .    .    .  .    .    .       : l)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #include "dynamic-link.h"
  .    .    .   .    .    .  .    .    .  
298    4    4 104   17    0 63    0    0      ELF_DYNAMIC_RELOCATE (l, lazy, consider_profiling, skip_ifunc);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifndef PROF
 15    1    1   5    0    0  0    0    0      if (__builtin_expect (consider_profiling, 0)
  .    .    .   .    .    .  .    .    .  	&& l->l_info[DT_PLTRELSZ] != NULL)
  .    .    .   .    .    .  .    .    .        {
  .    .    .   .    .    .  .    .    .  	/* Allocate the array which will contain the already found
  .    .    .   .    .    .  .    .    .  	   relocations.  If the shared object lacks a PLT (for example
  .    .    .   .    .    .  .    .    .  	   if it only contains lead function) the l_info[DT_PLTRELSZ]
  .    .    .   .    .    .  .    .    .  	   will be NULL.  */
  .    .    .   .    .    .  .    .    .  	size_t sizeofrel = l->l_info[DT_PLTREL]->d_un.d_val == DT_RELA
  .    .    .   .    .    .  .    .    .  			   ? sizeof (ElfW(Rela))
-- line 270 ----------------------------------------
-- line 278 ----------------------------------------
  .    .    .   .    .    .  .    .    .  %s: out of memory to store relocation results for %s\n");
  .    .    .   .    .    .  .    .    .  	    _dl_fatal_printf (errstring, rtld_progname, l->l_name);
  .    .    .   .    .    .  .    .    .  	  }
  .    .    .   .    .    .  .    .    .        }
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .    }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Mark the object so we know this work has been done.  */
  5    0    0   5    0    0  0    0    0    l->l_relocated = 1;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Undo the segment protection changes.  */
 10    0    0   5    0    0  0    0    0    while (__builtin_expect (textrels != NULL, 0))
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        if (__mprotect (textrels->start, textrels->len, textrels->prot) < 0)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  errstring = N_("cannot restore segment prot after reloc");
  .    .    .   .    .    .  .    .    .  	  goto call_error;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifdef CLEAR_CACHE
-- line 297 ----------------------------------------
-- line 298 ----------------------------------------
  .    .    .   .    .    .  .    .    .        CLEAR_CACHE (textrels->start, textrels->start + textrels->len);
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        textrels = textrels->next;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* In case we can protect the data now that the relocations are
  .    .    .   .    .    .  .    .    .       done, do it.  */
 15    0    0   5    4    0  0    0    0    if (l->l_relro_size != 0)
  .    .    .   .    .    .  .    .    .      _dl_protect_relro (l);
 40    0    0  35    2    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  void internal_function
  .    .    .   .    .    .  .    .    .  _dl_protect_relro (struct link_map *l)
  .    .    .   .    .    .  .    .    .  {
 20    2    2  10    0    0  0    0    0    ElfW(Addr) start = ((l->l_addr + l->l_relro_addr)
 10    0    0   5    0    0  0    0    0  		      & ~(GLRO(dl_pagesize) - 1));
 10    0    0   0    0    0  0    0    0    ElfW(Addr) end = ((l->l_addr + l->l_relro_addr + l->l_relro_size)
  .    .    .   .    .    .  .    .    .  		    & ~(GLRO(dl_pagesize) - 1));
  .    .    .   .    .    .  .    .    .  
 10    0    0   0    0    0  0    0    0    if (start != end
 25    0    0   0    0    0  5    0    0        && __mprotect ((void *) start, end - start, PROT_READ) < 0)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        static const char errstring[] = N_("\
  .    .    .   .    .    .  .    .    .  cannot apply additional memory protection after relocation");
  .    .    .   .    .    .  .    .    .        _dl_signal_error (errno, l->l_name, NULL, errstring);
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  void
-- line 328 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdio-common/vfprintf.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 214 ----------------------------------------
  .    .    .   .    .    .  .    .    .  static CHAR_T *group_number (CHAR_T *, CHAR_T *, const char *, const char *)
  .    .    .   .    .    .  .    .    .       __THROW internal_function;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* The function itself.  */
  .    .    .   .    .    .  .    .    .  int
  .    .    .   .    .    .  .    .    .  vfprintf (FILE *s, const CHAR_T *format, va_list ap)
 77    1    1   0    0    0 42    1    0  {
  .    .    .   .    .    .  .    .    .    /* The character used as thousands separator.  */
  .    .    .   .    .    .  .    .    .  #ifdef COMPILE_WPRINTF
  .    .    .   .    .    .  .    .    .    wchar_t thousands_sep = L'\0';
  .    .    .   .    .    .  .    .    .  #else
  7    0    0   0    0    0  7    0    0    const char *thousands_sep = NULL;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* The string describing the size of groups of digits.  */
  .    .    .   .    .    .  .    .    .    const char *grouping;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Place to accumulate the result.  */
  .    .    .   .    .    .  .    .    .    int done;
  .    .    .   .    .    .  .    .    .  
-- line 235 ----------------------------------------
-- line 249 ----------------------------------------
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* We have to save the original argument pointer.  */
  .    .    .   .    .    .  .    .    .    va_list ap_save;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Count number of specifiers we already processed.  */
  .    .    .   .    .    .  .    .    .    int nspecs_done;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* For the %m format we may need the current `errno' value.  */
 21    0    0  14    1    0  7    0    0    int save_errno = errno;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* 1 if format is in read-only memory, -1 if it is in writable memory,
  .    .    .   .    .    .  .    .    .       0 if unknown.  */
  7    0    0   0    0    0  7    0    0    int readonly_format = 0;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* For the argument descriptions, which may be allocated on the heap.  */
  7    0    0   0    0    0  7    0    0    void *args_malloced = NULL;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* For positional argument handling.  */
  .    .    .   .    .    .  .    .    .    struct printf_spec *specs;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Track if we malloced the SPECS array and thus must free it.  */
  7    0    0   0    0    0  7    0    0    bool specs_malloced = false;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* This table maps a character into a number representing a
  .    .    .   .    .    .  .    .    .       class.  In each step there is a destination label for each
  .    .    .   .    .    .  .    .    .       class.  */
  .    .    .   .    .    .  .    .    .    static const uint8_t jump_table[] =
  .    .    .   .    .    .  .    .    .    {
  .    .    .   .    .    .  .    .    .      /* ' ' */  1,            0,            0, /* '#' */  4,
  .    .    .   .    .    .  .    .    .  	       0, /* '%' */ 14,            0, /* '\''*/  6,
-- line 278 ----------------------------------------
-- line 1263 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	if (__builtin_expect (string_malloced, 0))			      \
  .    .    .   .    .    .  .    .    .  	  free (string);						      \
  .    .    .   .    .    .  .    .    .        }									      \
  .    .    .   .    .    .  .    .    .        break;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Orient the stream.  */
  .    .    .   .    .    .  .    .    .  #ifdef ORIENT
 34    1    1   7    1    0  1    0    0    ORIENT;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Sanity check of arguments.  */
 35    0    0   7    1    1  0    0    0    ARGCHECK (s, format);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifdef ORIENT
  .    .    .   .    .    .  .    .    .    /* Check for correct orientation.  */
  .    .    .   .    .    .  .    .    .    if (_IO_vtable_offset (s) == 0 &&
  .    .    .   .    .    .  .    .    .        _IO_fwide (s, sizeof (CHAR_T) == 1 ? -1 : 1)
  .    .    .   .    .    .  .    .    .        != (sizeof (CHAR_T) == 1 ? -1 : 1))
  .    .    .   .    .    .  .    .    .      /* The stream is already oriented otherwise.  */
  .    .    .   .    .    .  .    .    .      return EOF;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
 14    0    0   0    0    0  0    0    0    if (UNBUFFERED_P (s))
  .    .    .   .    .    .  .    .    .      /* Use a helper function which will allocate a local temporary buffer
  .    .    .   .    .    .  .    .    .         for the stream and then call us again.  */
  .    .    .   .    .    .  .    .    .      return buffered_vfprintf (s, format, ap);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Initialize local variables.  */
  .    .    .   .    .    .  .    .    .    done = 0;
  7    0    0   0    0    0  7    0    0    grouping = (const char *) -1;
  .    .    .   .    .    .  .    .    .  #ifdef __va_copy
  .    .    .   .    .    .  .    .    .    /* This macro will be available soon in gcc's <stdarg.h>.  We need it
  .    .    .   .    .    .  .    .    .       since on some systems `va_list' is not an integral type.  */
 42    1    1  21    0    0 21    0    0    __va_copy (ap_save, ap);
  .    .    .   .    .    .  .    .    .  #else
  .    .    .   .    .    .  .    .    .    ap_save = ap;
  .    .    .   .    .    .  .    .    .  #endif
  7    1    1   0    0    0  7    0    0    nspecs_done = 0;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #ifdef COMPILE_WPRINTF
  .    .    .   .    .    .  .    .    .    /* Find the first format specifier.  */
  .    .    .   .    .    .  .    .    .    f = lead_str_end = __find_specwc ((const UCHAR_T *) format);
  .    .    .   .    .    .  .    .    .  #else
  .    .    .   .    .    .  .    .    .    /* Find the first format specifier.  */
  7    0    0   0    0    0  7    0    0    f = lead_str_end = __find_specmb ((const UCHAR_T *) format);
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Lock stream.  */
 98    2    2  28    2    0 21    0    0    _IO_cleanup_region_start ((void (*) (void *)) &_IO_funlockfile, s);
126    3    3  63    1    0  7    0    0    _IO_flockfile (s);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Write the literal text before the first format.  */
 91    1    1  21    1    0 21    0    0    outstring ((const UCHAR_T *) format,
  .    .    .   .    .    .  .    .    .  	     lead_str_end - (const UCHAR_T *) format);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* If we only have to print a simple string, return now.  */
 21    0    0  14    0    0  0    0    0    if (*f == L_('\0'))
  .    .    .   .    .    .  .    .    .      goto all_done;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Use the slow path in case any printf handler is registered.  */
 49    1    1  21    4    1  0    0    0    if (__builtin_expect (__printf_function_table != NULL
  .    .    .   .    .    .  .    .    .  			|| __printf_modifier_table != NULL
  .    .    .   .    .    .  .    .    .  			|| __printf_va_arg_table != NULL, 0))
  .    .    .   .    .    .  .    .    .      goto do_positional;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Process whole format string.  */
  .    .    .   .    .    .  .    .    .    do
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .  #ifdef SHARED
-- line 1332 ----------------------------------------
-- line 1343 ----------------------------------------
  .    .    .   .    .    .  .    .    .        union
  .    .    .   .    .    .  .    .    .        {
  .    .    .   .    .    .  .    .    .  	unsigned long long int longlong;
  .    .    .   .    .    .  .    .    .  	unsigned long int word;
  .    .    .   .    .    .  .    .    .        } number;
  .    .    .   .    .    .  .    .    .        int base;
  .    .    .   .    .    .  .    .    .        union printf_arg the_arg;
  .    .    .   .    .    .  .    .    .        CHAR_T *string;	/* Pointer to argument string.  */
  7    0    0   0    0    0  7    0    0        int alt = 0;	/* Alternate format.  */
  7    0    0   0    0    0  7    0    0        int space = 0;	/* Use space prefix if no sign is needed.  */
  7    0    0   0    0    0  7    0    0        int left = 0;	/* Left-justify output.  */
  7    0    0   0    0    0  7    1    1        int showsign = 0;	/* Always begin with plus or minus sign.  */
  7    0    0   0    0    0  7    0    0        int group = 0;	/* Print numbers according grouping rules.  */
  7    1    1   0    0    0  7    0    0        int is_long_double = 0; /* Argument is long double/ long long int.  */
  7    0    0   0    0    0  7    0    0        int is_short = 0;	/* Argument is short int.  */
  7    0    0   0    0    0  7    0    0        int is_long = 0;	/* Argument is long int.  */
  7    0    0   0    0    0  7    0    0        int is_char = 0;	/* Argument is promoted (unsigned) char.  */
  7    0    0   0    0    0  7    0    0        int width = 0;	/* Width of output; 0 means none specified.  */
  7    0    0   0    0    0  7    0    0        int prec = -1;	/* Precision of output; -1 means none specified.  */
  .    .    .   .    .    .  .    .    .        /* This flag is set by the 'I' modifier and selects the use of the
  .    .    .   .    .    .  .    .    .  	 `outdigits' as determined by the current locale.  */
  7    0    0   0    0    0  7    0    0        int use_outdigits = 0;
  7    0    0   0    0    0  7    0    0        UCHAR_T pad = L_(' ');/* Padding character.  */
  .    .    .   .    .    .  .    .    .        CHAR_T spec;
  .    .    .   .    .    .  .    .    .  
  7    0    0   0    0    0  0    0    0        workstart = NULL;
  7    0    0   0    0    0  0    0    0        workend = &work_buffer[sizeof (work_buffer) / sizeof (CHAR_T)];
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Get current character in format string.  */
119    3    3  28    4    4 14    0    0        JUMP (*++f, step0_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* ' ' flag.  */
  .    .    .   .    .    .  .    .    .      LABEL (flag_space):
  2    1    1   0    0    0  1    0    0        space = 1;
 17    2    2   5    1    0  2    0    0        JUMP (*++f, step0_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* '+' flag.  */
  .    .    .   .    .    .  .    .    .      LABEL (flag_plus):
  .    .    .   .    .    .  .    .    .        showsign = 1;
  .    .    .   .    .    .  .    .    .        JUMP (*++f, step0_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* The '-' flag.  */
  .    .    .   .    .    .  .    .    .      LABEL (flag_minus):
-- line 1385 ----------------------------------------
-- line 1517 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .        if (*f == L_('$'))
  .    .    .   .    .    .  .    .    .  	/* Oh, oh.  The argument comes from a positional parameter.  */
  .    .    .   .    .    .  .    .    .  	goto do_positional;
  .    .    .   .    .    .  .    .    .        JUMP (*f, step1_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .      LABEL (precision):
  4    1    1   1    0    0  1    0    0        ++f;
  3    0    0   1    0    0  0    0    0        if (*f == L_('*'))
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  const UCHAR_T *tmp;	/* Temporary value.  */
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  tmp = ++f;
  .    .    .   .    .    .  .    .    .  	  if (ISDIGIT (*tmp))
  .    .    .   .    .    .  .    .    .  	    {
 21    0    0   0    0    0  7    0    0  	      int pos = read_int (&tmp);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	      if (pos == -1)
  .    .    .   .    .    .  .    .    .  		{
  .    .    .   .    .    .  .    .    .  		  __set_errno (EOVERFLOW);
  .    .    .   .    .    .  .    .    .  		  done = -1;
  .    .    .   .    .    .  .    .    .  		  goto all_done;
  .    .    .   .    .    .  .    .    .  		}
  .    .    .   .    .    .  .    .    .  
-- line 1541 ----------------------------------------
-- line 1544 ----------------------------------------
  .    .    .   .    .    .  .    .    .  		goto do_positional;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	  prec = va_arg (ap, int);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  /* If the precision is negative the precision is omitted.  */
  .    .    .   .    .    .  .    .    .  	  if (prec < 0)
  .    .    .   .    .    .  .    .    .  	    prec = -1;
  .    .    .   .    .    .  .    .    .  	}
  4    1    1   0    0    0  0    0    0        else if (ISDIGIT (*f))
  .    .    .   .    .    .  .    .    .  	{
 18    2    2   1    0    0 10    1    1  	  prec = read_int (&f);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  /* The precision was specified in this case as an extremely
  .    .    .   .    .    .  .    .    .  	     large positive value.  */
  3    0    0   1    0    0  0    0    0  	  if (prec == -1)
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      __set_errno (EOVERFLOW);
  .    .    .   .    .    .  .    .    .  	      done = -1;
  .    .    .   .    .    .  .    .    .  	      goto all_done;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .        else
  1    0    0   0    0    0  1    0    0  	prec = 0;
  2    0    0   1    0    0  0    0    0        if (prec > width
  .    .    .   .    .    .  .    .    .  	  && prec > sizeof (work_buffer) / sizeof (work_buffer[0]) - 32)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  if (__builtin_expect (prec >= INT_MAX / sizeof (CHAR_T) - 32, 0))
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      __set_errno (EOVERFLOW);
  .    .    .   .    .    .  .    .    .  	      done = -1;
  .    .    .   .    .    .  .    .    .  	      goto all_done;
  .    .    .   .    .    .  .    .    .  	    }
-- line 1575 ----------------------------------------
-- line 1580 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	  else
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      workstart = (CHAR_T *) malloc (needed);
  .    .    .   .    .    .  .    .    .  	      if (workstart == NULL)
  .    .    .   .    .    .  .    .    .  		{
  .    .    .   .    .    .  .    .    .  		  done = -1;
  .    .    .   .    .    .  .    .    .  		  goto all_done;
  .    .    .   .    .    .  .    .    .  		}
  2    1    1   1    0    0  0    0    0  	      workend = workstart + prec + 32;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	}
 16    1    1   4    2    1  1    0    0        JUMP (*f, step2_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Process 'h' modifier.  There might another 'h' following.  */
  .    .    .   .    .    .  .    .    .      LABEL (mod_half):
  .    .    .   .    .    .  .    .    .        is_short = 1;
  .    .    .   .    .    .  .    .    .        JUMP (*++f, step3a_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Process 'hh' modifier.  */
  .    .    .   .    .    .  .    .    .      LABEL (mod_halfhalf):
-- line 1599 ----------------------------------------
-- line 1626 ----------------------------------------
  .    .    .   .    .    .  .    .    .      LABEL (mod_intmax_t):
  .    .    .   .    .    .  .    .    .        is_long_double = sizeof (intmax_t) > sizeof (unsigned long int);
  .    .    .   .    .    .  .    .    .        is_long = sizeof (intmax_t) > sizeof (unsigned int);
  .    .    .   .    .    .  .    .    .        JUMP (*++f, step4_jumps);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Process current format.  */
  .    .    .   .    .    .  .    .    .        while (1)
  .    .    .   .    .    .  .    .    .  	{
759   30   30 259    0    0 95    0    0  	  process_arg (((struct printf_spec *) NULL));
  .    .    .   .    .    .  .    .    .  	  process_string_arg (((struct printf_spec *) NULL));
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	LABEL (form_unknown):
  .    .    .   .    .    .  .    .    .  	  if (spec == L_('\0'))
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      /* The format string ended before the specifier is complete.  */
  .    .    .   .    .    .  .    .    .  	      __set_errno (EINVAL);
  .    .    .   .    .    .  .    .    .  	      done = -1;
-- line 1642 ----------------------------------------
-- line 1646 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	  /* If we are in the fast loop force entering the complicated
  .    .    .   .    .    .  .    .    .  	     one.  */
  .    .    .   .    .    .  .    .    .  	  goto do_positional;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* The format is correctly handled.  */
  .    .    .   .    .    .  .    .    .        ++nspecs_done;
  .    .    .   .    .    .  .    .    .  
 14    1    1   0    0    0  0    0    0        if (__builtin_expect (workstart != NULL, 0))
  .    .    .   .    .    .  .    .    .  	free (workstart);
  7    0    0   0    0    0  0    0    0        workstart = NULL;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Look for next format specifier.  */
  .    .    .   .    .    .  .    .    .  #ifdef COMPILE_WPRINTF
  .    .    .   .    .    .  .    .    .        f = __find_specwc ((end_of_spec = ++f));
  .    .    .   .    .    .  .    .    .  #else
 28    0    0   7    0    0 14    0    0        f = __find_specmb ((end_of_spec = ++f));
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Write the following constant string.  */
154    1    1  35    0    0 28    0    0        outstring (end_of_spec, f - end_of_spec);
  .    .    .   .    .    .  .    .    .      }
 14    0    0   7    0    0  0    0    0    while (*f != L_('\0'));
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Unlock stream and return.  */
  .    .    .   .    .    .  .    .    .    goto all_done;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Here starts the more complex loop to handle positional parameters.  */
  .    .    .   .    .    .  .    .    .  do_positional:
  .    .    .   .    .    .  .    .    .    {
  .    .    .   .    .    .  .    .    .      /* Array with information about the needed arguments.  This has to
-- line 1676 ----------------------------------------
-- line 2048 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	/* Write the following constant string.  */
  .    .    .   .    .    .  .    .    .  	outstring (specs[nspecs_done].end_of_fmt,
  .    .    .   .    .    .  .    .    .  		   specs[nspecs_done].next_fmt
  .    .    .   .    .    .  .    .    .  		   - specs[nspecs_done].end_of_fmt);
  .    .    .   .    .    .  .    .    .        }
  .    .    .   .    .    .  .    .    .    }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  all_done:
 14    2    1   7    0    0  0    0    0    if (specs_malloced)
  .    .    .   .    .    .  .    .    .      free (specs);
 14    0    0   7    0    0  7    0    0    free (args_malloced);
 14    0    0   0    0    0  7    0    0    free (workstart);
  .    .    .   .    .    .  .    .    .    /* Unlock the stream.  */
 77    2    2  42    0    0  7    0    0    _IO_funlockfile (s);
 70    0    0  21    0    0  7    0    0    _IO_cleanup_region_end (0);
  .    .    .   .    .    .  .    .    .  
  7    0    0   7    0    0  0    0    0    return done;
 56    0    0  49    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* Handle an unknown format specifier.  This prints out a canonicalized
  .    .    .   .    .    .  .    .    .     representation of the format spec itself.  */
  .    .    .   .    .    .  .    .    .  static int
  .    .    .   .    .    .  .    .    .  printf_unknown (FILE *s, const struct printf_info *info,
  .    .    .   .    .    .  .    .    .  		const void *const *args)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  {
-- line 2073 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-object.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 25 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #include <assert.h>
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Add the new link_map NEW to the end of the namespace list.  */
  .    .    .  .    .    .  .    .    .  void
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_add_to_namespace_list (struct link_map *new, Lmid_t nsid)
 20    2    2  0    0    0  8    0    0  {
  .    .    .  .    .    .  .    .    .    /* We modify the list of loaded objects.  */
  8    0    0  4    0    0  4    0    0    __rtld_lock_lock_recursive (GL(dl_load_write_lock));
  .    .    .  .    .    .  .    .    .  
 29    0    0  4    0    0  0    0    0    if (GL(dl_ns)[nsid]._ns_loaded != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        struct link_map *l = GL(dl_ns)[nsid]._ns_loaded;
 27    0    0  9    0    0  0    0    0        while (l->l_next != NULL)
  6    0    0  0    0    0  0    0    0  	l = l->l_next;
  3    0    0  0    0    0  3    0    0        new->l_prev = l;
  .    .    .  .    .    .  .    .    .        /* new->l_next = NULL;   Would be necessary but we use calloc.  */
  3    0    0  0    0    0  3    0    0        l->l_next = new;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  2    1    1  0    0    0  1    0    0      GL(dl_ns)[nsid]._ns_loaded = new;
 12    0    0  4    0    0  0    0    0    ++GL(dl_ns)[nsid]._ns_nloaded;
  8    0    0  4    0    0  4    0    0    new->l_serial = GL(dl_load_adds);
  8    0    0  0    0    0  4    0    0    ++GL(dl_load_adds);
  .    .    .  .    .    .  .    .    .  
 12    0    0  4    0    0  0    0    0    __rtld_lock_unlock_recursive (GL(dl_load_write_lock));
 12    0    0  8    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Allocate a `struct link_map' for a new object being loaded,
  .    .    .  .    .    .  .    .    .     and enter it into the _dl_loaded list.  */
  .    .    .  .    .    .  .    .    .  struct link_map *
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_new_object (char *realname, const char *libname, int type,
  .    .    .  .    .    .  .    .    .  		struct link_map *loader, int mode, Lmid_t nsid)
 52    1    1  0    0    0 36    0    0  {
 20    0    0  0    0    0  4    0    0    size_t libname_len = strlen (libname) + 1;
  .    .    .  .    .    .  .    .    .    struct link_map *new;
  .    .    .  .    .    .  .    .    .    struct libname_list *newname;
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .    /* We create the map for the executable before we know whether we have
  .    .    .  .    .    .  .    .    .       auditing libraries and if yes, how many.  Assume the worst.  */
 48    1    1  8    0    0  0    0    0    unsigned int naudit = GLRO(dl_naudit) ?: ((mode & __RTLD_OPENEXEC)
  .    .    .  .    .    .  .    .    .  					    ? DL_NNS : 0);
  .    .    .  .    .    .  .    .    .    size_t audit_space = naudit * sizeof (new->l_audit[0]);
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .  # define audit_space 0
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
 20    0    0  0    0    0  8    0    0    new = (struct link_map *) calloc (sizeof (*new) + audit_space
  .    .    .  .    .    .  .    .    .  				    + sizeof (struct link_map *)
  .    .    .  .    .    .  .    .    .  				    + sizeof (*newname) + libname_len, 1);
  8    1    1  0    0    0  0    0    0    if (new == NULL)
  .    .    .  .    .    .  .    .    .      return NULL;
  .    .    .  .    .    .  .    .    .  
  4    0    0  0    0    0  4    3    3    new->l_real = new;
  8    0    0  0    0    0  4    4    4    new->l_symbolic_searchlist.r_list = (struct link_map **) ((char *) (new + 1)
  .    .    .  .    .    .  .    .    .  							    + audit_space);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    new->l_libname = newname
  8    0    0  0    0    0  4    2    2      = (struct libname_list *) (new->l_symbolic_searchlist.r_list + 1);
 20    0    0  4    0    0  8    1    1    newname->name = (char *) memcpy (newname + 1, libname, libname_len);
  .    .    .  .    .    .  .    .    .    /* newname->next = NULL;	We use calloc therefore not necessary.  */
  4    1    1  0    0    0  4    0    0    newname->dont_free = 1;
  .    .    .  .    .    .  .    .    .  
  8    0    0  4    0    0  4    0    0    new->l_name = realname;
 24    0    0  8    4    4  4    0    0    new->l_type = type;
  .    .    .  .    .    .  .    .    .    /* If we set the bit now since we know it is never used we avoid
  .    .    .  .    .    .  .    .    .       dirtying the cache line later.  */
  8    0    0  4    0    0  0    0    0    if ((GLRO(dl_debug_mask) & DL_DEBUG_UNUSED) == 0)
  9    1    1  0    0    0  4    4    4      new->l_used = 1;
  4    0    0  0    0    0  4    0    0    new->l_loader = loader;
  .    .    .  .    .    .  .    .    .  #if NO_TLS_OFFSET != 0
  .    .    .  .    .    .  .    .    .    new->l_tls_offset = NO_TLS_OFFSET;
  .    .    .  .    .    .  .    .    .  #endif
  4    1    1  0    0    0  4    0    0    new->l_ns = nsid;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
 45    0    0  0    0    0  0    0    0    for (unsigned int cnt = 0; cnt < naudit; ++cnt)
  .    .    .  .    .    .  .    .    .      {
 32    0    0  0    0    0 16    5    5        new->l_audit[cnt].cookie = (uintptr_t) new;
  .    .    .  .    .    .  .    .    .        /* new->l_audit[cnt].bindflags = 0; */
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* new->l_global = 0;	We use calloc therefore not necessary.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Use the 'l_scope_mem' array by default for the 'l_scope'
  .    .    .  .    .    .  .    .    .       information.  If we need more entries we will allocate a large
  .    .    .  .    .    .  .    .    .       array dynamically.  */
  8    0    0  0    0    0  4    1    1    new->l_scope = new->l_scope_mem;
  4    1    1  0    0    0  4    4    4    new->l_scope_max = sizeof (new->l_scope_mem) / sizeof (new->l_scope_mem[0]);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Counter for the scopes we have to handle.  */
  4    0    0  0    0    0  0    0    0    int idx = 0;
  .    .    .  .    .    .  .    .    .  
 24    0    0  4    1    1  0    0    0    if (GL(dl_ns)[nsid]._ns_loaded != NULL)
  .    .    .  .    .    .  .    .    .      /* Add the global scope.  */
  9    0    0  0    0    0  3    2    2      new->l_scope[idx++] = &GL(dl_ns)[nsid]._ns_loaded->l_searchlist;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* If we have no loader the new object acts as it.  */
  9    0    0  0    0    0  0    0    0    if (loader == NULL)
  .    .    .  .    .    .  .    .    .      loader = new;
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      /* Determine the local scope.  */
  9    0    0  3    0    0  0    0    0      while (loader->l_loader != NULL)
  .    .    .  .    .    .  .    .    .        loader = loader->l_loader;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Insert the scope if it isn't the global scope we already added.  */
 21    0    0  3    0    0  0    0    0    if (idx == 0 || &loader->l_searchlist != new->l_scope[0])
  .    .    .  .    .    .  .    .    .      {
  1    1    1  0    0    0  0    0    0        if ((mode & RTLD_DEEPBIND) != 0 && idx != 0)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  new->l_scope[1] = new->l_scope[0];
  .    .    .  .    .    .  .    .    .  	  idx = 0;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  1    1    1        new->l_scope[idx] = &loader->l_searchlist;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  8    0    0  0    0    0  4    0    0    new->l_local_scope[0] = &new->l_searchlist;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Don't try to find the origin for the main map which has the name "".  */
 20    1    1  8    0    0  0    0    0    if (realname[0] != '\0')
  .    .    .  .    .    .  .    .    .      {
 15    0    0  3    0    0  6    0    0        size_t realname_len = strlen (realname) + 1;
  .    .    .  .    .    .  .    .    .        char *origin;
  .    .    .  .    .    .  .    .    .        char *cp;
  .    .    .  .    .    .  .    .    .  
 15    0    0  0    0    0  0    0    0        if (realname[0] == '/')
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  /* It is an absolute path.  Use it.  But we have to make a
  .    .    .  .    .    .  .    .    .  	     copy since we strip out the trailing slash.  */
  9    1    1  0    0    0  3    0    0  	  cp = origin = (char *) malloc (realname_len);
 12    0    0  0    0    0  0    0    0  	  if (origin == NULL)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      origin = (char *) -1;
  .    .    .  .    .    .  .    .    .  	      goto out;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  size_t len = realname_len;
-- line 169 ----------------------------------------
-- line 198 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	     slash.  We could use rawmemchr but this need not be
  .    .    .  .    .    .  .    .    .  	     fast.  */
  .    .    .  .    .    .  .    .    .  	  cp = (strchr) (origin, '\0');
  .    .    .  .    .    .  .    .    .  	  if (cp[-1] != '/')
  .    .    .  .    .    .  .    .    .  	    *cp++ = '/';
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Add the real file name.  */
 12    1    1  6    0    0  3    0    0        cp = __mempcpy (cp, realname, realname_len);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Now remove the filename and the slash.  Leave the slash if
  .    .    .  .    .    .  .    .    .  	 the name is something like "/foo".  */
  .    .    .  .    .    .  .    .    .        do
115    0    0  0    0    0  0    0    0  	--cp;
124    0    0 59    0    0  0    0    0        while (*cp != '/');
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (cp == origin)
  .    .    .  .    .    .  .    .    .  	/* Keep the only slash which is the first character.  */
  .    .    .  .    .    .  .    .    .  	++cp;
  6    0    0  0    0    0  3    0    0        *cp = '\0';
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      out:
  6    0    0  0    0    0  3    0    0        new->l_origin = origin;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return new;
 32    1    1 28    0    0  0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../sysdeps/x86_64/dl-machine.h
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr    D1mr DLmr Dw    D1mw DLmw 

-- line 51 ----------------------------------------
    .    .    .     .    .    .     .    .    .  /* Return the run-time load address of the shared object.  */
    .    .    .     .    .    .     .    .    .  static inline ElfW(Addr) __attribute__ ((unused))
    .    .    .     .    .    .     .    .    .  elf_machine_load_address (void)
    .    .    .     .    .    .     .    .    .  {
    .    .    .     .    .    .     .    .    .    /* Compute the difference between the runtime address of _DYNAMIC as seen
    .    .    .     .    .    .     .    .    .       by an IP-relative reference, and the link-time address found in the
    .    .    .     .    .    .     .    .    .       special unrelocated first GOT entry.  */
    .    .    .     .    .    .     .    .    .    extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;
    3    1    1     1    1    1     0    0    0    return (ElfW(Addr)) &_DYNAMIC - elf_machine_dynamic ();
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  /* Set up the loaded object described by L so its unrelocated PLT
    .    .    .     .    .    .     .    .    .     entries will jump to the on-demand fixup code in dl-runtime.c.  */
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  static inline int __attribute__ ((unused, always_inline))
    .    .    .     .    .    .     .    .    .  elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
    .    .    .     .    .    .     .    .    .  {
-- line 67 ----------------------------------------
-- line 68 ----------------------------------------
    .    .    .     .    .    .     .    .    .    Elf64_Addr *got;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_resolve_fxsave (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_resolve_xsave (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_resolve_xsavec (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_profile_sse (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_profile_avx (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .    extern void _dl_runtime_profile_avx512 (ElfW(Word)) attribute_hidden;
    .    .    .     .    .    .     .    .    .  
   20    1    1     5    0    0     0    0    0    if (l->l_info[DT_JMPREL] && lazy)
    .    .    .     .    .    .     .    .    .      {
    .    .    .     .    .    .     .    .    .        /* The GOT entries for functions in the PLT have not yet been filled
    .    .    .     .    .    .     .    .    .  	 in.  Their initial contents will arrange when called to push an
    .    .    .     .    .    .     .    .    .  	 offset into the .rel.plt section, push _GLOBAL_OFFSET_TABLE_[1],
    .    .    .     .    .    .     .    .    .  	 and then jump to _GLOBAL_OFFSET_TABLE_[2].  */
    4    0    0     4    1    0     0    0    0        got = (Elf64_Addr *) D_PTR (l, l_info[DT_PLTGOT]);
    .    .    .     .    .    .     .    .    .        /* If a library is prelinked but we have to relocate anyway,
    .    .    .     .    .    .     .    .    .  	 we have to be able to undo the prelinking of .got.plt.
    .    .    .     .    .    .     .    .    .  	 The prelinker saved us here address of .plt + 0x16.  */
    6    0    0     2    2    1     0    0    0        if (got[1])
    .    .    .     .    .    .     .    .    .  	{
    .    .    .     .    .    .     .    .    .  	  l->l_mach.plt = got[1] + l->l_addr;
    .    .    .     .    .    .     .    .    .  	  l->l_mach.gotplt = (ElfW(Addr)) &got[3];
    .    .    .     .    .    .     .    .    .  	}
    .    .    .     .    .    .     .    .    .        /* Identify this shared object.  */
    2    0    0     0    0    0     2    0    0        *(ElfW(Addr) *) (got + 1) = (ElfW(Addr)) l;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        /* The got[2] entry contains the address of a function which gets
    .    .    .     .    .    .     .    .    .  	 called to get the address of a so far unresolved function and
    .    .    .     .    .    .     .    .    .  	 jump to it.  The profiling extension of the dynamic linker allows
    .    .    .     .    .    .     .    .    .  	 to intercept the calls to collect information.  In this case we
    .    .    .     .    .    .     .    .    .  	 don't store the address in the GOT so that all future calls also
    .    .    .     .    .    .     .    .    .  	 end in this function.  */
    6    0    0     2    0    0     0    0    0        if (__builtin_expect (profile, 0))
    .    .    .     .    .    .     .    .    .  	{
    .    .    .     .    .    .     .    .    .  	  if (HAS_ARCH_FEATURE (AVX512F_Usable))
    .    .    .     .    .    .     .    .    .  	    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_avx512;
    .    .    .     .    .    .     .    .    .  	  else if (HAS_ARCH_FEATURE (AVX_Usable))
    .    .    .     .    .    .     .    .    .  	    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_avx;
    .    .    .     .    .    .     .    .    .  	  else
    .    .    .     .    .    .     .    .    .  	    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_sse;
    .    .    .     .    .    .     .    .    .  
-- line 108 ----------------------------------------
-- line 112 ----------------------------------------
    .    .    .     .    .    .     .    .    .  	       want profiling and the timers are started.  */
    .    .    .     .    .    .     .    .    .  	    GL(dl_profile_map) = l;
    .    .    .     .    .    .     .    .    .  	}
    .    .    .     .    .    .     .    .    .        else
    .    .    .     .    .    .     .    .    .  	{
    .    .    .     .    .    .     .    .    .  	  /* This function will get called to fix up the GOT entry
    .    .    .     .    .    .     .    .    .  	     indicated by the offset on the stack, and then jump to
    .    .    .     .    .    .     .    .    .  	     the resolved address.  */
    4    0    0     2    0    0     0    0    0  	  if (GLRO(dl_x86_cpu_features).xsave_state_size != 0)
    .    .    .     .    .    .     .    .    .  	    *(ElfW(Addr) *) (got + 2)
    4    0    0     0    0    0     2    0    0  	      = (HAS_ARCH_FEATURE (XSAVEC_Usable)
    .    .    .     .    .    .     .    .    .  		 ? (ElfW(Addr)) &_dl_runtime_resolve_xsavec
    8    1    1     2    0    0     0    0    0  		 : (ElfW(Addr)) &_dl_runtime_resolve_xsave);
    .    .    .     .    .    .     .    .    .  	  else
    .    .    .     .    .    .     .    .    .  	    *(ElfW(Addr) *) (got + 2)
    .    .    .     .    .    .     .    .    .  	      = (ElfW(Addr)) &_dl_runtime_resolve_fxsave;
    .    .    .     .    .    .     .    .    .  	}
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  
    8    0    0     2    2    0     0    0    0    if (l->l_info[ADDRIDX (DT_TLSDESC_GOT)] && lazy)
    .    .    .     .    .    .     .    .    .      *(ElfW(Addr)*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
    .    .    .     .    .    .     .    .    .        = (ElfW(Addr)) &_dl_tlsdesc_resolve_rela;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    return lazy;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  /* Initial entry point code for the dynamic linker.
    .    .    .     .    .    .     .    .    .     The C function `_dl_start' is the real entry point;
-- line 139 ----------------------------------------
-- line 213 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  /* We define an initialization function.  This is called very early in
    .    .    .     .    .    .     .    .    .     _dl_sysdep_start.  */
    .    .    .     .    .    .     .    .    .  #define DL_PLATFORM_INIT dl_platform_init ()
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  static inline void __attribute__ ((unused))
    .    .    .     .    .    .     .    .    .  dl_platform_init (void)
    .    .    .     .    .    .     .    .    .  {
    5    0    0     2    1    1     0    0    0    if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
    .    .    .     .    .    .     .    .    .      /* Avoid an empty string which would disturb us.  */
    .    .    .     .    .    .     .    .    .      GLRO(dl_platform) = NULL;
    .    .    .     .    .    .     .    .    .  
    1    0    0     0    0    0     1    0    0    init_cpu_features (&GLRO(dl_x86_cpu_features));
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  static inline ElfW(Addr)
    .    .    .     .    .    .     .    .    .  elf_machine_fixup_plt (struct link_map *map, lookup_t t,
    .    .    .     .    .    .     .    .    .  		       const ElfW(Rela) *reloc,
    .    .    .     .    .    .     .    .    .  		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)
    .    .    .     .    .    .     .    .    .  {
   24    0    0     0    0    0    24    0    0    return *reloc_addr = value;
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  /* Return the final value of a PLT relocation.  On x86-64 the
    .    .    .     .    .    .     .    .    .     JUMP_SLOT relocation ignores the addend.  */
    .    .    .     .    .    .     .    .    .  static inline ElfW(Addr)
    .    .    .     .    .    .     .    .    .  elf_machine_plt_value (struct link_map *map, const ElfW(Rela) *reloc,
    .    .    .     .    .    .     .    .    .  		       ElfW(Addr) value)
    .    .    .     .    .    .     .    .    .  {
-- line 241 ----------------------------------------
-- line 256 ----------------------------------------
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  auto inline void
    .    .    .     .    .    .     .    .    .  __attribute__ ((always_inline))
    .    .    .     .    .    .     .    .    .  elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
    .    .    .     .    .    .     .    .    .  		  const ElfW(Sym) *sym, const struct r_found_version *version,
    .    .    .     .    .    .     .    .    .  		  void *const reloc_addr_arg, int skip_ifunc)
    .    .    .     .    .    .     .    .    .  {
    .    .    .     .    .    .     .    .    .    ElfW(Addr) *const reloc_addr = reloc_addr_arg;
    9    0    0     0    0    0     0    0    0    const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  # if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
  402    0    0     0    0    0     0    0    0    if (__builtin_expect (r_type == R_X86_64_RELATIVE, 0))
    .    .    .     .    .    .     .    .    .      {
    .    .    .     .    .    .     .    .    .  #  if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC
    .    .    .     .    .    .     .    .    .        /* This is defined in rtld.c, but nowhere in the static libc.a;
    .    .    .     .    .    .     .    .    .  	 make the reference weak so static programs can still link.
    .    .    .     .    .    .     .    .    .  	 This declaration cannot be done when compiling rtld.c
    .    .    .     .    .    .     .    .    .  	 (i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the
    .    .    .     .    .    .     .    .    .  	 common defn for _dl_rtld_map, which is incompatible with a
    .    .    .     .    .    .     .    .    .  	 weak decl in the same file.  */
-- line 275 ----------------------------------------
-- line 280 ----------------------------------------
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	*reloc_addr = map->l_addr + reloc->r_addend;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    else
    .    .    .     .    .    .     .    .    .  # endif
    .    .    .     .    .    .     .    .    .  # if !defined RTLD_BOOTSTRAP
    .    .    .     .    .    .     .    .    .    /* l_addr + r_addend may be > 0xffffffff and R_X86_64_RELATIVE64
    .    .    .     .    .    .     .    .    .       relocation updates the whole 64-bit entry.  */
  402    1    1     0    0    0     0    0    0    if (__builtin_expect (r_type == R_X86_64_RELATIVE64, 0))
    .    .    .     .    .    .     .    .    .      *(Elf64_Addr *) reloc_addr = (Elf64_Addr) map->l_addr + reloc->r_addend;
    .    .    .     .    .    .     .    .    .    else
    .    .    .     .    .    .     .    .    .  # endif
  420    0    0     0    0    0     0    0    0    if (__builtin_expect (r_type == R_X86_64_NONE, 0))
    .    .    .     .    .    .     .    .    .      return;
    .    .    .     .    .    .     .    .    .    else
    .    .    .     .    .    .     .    .    .      {
    .    .    .     .    .    .     .    .    .  # ifndef RTLD_BOOTSTRAP
    .    .    .     .    .    .     .    .    .        const ElfW(Sym) *const refsym = sym;
    .    .    .     .    .    .     .    .    .  # endif
7,050   10   10 1,504  126  107 1,294    2    0        struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
    .    .    .     .    .    .     .    .    .        ElfW(Addr) value = (sym == NULL ? 0
  998    2    2   416    4    2     0    0    0  			  : (ElfW(Addr)) sym_map->l_addr + sym->st_value);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .        if (sym != NULL
  832    1    1   208    5    5     0    0    0  	  && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC,
    .    .    .     .    .    .     .    .    .  			       0)
   12    1    1     6    0    0     0    0    0  	  && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
   24    0    0     6    0    0     6    0    0  	  && __builtin_expect (!skip_ifunc, 1))
   24    0    0     6    0    0     6    0    0  	value = ((ElfW(Addr) (*) (void)) value) ();
    .    .    .     .    .    .     .    .    .  
1,462    0    0   210    5    4     0    0    0        switch (r_type)
    .    .    .     .    .    .     .    .    .  	{
    .    .    .     .    .    .     .    .    .  	case R_X86_64_GLOB_DAT:
    .    .    .     .    .    .     .    .    .  	case R_X86_64_JUMP_SLOT:
    .    .    .     .    .    .     .    .    .  	  *reloc_addr = value + reloc->r_addend;
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  # ifndef RESOLVE_CONFLICT_FIND_MAP
    .    .    .     .    .    .     .    .    .  	case R_X86_64_DTPMOD64:
-- line 318 ----------------------------------------
-- line 320 ----------------------------------------
    .    .    .     .    .    .     .    .    .  	  /* During startup the dynamic linker is always the module
    .    .    .     .    .    .     .    .    .  	     with index 1.
    .    .    .     .    .    .     .    .    .  	     XXX If this relocation is necessary move before RESOLVE
    .    .    .     .    .    .     .    .    .  	     call.  */
    .    .    .     .    .    .     .    .    .  	  *reloc_addr = 1;
    .    .    .     .    .    .     .    .    .  #  else
    .    .    .     .    .    .     .    .    .  	  /* Get the information from the link map returned by the
    .    .    .     .    .    .     .    .    .  	     resolve function.  */
    4    0    0     0    0    0     0    0    0  	  if (sym_map != NULL)
    6    1    1     2    0    0     2    0    0  	    *reloc_addr = sym_map->l_tls_modid;
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  	case R_X86_64_DTPOFF64:
    .    .    .     .    .    .     .    .    .  #  ifndef RTLD_BOOTSTRAP
    .    .    .     .    .    .     .    .    .  	  /* During relocation all TLS symbols are defined and used.
    .    .    .     .    .    .     .    .    .  	     Therefore the offset is already correct.  */
    3    0    0     1    0    0     0    0    0  	  if (sym != NULL)
    .    .    .     .    .    .     .    .    .  	    {
    2    0    0     2    0    0     0    0    0  	      value = sym->st_value + reloc->r_addend;
    .    .    .     .    .    .     .    .    .  #   ifdef __ILP32__
    .    .    .     .    .    .     .    .    .  	      /* This relocation type computes a signed offset that is
    .    .    .     .    .    .     .    .    .  		 usually negative.  The symbol and addend values are 32
    .    .    .     .    .    .     .    .    .  		 bits but the GOT entry is 64 bits wide and the whole
    .    .    .     .    .    .     .    .    .  		 64-bit entry is used as a signed quantity, so we need
    .    .    .     .    .    .     .    .    .  		 to sign-extend the computed value to 64 bits.  */
    .    .    .     .    .    .     .    .    .  	      *(Elf64_Sxword *) reloc_addr = (Elf64_Sxword) (Elf32_Sword) value;
    .    .    .     .    .    .     .    .    .  #   else
    2    0    0     0    0    0     1    1    1  	      *reloc_addr = value;
    .    .    .     .    .    .     .    .    .  #   endif
    .    .    .     .    .    .     .    .    .  	    }
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  	case R_X86_64_TLSDESC:
    .    .    .     .    .    .     .    .    .  	  {
    .    .    .     .    .    .     .    .    .  	    struct tlsdesc volatile *td =
    .    .    .     .    .    .     .    .    .  	      (struct tlsdesc volatile *)reloc_addr;
-- line 355 ----------------------------------------
-- line 382 ----------------------------------------
    .    .    .     .    .    .     .    .    .  		    td->entry = _dl_tlsdesc_return;
    .    .    .     .    .    .     .    .    .  		  }
    .    .    .     .    .    .     .    .    .  	      }
    .    .    .     .    .    .     .    .    .  	    break;
    .    .    .     .    .    .     .    .    .  	  }
    .    .    .     .    .    .     .    .    .  	case R_X86_64_TPOFF64:
    .    .    .     .    .    .     .    .    .  	  /* The offset is negative, forward from the thread pointer.  */
    .    .    .     .    .    .     .    .    .  #  ifndef RTLD_BOOTSTRAP
   42    1    1    14    0    0     0    0    0  	  if (sym != NULL)
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	    {
    .    .    .     .    .    .     .    .    .  #  ifndef RTLD_BOOTSTRAP
   70    0    0    14    1    0     0    0    0  	      CHECK_STATIC_TLS (map, sym_map);
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	      /* We know the offset of the object the symbol is contained in.
    .    .    .     .    .    .     .    .    .  		 It is a negative value which will be added to the
    .    .    .     .    .    .     .    .    .  		 thread pointer.  */
   79    2    2    37    3    3    14    8    8  	      value = (sym->st_value + reloc->r_addend
    .    .    .     .    .    .     .    .    .  		       - sym_map->l_tls_offset);
    .    .    .     .    .    .     .    .    .  #  ifdef __ILP32__
    .    .    .     .    .    .     .    .    .  	      /* The symbol and addend values are 32 bits but the GOT
    .    .    .     .    .    .     .    .    .  		 entry is 64 bits wide and the whole 64-bit entry is used
    .    .    .     .    .    .     .    .    .  		 as a signed quantity, so we need to sign-extend the
    .    .    .     .    .    .     .    .    .  		 computed value to 64 bits.  */
    .    .    .     .    .    .     .    .    .  	      *(Elf64_Sxword *) reloc_addr = (Elf64_Sxword) (Elf32_Sword) value;
    .    .    .     .    .    .     .    .    .  #  else
    9    0    0     0    0    0     9    1    1  	      *reloc_addr = value;
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	    }
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  # endif
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  # ifndef RTLD_BOOTSTRAP
    .    .    .     .    .    .     .    .    .  	case R_X86_64_64:
    .    .    .     .    .    .     .    .    .  	  /* value + r_addend may be > 0xffffffff and R_X86_64_64
    .    .    .     .    .    .     .    .    .  	     relocation updates the whole 64-bit entry.  */
  543    1    1   181   23   22   181   23   19  	  *(Elf64_Addr *) reloc_addr = (Elf64_Addr) value + reloc->r_addend;
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  	case R_X86_64_32:
    .    .    .     .    .    .     .    .    .  	  value += reloc->r_addend;
    .    .    .     .    .    .     .    .    .  	  *(unsigned int *) reloc_addr = value;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  	  const char *fmt;
   20    1    1     0    0    0    12    0    0  	  if (__builtin_expect (value > UINT_MAX, 0))
    .    .    .     .    .    .     .    .    .  	    {
    .    .    .     .    .    .     .    .    .  	      const char *strtab;
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  	      fmt = "\
    .    .    .     .    .    .     .    .    .  %s: Symbol `%s' causes overflow in R_X86_64_32 relocation\n";
    .    .    .     .    .    .     .    .    .  #  ifndef RESOLVE_CONFLICT_FIND_MAP
    .    .    .     .    .    .     .    .    .  	    print_err:
    .    .    .     .    .    .     .    .    .  #  endif
-- line 433 ----------------------------------------
-- line 446 ----------------------------------------
    .    .    .     .    .    .     .    .    .  	  if (__builtin_expect (value != (int) value, 0))
    .    .    .     .    .    .     .    .    .  	    {
    .    .    .     .    .    .     .    .    .  	      fmt = "\
    .    .    .     .    .    .     .    .    .  %s: Symbol `%s' causes overflow in R_X86_64_PC32 relocation\n";
    .    .    .     .    .    .     .    .    .  	      goto print_err;
    .    .    .     .    .    .     .    .    .  	    }
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  	case R_X86_64_COPY:
    9    1    1     3    0    0     0    0    0  	  if (sym == NULL)
    .    .    .     .    .    .     .    .    .  	    /* This can happen in trace mode if an object could not be
    .    .    .     .    .    .     .    .    .  	       found.  */
    .    .    .     .    .    .     .    .    .  	    break;
   18    0    0     9    0    0     3    0    0  	  memcpy (reloc_addr_arg, (void *) value,
    .    .    .     .    .    .     .    .    .  		  MIN (sym->st_size, refsym->st_size));
    9    0    0     6    0    0     0    0    0  	  if (__builtin_expect (sym->st_size > refsym->st_size, 0)
    3    1    1     0    0    0     0    0    0  	      || (__builtin_expect (sym->st_size < refsym->st_size, 0)
    .    .    .     .    .    .     .    .    .  		  && GLRO(dl_verbose)))
    .    .    .     .    .    .     .    .    .  	    {
    .    .    .     .    .    .     .    .    .  	      fmt = "\
    .    .    .     .    .    .     .    .    .  %s: Symbol `%s' has different size in shared object, consider re-linking\n";
    .    .    .     .    .    .     .    .    .  	      goto print_err;
    .    .    .     .    .    .     .    .    .  	    }
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  #  endif
    .    .    .     .    .    .     .    .    .  	case R_X86_64_IRELATIVE:
   14    0    0    14    0    0     0    0    0  	  value = map->l_addr + reloc->r_addend;
    7    0    0     0    0    0     7    0    0  	  value = ((ElfW(Addr) (*) (void)) value) ();
   14    0    0     0    0    0     7    0    0  	  *reloc_addr = value;
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  	default:
    .    .    .     .    .    .     .    .    .  	  _dl_reloc_bad_type (map, r_type, 0);
    .    .    .     .    .    .     .    .    .  	  break;
    .    .    .     .    .    .     .    .    .  # endif
    .    .    .     .    .    .     .    .    .  	}
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  }
-- line 481 ----------------------------------------
-- line 490 ----------------------------------------
    .    .    .     .    .    .     .    .    .    /* l_addr + r_addend may be > 0xffffffff and R_X86_64_RELATIVE64
    .    .    .     .    .    .     .    .    .       relocation updates the whole 64-bit entry.  */
    .    .    .     .    .    .     .    .    .    if (__builtin_expect (ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE64, 0))
    .    .    .     .    .    .     .    .    .      *(Elf64_Addr *) reloc_addr = (Elf64_Addr) l_addr + reloc->r_addend;
    .    .    .     .    .    .     .    .    .    else
    .    .    .     .    .    .     .    .    .  #endif
    .    .    .     .    .    .     .    .    .      {
    .    .    .     .    .    .     .    .    .        assert (ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE);
3,814    0    0 2,536  478  477    10    2    2        *reloc_addr = l_addr + reloc->r_addend;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .  }
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .  auto inline void
    .    .    .     .    .    .     .    .    .  __attribute ((always_inline))
    .    .    .     .    .    .     .    .    .  elf_machine_lazy_rel (struct link_map *map,
    .    .    .     .    .    .     .    .    .  		      ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
    .    .    .     .    .    .     .    .    .  		      int skip_ifunc)
    .    .    .     .    .    .     .    .    .  {
   58    0    0    29    0    0     0    0    0    ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
    .    .    .     .    .    .     .    .    .    const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);
    .    .    .     .    .    .     .    .    .  
    .    .    .     .    .    .     .    .    .    /* Check for unexpected PLT reloc type.  */
   58    0    0     0    0    0     0    0    0    if (__builtin_expect (r_type == R_X86_64_JUMP_SLOT, 1))
    .    .    .     .    .    .     .    .    .      {
   87    0    0    29    0    0     0    0    0        if (__builtin_expect (map->l_mach.plt, 0) == 0)
   29    0    0    29    3    3     0    0    0  	*reloc_addr += l_addr;
    .    .    .     .    .    .     .    .    .        else
    .    .    .     .    .    .     .    .    .  	*reloc_addr =
    .    .    .     .    .    .     .    .    .  	  map->l_mach.plt
    .    .    .     .    .    .     .    .    .  	  + (((ElfW(Addr)) reloc_addr) - map->l_mach.gotplt) * 2;
    .    .    .     .    .    .     .    .    .      }
    .    .    .     .    .    .     .    .    .    else if (__builtin_expect (r_type == R_X86_64_TLSDESC, 1))
    .    .    .     .    .    .     .    .    .      {
    .    .    .     .    .    .     .    .    .        struct tlsdesc volatile * __attribute__((__unused__)) td =
-- line 523 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-memset.S
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr D1mr DLmr Dw    D1mw DLmw 

-- line 22 ----------------------------------------
    .    .    .  .    .    .     .    .    .  
    .    .    .  .    .    .     .    .    .  
    .    .    .  .    .    .     .    .    .  	.text
    .    .    .  .    .    .     .    .    .  /* void *memset (void *dest, char c, size_t count)
    .    .    .  .    .    .     .    .    .     dest	 => %rdi
    .    .    .  .    .    .     .    .    .     c	 => %rsi
    .    .    .  .    .    .     .    .    .     count => %rdx  */
    .    .    .  .    .    .     .    .    .  ENTRY (memset)
   20    2    1  0    0    0     0    0    0  	mov	%rdx, %rcx
   20    0    0  0    0    0     0    0    0  	movzbl	%sil, %eax
   20    0    0  0    0    0     0    0    0  	mov	%rdi, %rdx
6,616    0    0  0    0    0 6,596  102  102  	rep	stosb
   20    0    0  0    0    0     0    0    0  	mov	%rdx, %rax
   20    0    0 20    0    0     0    0    0  	ret
    .    .    .  .    .    .     .    .    .  END (memset)
    .    .    .  .    .    .     .    .    .  libc_hidden_builtin_def (memset)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/do-rel.h
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr  D1mr DLmr Dw    D1mw DLmw 

-- line 39 ----------------------------------------
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  auto inline void __attribute__ ((always_inline))
    .    .    .   .    .    .     .    .    .  elf_dynamic_do_Rel (struct link_map *map,
    .    .    .   .    .    .     .    .    .  		    ElfW(Addr) reladdr, ElfW(Addr) relsize,
    .    .    .   .    .    .     .    .    .  		    __typeof (((ElfW(Dyn) *) 0)->d_un.d_val) nrelative,
    .    .    .   .    .    .     .    .    .  		    int lazy, int skip_ifunc)
    .    .    .   .    .    .     .    .    .  {
    .    .    .   .    .    .     .    .    .    const ElfW(Rel) *r = (const void *) reladdr;
   20    0    0  10    0    0     0    0    0    const ElfW(Rel) *end = (const void *) (reladdr + relsize);
   10    0    0  10    0    0     0    0    0    ElfW(Addr) l_addr = map->l_addr;
    .    .    .   .    .    .     .    .    .  # if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP
    4    0    0   0    0    0     0    0    0    const ElfW(Rel) *r2 = NULL;
    4    0    0   0    0    0     4    1    0    const ElfW(Rel) *end2 = NULL;
    .    .    .   .    .    .     .    .    .  # endif
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if (!defined DO_RELA || !defined ELF_MACHINE_PLT_REL) && !defined RTLD_BOOTSTRAP
    .    .    .   .    .    .     .    .    .    /* We never bind lazily during ld.so bootstrap.  Unfortunately gcc is
    .    .    .   .    .    .     .    .    .       not clever enough to see through all the function calls to realize
    .    .    .   .    .    .     .    .    .       that.  */
   30    0    0  10    2    0     0    0    0    if (lazy)
    .    .    .   .    .    .     .    .    .      {
    .    .    .   .    .    .     .    .    .        /* Doing lazy PLT relocations; they need very little info.  */
   95    0    0   0    0    0     0    0    0        for (; r < end; ++r)
    .    .    .   .    .    .     .    .    .  # ifdef ELF_MACHINE_IRELATIVE
   87    1    1  29   11   11     0    0    0  	if (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  	  {
    .    .    .   .    .    .     .    .    .  	    if (r2 == NULL)
    .    .    .   .    .    .     .    .    .  	      r2 = r;
    .    .    .   .    .    .     .    .    .  	    end2 = r;
    .    .    .   .    .    .     .    .    .  	  }
    .    .    .   .    .    .     .    .    .  	else
    .    .    .   .    .    .     .    .    .  # endif
    .    .    .   .    .    .     .    .    .  	  elf_machine_lazy_rel (map, l_addr, r, skip_ifunc);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  # ifdef ELF_MACHINE_IRELATIVE
    4    1    1   0    0    0     0    0    0        if (r2 != NULL)
   10    1    1  10    0    0     0    0    0  	for (; r2 <= end2; ++r2)
    .    .    .   .    .    .     .    .    .  	  if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  	    elf_machine_lazy_rel (map, l_addr, r2, skip_ifunc);
    .    .    .   .    .    .     .    .    .  # endif
    .    .    .   .    .    .     .    .    .      }
    .    .    .   .    .    .     .    .    .    else
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .      {
   17    0    0   9    0    0     8    0    0        const ElfW(Sym) *const symtab =
    8    1    1   8    0    0     0    0    0  	(const void *) D_PTR (map, l_info[DT_SYMTAB]);
    .    .    .   .    .    .     .    .    .        const ElfW(Rel) *relative = r;
   16    0    0   0    0    0     0    0    0        r += nrelative;
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #ifndef RTLD_BOOTSTRAP
    .    .    .   .    .    .     .    .    .        /* This is defined in rtld.c, but nowhere in the static libc.a; make
    .    .    .   .    .    .     .    .    .  	 the reference weak so static programs can still link.  This
    .    .    .   .    .    .     .    .    .  	 declaration cannot be done when compiling rtld.c (i.e. #ifdef
    .    .    .   .    .    .     .    .    .  	 RTLD_BOOTSTRAP) because rtld.c contains the common defn for
    .    .    .   .    .    .     .    .    .  	 _dl_rtld_map, which is incompatible with a weak decl in the same
    .    .    .   .    .    .     .    .    .  	 file.  */
    .    .    .   .    .    .     .    .    .  # ifndef SHARED
    .    .    .   .    .    .     .    .    .        weak_extern (GL(dl_rtld_map));
    .    .    .   .    .    .     .    .    .  # endif
   24    1    1   0    0    0     0    0    0        if (map != &GL(dl_rtld_map)) /* Already done in rtld itself.  */
    .    .    .   .    .    .     .    .    .  # if !defined DO_RELA || defined ELF_MACHINE_REL_RELATIVE
    .    .    .   .    .    .     .    .    .  	/* Rela platforms get the offset from r_addend and this must
    .    .    .   .    .    .     .    .    .  	   be copied in the relocation address.  Therefore we can skip
    .    .    .   .    .    .     .    .    .  	   the relative relocations only if this is for rel
    .    .    .   .    .    .     .    .    .  	   relocations or rela relocations if they are computed as
    .    .    .   .    .    .     .    .    .  	   memory_loc += l_addr...  */
    .    .    .   .    .    .     .    .    .  	if (l_addr != 0)
    .    .    .   .    .    .     .    .    .  # else
    .    .    .   .    .    .     .    .    .  	/* ...or we know the object has been prelinked.  */
   15    1    1   1    1    1     0    0    0  	if (l_addr != 0 || ! map->l_info[VALIDX(DT_GNU_PRELINKED)])
    .    .    .   .    .    .     .    .    .  # endif
    .    .    .   .    .    .     .    .    .  #endif
5,080    0    0   0    0    0 1,258  239  236  	  for (; relative < r; ++relative)
    .    .    .   .    .    .     .    .    .  	    DO_ELF_MACHINE_REL_RELATIVE (map, l_addr, relative);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #ifdef RTLD_BOOTSTRAP
    .    .    .   .    .    .     .    .    .        /* The dynamic linker always uses versioning.  */
    .    .    .   .    .    .     .    .    .        assert (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL);
    .    .    .   .    .    .     .    .    .  #else
   24    1    1   8    6    0     0    0    0        if (map->l_info[VERSYMIDX (DT_VERSYM)])
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .  	{
   14    0    0   7    3    0     7    1    0  	  const ElfW(Half) *const version =
    .    .    .   .    .    .     .    .    .  	    (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
    .    .    .   .    .    .     .    .    .  
  663    1    1 210    0    0     0    0    0  	  for (; r < end; ++r)
    .    .    .   .    .    .     .    .    .  	    {
    .    .    .   .    .    .     .    .    .  #if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP
  808    0    0 202   54   50     0    0    0  	      if (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  		{
   29    1    1   7    0    0     8    0    0  		  if (r2 == NULL)
    .    .    .   .    .    .     .    .    .  		    r2 = r;
    .    .    .   .    .    .     .    .    .  		  end2 = r;
    .    .    .   .    .    .     .    .    .  		  continue;
    .    .    .   .    .    .     .    .    .  		}
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .  
  585    0    0 390   49   41     0    0    0  	      ElfW(Half) ndx = version[ELFW(R_SYM) (r->r_info)] & 0x7fff;
1,350    2    2 204    2    2   195    1    0  	      elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)],
  370    1    1 195    1    0     0    0    0  			       &map->l_versions[ndx],
  408    0    0 399    0    0     0    0    0  			       (void *) (l_addr + r->r_offset), skip_ifunc);
    .    .    .   .    .    .     .    .    .  	    }
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  #if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP
    8    0    0   0    0    0     0    0    0  	  if (r2 != NULL)
   26    0    0   1    0    0     0    0    0  	    for (; r2 <= end2; ++r2)
   21    1    1   7    0    0     0    0    0  	      if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  		{
    .    .    .   .    .    .     .    .    .  		  ElfW(Half) ndx
   21    0    0  14    0    0     0    0    0  		    = version[ELFW(R_SYM) (r2->r_info)] & 0x7fff;
   21    0    0   7    0    0     7    0    0  		  elf_machine_rel (map, r2,
    7    0    0   0    0    0     0    0    0  				   &symtab[ELFW(R_SYM) (r2->r_info)],
    7    0    0   7    0    0     0    0    0  				   &map->l_versions[ndx],
   14    0    0   7    0    0     0    0    0  				   (void *) (l_addr + r2->r_offset),
    .    .    .   .    .    .     .    .    .  				   skip_ifunc);
    .    .    .   .    .    .     .    .    .  		}
    .    .    .   .    .    .     .    .    .  #endif
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .  #ifndef RTLD_BOOTSTRAP
    .    .    .   .    .    .     .    .    .        else
    .    .    .   .    .    .     .    .    .  	{
   26    2    2   6    0    0     4    0    0  	  for (; r < end; ++r)
    .    .    .   .    .    .     .    .    .  # ifdef ELF_MACHINE_IRELATIVE
   24    1    1   6    2    2     0    0    0  	    if (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  	      {
    .    .    .   .    .    .     .    .    .  		if (r2 == NULL)
    .    .    .   .    .    .     .    .    .  		  r2 = r;
    .    .    .   .    .    .     .    .    .  		end2 = r;
    .    .    .   .    .    .     .    .    .  	      }
    .    .    .   .    .    .     .    .    .  	    else
    .    .    .   .    .    .     .    .    .  # endif
   30    0    0   6    0    0     6    0    0  	      elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)], NULL,
   12    0    0  12    0    0     0    0    0  			       (void *) (l_addr + r->r_offset), skip_ifunc);
    .    .    .   .    .    .     .    .    .  
    .    .    .   .    .    .     .    .    .  # ifdef ELF_MACHINE_IRELATIVE
    5    0    0   2    0    0     0    0    0  	  if (r2 != NULL)
    .    .    .   .    .    .     .    .    .  	    for (; r2 <= end2; ++r2)
    .    .    .   .    .    .     .    .    .  	      if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)
    .    .    .   .    .    .     .    .    .  		elf_machine_rel (map, r2, &symtab[ELFW(R_SYM) (r2->r_info)],
    .    .    .   .    .    .     .    .    .  				 NULL, (void *) (l_addr + r2->r_offset),
    .    .    .   .    .    .     .    .    .  				 skip_ifunc);
    .    .    .   .    .    .     .    .    .  # endif
    .    .    .   .    .    .     .    .    .  	}
    .    .    .   .    .    .     .    .    .  #endif
-- line 182 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdlib/random_r.c
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 154 ----------------------------------------
    .    .    .   .    .    .   .    .    .     Otherwise, initializes state[] based on the given "seed" via a linear
    .    .    .   .    .    .   .    .    .     congruential generator.  Then, the pointers are set to known locations
    .    .    .   .    .    .   .    .    .     that are exactly rand_sep places apart.  Lastly, it cycles the state
    .    .    .   .    .    .   .    .    .     information a given number of times to get rid of any initial dependencies
    .    .    .   .    .    .   .    .    .     introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
    .    .    .   .    .    .   .    .    .     for default usage relies on values produced by this routine.  */
    .    .    .   .    .    .   .    .    .  int
    .    .    .   .    .    .   .    .    .  __srandom_r (unsigned int seed, struct random_data *buf)
    5    1    1   0    0    0   3    0    0  {
    .    .    .   .    .    .   .    .    .    int type;
    .    .    .   .    .    .   .    .    .    int32_t *state;
    .    .    .   .    .    .   .    .    .    long int i;
    .    .    .   .    .    .   .    .    .    int32_t word;
    .    .    .   .    .    .   .    .    .    int32_t *dst;
    .    .    .   .    .    .   .    .    .    int kc;
    .    .    .   .    .    .   .    .    .  
    2    1    1   0    0    0   0    0    0    if (buf == NULL)
    .    .    .   .    .    .   .    .    .      goto fail;
    1    0    0   1    0    0   0    0    0    type = buf->rand_type;
    2    0    0   0    0    0   0    0    0    if ((unsigned int) type >= MAX_TYPES)
    .    .    .   .    .    .   .    .    .      goto fail;
    .    .    .   .    .    .   .    .    .  
    1    0    0   1    0    0   0    0    0    state = buf->state;
    .    .    .   .    .    .   .    .    .    /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */
    3    0    0   0    0    0   0    0    0    if (seed == 0)
    .    .    .   .    .    .   .    .    .      seed = 1;
    1    0    0   0    0    0   1    1    1    state[0] = seed;
    2    0    0   0    0    0   0    0    0    if (type == TYPE_0)
    .    .    .   .    .    .   .    .    .      goto done;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .    dst = state;
    .    .    .   .    .    .   .    .    .    word = seed;
    1    0    0   1    0    0   0    0    0    kc = buf->rand_deg;
   95    2    2   0    0    0   0    0    0    for (i = 1; i < kc; ++i)
    .    .    .   .    .    .   .    .    .      {
    .    .    .   .    .    .   .    .    .        /* This does:
    .    .    .   .    .    .   .    .    .  	   state[i] = (16807 * state[i - 1]) % 2147483647;
    .    .    .   .    .    .   .    .    .  	 but avoids overflowing 31 bits.  */
  211    0    0   0    0    0   0    0    0        long int hi = word / 127773;
   60    0    0   0    0    0   0    0    0        long int lo = word % 127773;
   90    0    0   0    0    0   0    0    0        word = 16807 * lo - 2836 * hi;
    .    .    .   .    .    .   .    .    .        if (word < 0)
   90    0    0   0    0    0   0    0    0  	word += 2147483647;
   30    0    0   0    0    0  30    1    1        *++dst = word;
    .    .    .   .    .    .   .    .    .      }
    .    .    .   .    .    .   .    .    .  
    3    0    0   1    1    0   1    0    0    buf->fptr = &state[buf->rand_sep];
    2    0    0   0    0    0   1    0    0    buf->rptr = &state[0];
    1    0    0   0    0    0   0    0    0    kc *= 10;
  934    1    1   0    0    0   0    0    0    while (--kc >= 0)
    .    .    .   .    .    .   .    .    .      {
    .    .    .   .    .    .   .    .    .        int32_t discard;
  930    0    0   0    0    0 310    0    0        (void) __random_r (buf, &discard);
    .    .    .   .    .    .   .    .    .      }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   done:
    1    0    0   0    0    0   0    0    0    return 0;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   fail:
    .    .    .   .    .    .   .    .    .    return -1;
    5    0    0   4    0    0   0    0    0  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  weak_alias (__srandom_r, srandom_r)
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  /* Initialize the state information in the given array of N bytes for
    .    .    .   .    .    .   .    .    .     future random number generation.  Based on the number of bytes we
    .    .    .   .    .    .   .    .    .     are given, and the break values for the different R.N.G.'s, we choose
    .    .    .   .    .    .   .    .    .     the best (largest) one we can and set things up for it.  srandom is
    .    .    .   .    .    .   .    .    .     then called to initialize the state information.  Note that on return
-- line 222 ----------------------------------------
-- line 349 ----------------------------------------
    .    .    .   .    .    .   .    .    .     rear pointers can't wrap on the same call by not testing the rear
    .    .    .   .    .    .   .    .    .     pointer if the front one has wrapped.  Returns a 31-bit random number.  */
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  int
    .    .    .   .    .    .   .    .    .  __random_r (struct random_data *buf, int32_t *result)
    .    .    .   .    .    .   .    .    .  {
    .    .    .   .    .    .   .    .    .    int32_t *state;
    .    .    .   .    .    .   .    .    .  
1,264    1    1   0    0    0   0    0    0    if (buf == NULL || result == NULL)
    .    .    .   .    .    .   .    .    .      goto fail;
    .    .    .   .    .    .   .    .    .  
  326    0    0 316    0    0   0    0    0    state = buf->state;
    .    .    .   .    .    .   .    .    .  
  948    0    0 316    1    0   0    0    0    if (buf->rand_type == TYPE_0)
    .    .    .   .    .    .   .    .    .      {
    .    .    .   .    .    .   .    .    .        int32_t val = state[0];
    .    .    .   .    .    .   .    .    .        val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;
    .    .    .   .    .    .   .    .    .        state[0] = val;
    .    .    .   .    .    .   .    .    .        *result = val;
    .    .    .   .    .    .   .    .    .      }
    .    .    .   .    .    .   .    .    .    else
    .    .    .   .    .    .   .    .    .      {
  316    0    0 316    0    0   0    0    0        int32_t *fptr = buf->fptr;
  316    0    0 316    0    0   0    0    0        int32_t *rptr = buf->rptr;
  316    0    0 316    1    0   0    0    0        int32_t *end_ptr = buf->end_ptr;
    .    .    .   .    .    .   .    .    .        int32_t val;
    .    .    .   .    .    .   .    .    .  
  948    0    0 632    1    0 316    0    0        val = *fptr += *rptr;
    .    .    .   .    .    .   .    .    .        /* Chucking least random bit.  */
  632    1    1   0    0    0 316    0    0        *result = (val >> 1) & 0x7fffffff;
  316    0    0   0    0    0   0    0    0        ++fptr;
  632    0    0   0    0    0   0    0    0        if (fptr >= end_ptr)
    .    .    .   .    .    .   .    .    .  	{
    .    .    .   .    .    .   .    .    .  	  fptr = state;
   10    0    0   0    0    0   0    0    0  	  ++rptr;
    .    .    .   .    .    .   .    .    .  	}
    .    .    .   .    .    .   .    .    .        else
    .    .    .   .    .    .   .    .    .  	{
  306    0    0   0    0    0   0    0    0  	  ++rptr;
  612    0    0   0    0    0   0    0    0  	  if (rptr >= end_ptr)
    .    .    .   .    .    .   .    .    .  	    rptr = state;
    .    .    .   .    .    .   .    .    .  	}
  316    0    0   0    0    0 316    0    0        buf->fptr = fptr;
  632    0    0 316    0    0 316    0    0        buf->rptr = rptr;
    .    .    .   .    .    .   .    .    .      }
  316    0    0   0    0    0   0    0    0    return 0;
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .   fail:
    .    .    .   .    .    .   .    .    .    __set_errno (EINVAL);
    .    .    .   .    .    .   .    .    .    return -1;
    .    .    .   .    .    .   .    .    .  }
    .    .    .   .    .    .   .    .    .  
    .    .    .   .    .    .   .    .    .  weak_alias (__random_r, random_r)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_cond_destroy.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 19 ----------------------------------------
  .    .    .   .    .    .  .    .    .  #include <errno.h>
  .    .    .   .    .    .  .    .    .  #include <shlib-compat.h>
  .    .    .   .    .    .  .    .    .  #include "pthreadP.h"
  .    .    .   .    .    .  .    .    .  #include <stap-probe.h>
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  int
  .    .    .   .    .    .  .    .    .  __pthread_cond_destroy (pthread_cond_t *cond)
112    0    0   0    0    0 96    0    0  {
  .    .    .   .    .    .  .    .    .    int pshared = (cond->__data.__mutex == (void *) ~0l)
 96    0    0  16    8    0  0    0    0  		? LLL_SHARED : LLL_PRIVATE;
  .    .    .   .    .    .  .    .    .  
 16    0    0   0    0    0  0    0    0    LIBC_PROBE (cond_destroy, 1, cond);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Make sure we are alone.  */
 64    1    1  16    0    0  0    0    0    lll_lock (cond->__data.__lock, pshared);
  .    .    .   .    .    .  .    .    .  
 48    0    0  32    0    0  0    0    0    if (cond->__data.__total_seq > cond->__data.__wakeup_seq)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* If there are still some waiters which have not been
  .    .    .   .    .    .  .    .    .  	 woken up, this is an application bug.  */
  .    .    .   .    .    .  .    .    .        lll_unlock (cond->__data.__lock, pshared);
  .    .    .   .    .    .  .    .    .        return EBUSY;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Tell pthread_cond_*wait that this condvar is being destroyed.  */
 16    0    0   0    0    0 16    0    0    cond->__data.__total_seq = -1ULL;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* If there are waiters which have been already signalled or
  .    .    .   .    .    .  .    .    .       broadcasted, but still are using the pthread_cond_t structure,
  .    .    .   .    .    .  .    .    .       pthread_cond_destroy needs to wait for them.  */
 16    0    0  16    0    0  0    0    0    unsigned int nwaiters = cond->__data.__nwaiters;
  .    .    .   .    .    .  .    .    .  
 32    1    1   0    0    0  0    0    0    if (nwaiters >= (1 << COND_NWAITERS_SHIFT))
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Wake everybody on the associated mutex in case there are
  .    .    .   .    .    .  .    .    .  	 threads that have been requeued to it.
  .    .    .   .    .    .  .    .    .  	 Without this, pthread_cond_destroy could block potentially
  .    .    .   .    .    .  .    .    .  	 for a long time or forever, as it would depend on other
  .    .    .   .    .    .  .    .    .  	 thread's using the mutex.
  .    .    .   .    .    .  .    .    .  	 When all threads waiting on the mutex are woken up, pthread_cond_wait
  .    .    .   .    .    .  .    .    .  	 only waits for threads to acquire and release the internal
-- line 60 ----------------------------------------
-- line 75 ----------------------------------------
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  lll_lock (cond->__data.__lock, pshared);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  nwaiters = cond->__data.__nwaiters;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .        while (nwaiters >= (1 << COND_NWAITERS_SHIFT));
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
 16    0    0   0    0    0  0    0    0    return 0;
112    1    1 112    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  versioned_symbol (libpthread, __pthread_cond_destroy,
  .    .    .   .    .    .  .    .    .  		  pthread_cond_destroy, GLIBC_2_3_2);

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/../nptl/pthread_mutex_lock.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 54 ----------------------------------------
  .    .    .   .    .    .   .    .    .  #define FORCE_ELISION(m, s)
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int __pthread_mutex_lock_full (pthread_mutex_t *mutex)
  .    .    .   .    .    .   .    .    .       __attribute_noinline__;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  __pthread_mutex_lock (pthread_mutex_t *mutex)
154    0    0   0    0    0   0    0    0  {
  .    .    .   .    .    .   .    .    .    assert (sizeof (mutex->__size) >= sizeof (mutex->__data));
  .    .    .   .    .    .   .    .    .  
462    2    2 154    3    3   0    0    0    unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);
  .    .    .   .    .    .   .    .    .  
154    0    0   0    0    0   0    0    0    LIBC_PROBE (mutex_entry, 1, mutex);
  .    .    .   .    .    .   .    .    .  
462    0    0   0    0    0   0    0    0    if (__builtin_expect (type & ~(PTHREAD_MUTEX_KIND_MASK_NP
  .    .    .   .    .    .   .    .    .  				 | PTHREAD_MUTEX_ELISION_FLAGS_NP), 0))
  .    .    .   .    .    .   .    .    .      return __pthread_mutex_lock_full (mutex);
  .    .    .   .    .    .   .    .    .  
308    0    0   0    0    0   0    0    0    if (__builtin_expect (type == PTHREAD_MUTEX_TIMED_NP, 1))
  .    .    .   .    .    .   .    .    .      {
435    0    0 145    1    0   0    0    0        FORCE_ELISION (mutex, goto elision);
  .    .    .   .    .    .   .    .    .      simple:
  .    .    .   .    .    .   .    .    .        /* Normal mutex.  */
760    1    1 152    0    0   0    0    0        LLL_MUTEX_LOCK (mutex);
  .    .    .   .    .    .   .    .    .        assert (mutex->__data.__owner == 0);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #ifdef HAVE_ELISION
  4    1    1   0    0    0   0    0    0    else if (__builtin_expect (type == PTHREAD_MUTEX_TIMED_ELISION_NP, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .    elision: __attribute__((unused))
  .    .    .   .    .    .   .    .    .        /* This case can never happen on a system without elision,
  .    .    .   .    .    .   .    .    .           as the mutex type initialization functions will not
  .    .    .   .    .    .   .    .    .  	 allow to set the elision flags.  */
  .    .    .   .    .    .   .    .    .        /* Don't record owner or users for elision case.  This is a
  .    .    .   .    .    .   .    .    .           tail call.  */
  .    .    .   .    .    .   .    .    .        return LLL_MUTEX_LOCK_ELISION (mutex);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  8    0    0   0    0    0   0    0    0    else if (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)
  .    .    .   .    .    .   .    .    .  			     == PTHREAD_MUTEX_RECURSIVE_NP, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Recursive mutex.  */
  2    0    0   2    0    0   0    0    0        pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Check whether we already hold the mutex.  */
  4    0    0   2    0    0   0    0    0        if (mutex->__data.__owner == id)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* Just bump the counter.  */
  .    .    .   .    .    .   .    .    .  	  if (__builtin_expect (mutex->__data.__count + 1 == 0, 0))
  .    .    .   .    .    .   .    .    .  	    /* Overflow of the counter.  */
  .    .    .   .    .    .   .    .    .  	    return EAGAIN;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  ++mutex->__data.__count;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  return 0;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* We have to get the mutex.  */
  8    0    0   2    0    0   0    0    0        LLL_MUTEX_LOCK (mutex);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        assert (mutex->__data.__owner == 0);
  4    0    0   0    0    0   2    0    0        mutex->__data.__count = 1;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else if (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)
  .    .    .   .    .    .   .    .    .  			  == PTHREAD_MUTEX_ADAPTIVE_NP, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (! __is_smp)
  .    .    .   .    .    .   .    .    .  	goto simple;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        if (LLL_MUTEX_TRYLOCK (mutex) != 0)
-- line 124 ----------------------------------------
-- line 149 ----------------------------------------
  .    .    .   .    .    .   .    .    .        pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
  .    .    .   .    .    .   .    .    .        assert (PTHREAD_MUTEX_TYPE (mutex) == PTHREAD_MUTEX_ERRORCHECK_NP);
  .    .    .   .    .    .   .    .    .        /* Check whether we already hold the mutex.  */
  .    .    .   .    .    .   .    .    .        if (__builtin_expect (mutex->__data.__owner == id, 0))
  .    .    .   .    .    .   .    .    .  	return EDEADLK;
  .    .    .   .    .    .   .    .    .        goto simple;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
154    0    0 154    6    0   0    0    0    pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Record the ownership.  */
154    0    0   0    0    0 154    0    0    mutex->__data.__owner = id;
  .    .    .   .    .    .   .    .    .  #ifndef NO_INCR
147    0    0 147    0    0   0    0    0    ++mutex->__data.__nusers;
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
154    0    0   0    0    0   0    0    0    LIBC_PROBE (mutex_acquired, 1, mutex);
  .    .    .   .    .    .   .    .    .  
308    0    0 154    0    0   0    0    0    return 0;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  __pthread_mutex_lock_full (pthread_mutex_t *mutex)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    int oldval;
  .    .    .   .    .    .   .    .    .    pid_t id = THREAD_GETMEM (THREAD_SELF, tid);
  .    .    .   .    .    .   .    .    .  
-- line 175 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-deps.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 52 ----------------------------------------
  .    .    .  .    .    .  .    .    .      const char *name;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* The return value of openaux.  */
  .    .    .  .    .    .  .    .    .      struct link_map *aux;
  .    .    .  .    .    .  .    .    .    };
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  openaux (void *a)
 10    1    1  0    0    0  5    0    0  {
  .    .    .  .    .    .  .    .    .    struct openaux_args *args = (struct openaux_args *) a;
  .    .    .  .    .    .  .    .    .  
 50    1    1 20    0    0 10    0    0    args->aux = _dl_map_object (args->map, args->name,
 10    0    0  5    0    0  0    0    0  			      (args->map->l_type == lt_executable
  .    .    .  .    .    .  .    .    .  			       ? lt_library : args->map->l_type),
  .    .    .  .    .    .  .    .    .  			      args->trace_mode, args->open_mode,
  5    0    0  5    0    0  0    0    0  			      args->map->l_ns);
 10    0    0 10    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static ptrdiff_t
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_build_local_scope (struct link_map **list, struct link_map *map)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    struct link_map **p = list;
  .    .    .  .    .    .  .    .    .    struct link_map **q;
  .    .    .  .    .    .  .    .    .  
-- line 76 ----------------------------------------
-- line 139 ----------------------------------------
  .    .    .  .    .    .  .    .    .      __result; })
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  void
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_map_object_deps (struct link_map *map,
  .    .    .  .    .    .  .    .    .  		     struct link_map **preloads, unsigned int npreloads,
  .    .    .  .    .    .  .    .    .  		     int trace_mode, int open_mode)
 11    1    1  0    0    0  9    0    0  {
 21    3    3  1    0    0  1    0    0    struct list *known = __alloca (sizeof *known * (1 + npreloads + 1));
  .    .    .  .    .    .  .    .    .    struct list *runp, *tail;
  .    .    .  .    .    .  .    .    .    unsigned int nlist, i;
  .    .    .  .    .    .  .    .    .    /* Object name.  */
  .    .    .  .    .    .  .    .    .    const char *name;
  .    .    .  .    .    .  .    .    .    int errno_saved;
  .    .    .  .    .    .  .    .    .    int errno_reason;
  .    .    .  .    .    .  .    .    .    const char *errstring;
  .    .    .  .    .    .  .    .    .    const char *objname;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    auto inline void preload (struct link_map *map);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    inline void preload (struct link_map *map)
  .    .    .  .    .    .  .    .    .      {
  6    0    0  0    0    0  2    0    0        known[nlist].done = 0;
  3    0    0  1    0    0  2    0    0        known[nlist].map = map;
 11    2    2  0    0    0  4    0    0        known[nlist].next = &known[nlist + 1];
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  0    0    0        ++nlist;
  .    .    .  .    .    .  .    .    .        /* We use `l_reserved' as a mark bit to detect objects we have
  .    .    .  .    .    .  .    .    .  	 already put in the search list and avoid adding duplicate
  .    .    .  .    .    .  .    .    .  	 elements later in the list.  */
  8    0    0  2    0    0  2    0    0        map->l_reserved = 1;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* No loaded object so far.  */
  .    .    .  .    .    .  .    .    .    nlist = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* First load MAP itself.  */
  .    .    .  .    .    .  .    .    .    preload (map);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Add the preloaded items after MAP but before any of its dependencies.  */
  8    0    0  1    0    0  0    0    0    for (i = 0; i < npreloads; ++i)
  1    0    0  1    0    0  0    0    0      preload (preloads[i]);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Terminate the lists.  */
  3    0    0  0    0    0  2    0    0    known[nlist - 1].next = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Pointer to last unique object.  */
  .    .    .  .    .    .  .    .    .    tail = &known[nlist - 1];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* No alloca'd space yet.  */
  1    0    0  0    0    0  1    0    0    struct link_map **needed_space = NULL;
  1    0    0  0    0    0  1    0    0    size_t needed_space_bytes = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Process each element of the search list, loading each of its
  .    .    .  .    .    .  .    .    .       auxiliary objects and immediate dependencies.  Auxiliary objects
  .    .    .  .    .    .  .    .    .       will be added in the list before the object itself and
  .    .    .  .    .    .  .    .    .       dependencies will be appended to the list as we step through it.
  .    .    .  .    .    .  .    .    .       This produces a flat, ordered list that represents a
  .    .    .  .    .    .  .    .    .       breadth-first search of the dependency tree.
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .       The whole process is complicated by the fact that we better
  .    .    .  .    .    .  .    .    .       should use alloca for the temporary list elements.  But using
  .    .    .  .    .    .  .    .    .       alloca means we cannot use recursive function calls.  */
  2    0    0  1    0    0  1    0    0    errno_saved = errno;
  1    0    0  0    0    0  0    0    0    errno_reason = 0;
  1    0    0  0    0    0  1    0    0    errstring = NULL;
  2    1    1  0    0    0  2    0    0    errno = 0;
  .    .    .  .    .    .  .    .    .    name = NULL;
  .    .    .  .    .    .  .    .    .    for (runp = known; runp; )
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        struct link_map *l = runp->map;
  5    0    0  0    0    0  0    0    0        struct link_map **needed = NULL;
  7    0    0  0    0    0  0    0    0        unsigned int nneeded = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Unless otherwise stated, this object is handled.  */
  5    0    0  0    0    0  5    0    0        runp->done = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Allocate a temporary record to contain the references to the
  .    .    .  .    .    .  .    .    .  	 dependencies of this object.  */
 25    1    1 15    1    1  0    0    0        if (l->l_searchlist.r_list == NULL && l->l_initfini == NULL
 22    0    0  9    0    0  0    0    0  	  && l != map && l->l_ldnum > 0)
  .    .    .  .    .    .  .    .    .  	{
  3    0    0  0    0    0  0    0    0  	  size_t new_size = l->l_ldnum * sizeof (struct link_map *);
  .    .    .  .    .    .  .    .    .  
  9    1    1  6    0    0  0    0    0  	  if (new_size > needed_space_bytes)
  .    .    .  .    .    .  .    .    .  	    needed_space
 48    2    2  4    0    0  4    0    0  	      = extend_alloca (needed_space, needed_space_bytes, new_size);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  needed = needed_space;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
 23    0    0 14    0    0  0    0    0        if (l->l_info[DT_NEEDED] || l->l_info[AUXTAG] || l->l_info[FILTERTAG])
  .    .    .  .    .    .  .    .    .  	{
 12    1    1  9    0    0  3    0    0  	  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
  .    .    .  .    .    .  .    .    .  	  struct openaux_args args;
  .    .    .  .    .    .  .    .    .  	  struct list *orig;
  .    .    .  .    .    .  .    .    .  	  const ElfW(Dyn) *d;
  .    .    .  .    .    .  .    .    .  
  3    0    0  0    0    0  3    0    0  	  args.strtab = strtab;
  6    0    0  0    0    0  3    0    0  	  args.map = l;
  6    0    0  3    0    0  3    0    0  	  args.trace_mode = trace_mode;
  6    0    0  3    0    0  3    0    0  	  args.open_mode = open_mode;
  .    .    .  .    .    .  .    .    .  	  orig = runp;
  .    .    .  .    .    .  .    .    .  
341    0    0 89    1    0  3    0    0  	  for (d = l->l_ld; d->d_tag != DT_NULL; ++d)
160    1    1  0    0    0  0    0    0  	    if (__builtin_expect (d->d_tag, DT_NEEDED) == DT_NEEDED)
  .    .    .  .    .    .  .    .    .  	      {
  .    .    .  .    .    .  .    .    .  		/* Map in the needed object.  */
  .    .    .  .    .    .  .    .    .  		struct link_map *dep;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		/* Recognize DSTs.  */
 43    1    1 10    0    0  9    0    0  		name = expand_dst (l, strtab + d->d_un.d_val, 0);
  .    .    .  .    .    .  .    .    .  		/* Store the tag in the argument structure.  */
  5    0    0  0    0    0  5    0    0  		args.name = name;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		bool malloced;
 30    1    1 20    0    0  5    0    0  		int err = _dl_catch_error (&objname, &errstring, &malloced,
  .    .    .  .    .    .  .    .    .  					   openaux, &args);
 15    0    0  5    0    0  0    0    0  		if (__builtin_expect (errstring != NULL, 0))
  .    .    .  .    .    .  .    .    .  		  {
  .    .    .  .    .    .  .    .    .  		    char *new_errstring = strdupa (errstring);
  .    .    .  .    .    .  .    .    .  		    objname = strdupa (objname);
  .    .    .  .    .    .  .    .    .  		    if (malloced)
  .    .    .  .    .    .  .    .    .  		      free ((char *) errstring);
  .    .    .  .    .    .  .    .    .  		    errstring = new_errstring;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		    if (err)
  .    .    .  .    .    .  .    .    .  		      errno_reason = err;
  .    .    .  .    .    .  .    .    .  		    else
  .    .    .  .    .    .  .    .    .  		      errno_reason = -1;
  .    .    .  .    .    .  .    .    .  		    goto out;
  .    .    .  .    .    .  .    .    .  		  }
  .    .    .  .    .    .  .    .    .  		else
  5    0    0  5    0    0  0    0    0  		  dep = args.aux;
  .    .    .  .    .    .  .    .    .  
 10    1    1  5    0    0  0    0    0  		if (! dep->l_reserved)
  .    .    .  .    .    .  .    .    .  		  {
  .    .    .  .    .    .  .    .    .  		    /* Allocate new entry.  */
  .    .    .  .    .    .  .    .    .  		    struct list *newp;
  .    .    .  .    .    .  .    .    .  
 24    1    1  3    0    0  0    0    0  		    newp = alloca (sizeof (struct list));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		    /* Append DEP to the list.  */
  3    1    1  0    0    0  3    0    0  		    newp->map = dep;
  3    0    0  0    0    0  3    0    0  		    newp->done = 0;
  3    0    0  0    0    0  3    0    0  		    newp->next = NULL;
  6    0    0  3    0    0  3    0    0  		    tail->next = newp;
  .    .    .  .    .    .  .    .    .  		    tail = newp;
 12    1    1  3    0    0  3    0    0  		    ++nlist;
  .    .    .  .    .    .  .    .    .  		    /* Set the mark bit that says it's already in the list.  */
 15    0    0  3    0    0  6    0    0  		    dep->l_reserved = 1;
  .    .    .  .    .    .  .    .    .  		  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		/* Remember this dependency.  */
 10    0    0  0    0    0  0    0    0  		if (needed != NULL)
  9    0    0  0    0    0  3    0    0  		  needed[nneeded++] = dep;
  .    .    .  .    .    .  .    .    .  	      }
225    1    1  0    0    0  0    0    0  	    else if (d->d_tag == DT_AUXILIARY || d->d_tag == DT_FILTER)
  .    .    .  .    .    .  .    .    .  	      {
  .    .    .  .    .    .  .    .    .  		struct list *newp;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		/* Recognize DSTs.  */
  .    .    .  .    .    .  .    .    .  		name = expand_dst (l, strtab + d->d_un.d_val,
  .    .    .  .    .    .  .    .    .  				   d->d_tag == DT_AUXILIARY);
  .    .    .  .    .    .  .    .    .  		/* Store the tag in the argument structure.  */
  .    .    .  .    .    .  .    .    .  		args.name = name;
-- line 305 ----------------------------------------
-- line 339 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		      _dl_debug_printf ("load filtered object=%s"
  .    .    .  .    .    .  .    .    .  					" requested by file=%s\n",
  .    .    .  .    .    .  .    .    .  					name,
  .    .    .  .    .    .  .    .    .  					l->l_name[0]
  .    .    .  .    .    .  .    .    .  					? l->l_name : rtld_progname);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		    /* For filter objects the dependency must be available.  */
  .    .    .  .    .    .  .    .    .  		    bool malloced;
  9    1    1  0    0    0  4    0    0  		    int err = _dl_catch_error (&objname, &errstring, &malloced,
  .    .    .  .    .    .  .    .    .  					       openaux, &args);
  .    .    .  .    .    .  .    .    .  		    if (__builtin_expect (errstring != NULL, 0))
  .    .    .  .    .    .  .    .    .  		      {
  .    .    .  .    .    .  .    .    .  			char *new_errstring = strdupa (errstring);
  .    .    .  .    .    .  .    .    .  			objname = strdupa (objname);
  .    .    .  .    .    .  .    .    .  			if (malloced)
  .    .    .  .    .    .  .    .    .  			  free ((char *) errstring);
  .    .    .  .    .    .  .    .    .  			errstring = new_errstring;
-- line 355 ----------------------------------------
-- line 467 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		  tail = newp;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		/* Move on the insert point.  */
  .    .    .  .    .    .  .    .    .  		orig = newp;
  .    .    .  .    .    .  .    .    .  	      }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Terminate the list of dependencies and store the array address.  */
 10    0    0  0    0    0  0    0    0        if (needed != NULL)
  .    .    .  .    .    .  .    .    .  	{
  9    1    1  0    0    0  3    0    0  	  needed[nneeded++] = NULL;
  .    .    .  .    .    .  .    .    .  
  6    0    0  0    0    0  3    0    0  	  struct link_map **l_initfini = (struct link_map **)
  6    0    0  0    0    0  0    0    0  	    malloc ((2 * nneeded + 1) * sizeof needed[0]);
  6    0    0  0    0    0  0    0    0  	  if (l_initfini == NULL)
  .    .    .  .    .    .  .    .    .  	    _dl_signal_error (ENOMEM, map->l_name, NULL,
  .    .    .  .    .    .  .    .    .  			      N_("cannot allocate dependency list"));
  6    0    0  3    0    0  3    0    0  	  l_initfini[0] = l;
 15    0    0  0    0    0  3    0    0  	  memcpy (&l_initfini[1], needed, nneeded * sizeof needed[0]);
 15    0    0  0    0    0  3    0    0  	  memcpy (&l_initfini[nneeded + 1], l_initfini,
  .    .    .  .    .    .  .    .    .  		  nneeded * sizeof needed[0]);
  .    .    .  .    .    .  .    .    .  	  atomic_write_barrier ();
  3    0    0  0    0    0  3    0    0  	  l->l_initfini = l_initfini;
  3    0    0  3    0    0  0    0    0  	  l->l_free_initfini = 1;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* If we have no auxiliary objects just go on to the next map.  */
 36    1    1 18    0    0  4    0    0        if (runp->done)
  .    .    .  .    .    .  .    .    .  	do
  5    1    1  5    0    0  0    0    0  	  runp = runp->next;
 22    0    0  4    0    0  0    0    0  	while (runp != NULL && runp->done);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .   out:
  6    0    0  2    0    0  0    0    0    if (errno == 0 && errno_saved != 0)
  2    1    1  1    0    0  1    0    0      __set_errno (errno_saved);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    struct link_map **old_l_initfini = NULL;
  6    0    0  2    0    0  1    0    0    if (map->l_initfini != NULL && map->l_type == lt_loaded)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* This object was previously loaded as a dependency and we have
  .    .    .  .    .    .  .    .    .  	 a separate l_initfini list.  We don't need it anymore.  */
  .    .    .  .    .    .  .    .    .        assert (map->l_searchlist.r_list == NULL);
  .    .    .  .    .    .  .    .    .        old_l_initfini = map->l_initfini;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Store the search list we built in the object.  It will be used for
  .    .    .  .    .    .  .    .    .       searches in the scope of this object.  */
  2    0    0  0    0    0  1    0    0    struct link_map **l_initfini =
  4    1    1  1    0    0  1    0    0      (struct link_map **) malloc ((2 * nlist + 1)
  .    .    .  .    .    .  .    .    .  				 * sizeof (struct link_map *));
  3    0    0  1    0    0  0    0    0    if (l_initfini == NULL)
  .    .    .  .    .    .  .    .    .      _dl_signal_error (ENOMEM, map->l_name, NULL,
  .    .    .  .    .    .  .    .    .  		      N_("cannot allocate symbol search list"));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  7    0    0  2    0    0  1    0    0    map->l_searchlist.r_list = &l_initfini[nlist + 1];
  4    1    1  1    0    0  1    0    0    map->l_searchlist.r_nlist = nlist;
  .    .    .  .    .    .  .    .    .  
 28    0    0 11    0    0  1    0    0    for (nlist = 0, runp = known; runp; runp = runp->next)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        if (__builtin_expect (trace_mode, 0) && runp->map->l_faked)
  .    .    .  .    .    .  .    .    .  	/* This can happen when we trace the loading.  */
  .    .    .  .    .    .  .    .    .  	--map->l_searchlist.r_nlist;
  .    .    .  .    .    .  .    .    .        else
 15    0    0  5    0    0  5    2    2  	map->l_searchlist.r_list[nlist++] = runp->map;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Now clear all the mark bits we set in the objects on the search list
  .    .    .  .    .    .  .    .    .  	 to avoid duplicates, so the next call starts fresh.  */
 10    1    1 10    0    0  0    0    0        runp->map->l_reserved = 0;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK, 0) != 0
  .    .    .  .    .    .  .    .    .        && map == GL(dl_ns)[LM_ID_BASE]._ns_loaded)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* If we are to compute conflicts, we have to build local scope
  .    .    .  .    .    .  .    .    .  	 for each library, not just the ultimate loader.  */
  .    .    .  .    .    .  .    .    .        for (i = 0; i < nlist; ++i)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  struct link_map *l = map->l_searchlist.r_list[i];
  .    .    .  .    .    .  .    .    .  	  unsigned int j, cnt;
-- line 547 ----------------------------------------
-- line 584 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	  memcpy (l->l_local_scope[0]->r_list, l_initfini,
  .    .    .  .    .    .  .    .    .  		  cnt * sizeof (struct link_map *));
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Maybe we can remove some relocation dependencies now.  */
  .    .    .  .    .    .  .    .    .    assert (map->l_searchlist.r_list[0] == map);
  .    .    .  .    .    .  .    .    .    struct link_map_reldeps *l_reldeps = NULL;
  4    0    0  2    0    0  0    0    0    if (map->l_reldeps != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        for (i = 1; i < nlist; ++i)
  .    .    .  .    .    .  .    .    .  	map->l_searchlist.r_list[i]->l_reserved = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        struct link_map **list = &map->l_reldeps->list[0];
  .    .    .  .    .    .  .    .    .        for (i = 0; i < map->l_reldeps->act; ++i)
  .    .    .  .    .    .  .    .    .  	if (list[i]->l_reserved)
  .    .    .  .    .    .  .    .    .  	  {
-- line 600 ----------------------------------------
-- line 620 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        for (i = 1; i < nlist; ++i)
  .    .    .  .    .    .  .    .    .  	map->l_searchlist.r_list[i]->l_reserved = 0;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Sort the initializer list to take dependencies into account.  The binary
  .    .    .  .    .    .  .    .    .       itself will always be initialize last.  */
 10    1    1  3    0    0  3    0    0    memcpy (l_initfini, map->l_searchlist.r_list,
  .    .    .  .    .    .  .    .    .  	  nlist * sizeof (struct link_map *));
  4    1    1  1    0    0  0    0    0    if (__builtin_expect (nlist > 1, 1))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* We can skip looking for the binary itself which is at the front
  .    .    .  .    .    .  .    .    .  	 of the search list.  */
  1    1    1  0    0    0  0    0    0        i = 1;
 21    2    2  1    0    0  3    0    0        uint16_t seen[nlist];
 22    1    1 10    0    0  4    0    0        memset (seen, 0, nlist * sizeof (seen[0]));
  .    .    .  .    .    .  .    .    .        while (1)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  /* Keep track of which object we looked at this round.  */
  4    0    0  4    0    0  0    0    0  	  ++seen[i];
  8    0    0  4    0    0  0    0    0  	  struct link_map *thisp = l_initfini[i];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Find the last object in the list for which the current one is
  .    .    .  .    .    .  .    .    .  	     a dependency and move the current object behind the object
  .    .    .  .    .    .  .    .    .  	     with the dependency.  */
  .    .    .  .    .    .  .    .    .  	  unsigned int k = nlist - 1;
 23    0    0  0    0    0  0    0    0  	  while (k > i)
  .    .    .  .    .    .  .    .    .  	    {
 24    0    0 12    0    0  0    0    0  	      struct link_map **runp = l_initfini[k]->l_initfini;
 15    0    0  0    0    0  0    0    0  	      if (runp != NULL)
  .    .    .  .    .    .  .    .    .  		/* Look through the dependencies of the object.  */
 30    0    0 10    0    0  0    0    0  		while (*runp != NULL)
 21    0    0  0    0    0  0    0    0  		  if (__builtin_expect (*runp++ == thisp, 0))
  .    .    .  .    .    .  .    .    .  		    {
  .    .    .  .    .    .  .    .    .  		      /* Move the current object to the back past the last
  .    .    .  .    .    .  .    .    .  			 object with it as the dependency.  */
  .    .    .  .    .    .  .    .    .  		      memmove (&l_initfini[i], &l_initfini[i + 1],
  .    .    .  .    .    .  .    .    .  			       (k - i) * sizeof (l_initfini[0]));
  .    .    .  .    .    .  .    .    .  		      l_initfini[k] = thisp;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		      if (seen[i + 1] > nlist - i)
  .    .    .  .    .    .  .    .    .  			{
  3    1    1  2    0    0  0    0    0  			  ++i;
  .    .    .  .    .    .  .    .    .  			  goto next_clear;
  .    .    .  .    .    .  .    .    .  			}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		      uint16_t this_seen = seen[i];
  .    .    .  .    .    .  .    .    .  		      memmove (&seen[i], &seen[i + 1],
  .    .    .  .    .    .  .    .    .  			       (k - i) * sizeof (seen[0]));
  .    .    .  .    .    .  .    .    .  		      seen[k] = this_seen;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		      goto next;
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  
  6    1    1  0    0    0  0    0    0  	      --k;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  
 12    0    0  4    0    0  0    0    0  	  if (++i == nlist)
  .    .    .  .    .    .  .    .    .  	    break;
  .    .    .  .    .    .  .    .    .  	next_clear:
 42    1    1 12    0    0  9    0    0  	  memset (&seen[i], 0, (nlist - i) * sizeof (seen[0]));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	next:;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Terminate the list of dependencies.  */
  2    1    1  1    0    0  1    0    0    l_initfini[nlist] = NULL;
  .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
  2    0    0  1    0    0  1    0    0    map->l_initfini = l_initfini;
  1    0    0  1    0    0  0    0    0    map->l_free_initfini = 1;
  .    .    .  .    .    .  .    .    .    if (l_reldeps != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        atomic_write_barrier ();
  .    .    .  .    .    .  .    .    .        void *old_l_reldeps = map->l_reldeps;
  .    .    .  .    .    .  .    .    .        map->l_reldeps = l_reldeps;
  .    .    .  .    .    .  .    .    .        _dl_scope_free (old_l_reldeps);
  .    .    .  .    .    .  .    .    .      }
  3    0    0  1    0    0  0    0    0    if (old_l_initfini != NULL)
  .    .    .  .    .    .  .    .    .      _dl_scope_free (old_l_initfini);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0    if (errno_reason)
  .    .    .  .    .    .  .    .    .      _dl_signal_error (errno_reason == -1 ? 0 : errno_reason, objname,
  .    .    .  .    .    .  .    .    .  		      NULL, errstring);
  8    0    0  7    0    0  0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/rtld.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 100 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Check that AT_SECURE=0, or that the passed name does not contain
  .    .    .  .    .    .  .    .    .     directories and is not overly long.  Reject empty names
  .    .    .  .    .    .  .    .    .     unconditionally.  */
  .    .    .  .    .    .  .    .    .  static bool
  .    .    .  .    .    .  .    .    .  dso_name_valid_for_suid (const char *p)
  .    .    .  .    .    .  .    .    .  {
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Ignore pathnames with directories for AT_SECURE=1
  .    .    .  .    .    .  .    .    .  	 programs, and also skip overlong names.  */
  .    .    .  .    .    .  .    .    .        size_t len = strlen (p);
  .    .    .  .    .    .  .    .    .        if (len >= NAME_MAX || memchr (p, '/', len) != NULL)
  .    .    .  .    .    .  .    .    .  	return false;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    return *p != '\0';
-- line 116 ----------------------------------------
-- line 160 ----------------------------------------
  .    .    .  .    .    .  .    .    .        /* First iterate over audit_list_string.  */
  .    .    .  .    .    .  .    .    .        while (*iter->audit_list_tail != '\0')
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  /* Split audit list at colon.  */
  .    .    .  .    .    .  .    .    .  	  size_t len = strcspn (iter->audit_list_tail, ":");
  .    .    .  .    .    .  .    .    .  	  if (len > 0 && len < PATH_MAX)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      memcpy (iter->fname, iter->audit_list_tail, len);
  2    1    1  0    0    0  0    0    0  	      iter->fname[len] = '\0';
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    /* Do not return this name to the caller.  */
  .    .    .  .    .    .  .    .    .  	    iter->fname[0] = '\0';
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Skip over the substring and the following delimiter.  */
  .    .    .  .    .    .  .    .    .  	  iter->audit_list_tail += len;
  .    .    .  .    .    .  .    .    .  	  if (*iter->audit_list_tail == ':')
-- line 176 ----------------------------------------
-- line 370 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #ifndef DONT_USE_BOOTSTRAP_MAP
  .    .    .  .    .    .  .    .    .    GL(dl_rtld_map).l_addr = info->l.l_addr;
  .    .    .  .    .    .  .    .    .    GL(dl_rtld_map).l_ld = info->l.l_ld;
  .    .    .  .    .    .  .    .    .    memcpy (GL(dl_rtld_map).l_info, info->l.l_info,
  .    .    .  .    .    .  .    .    .  	  sizeof GL(dl_rtld_map).l_info);
  .    .    .  .    .    .  .    .    .    GL(dl_rtld_map).l_mach = info->l.l_mach;
  .    .    .  .    .    .  .    .    .    GL(dl_rtld_map).l_relocated = 1;
  .    .    .  .    .    .  .    .    .  #endif
  2    0    0  0    0    0  1    1    1    _dl_setup_hash (&GL(dl_rtld_map));
  2    0    0  0    0    0  1    0    0    GL(dl_rtld_map).l_real = &GL(dl_rtld_map);
  2    1    1  0    0    0  1    1    1    GL(dl_rtld_map).l_map_start = (ElfW(Addr)) _begin;
  2    0    0  0    0    0  1    0    0    GL(dl_rtld_map).l_map_end = (ElfW(Addr)) _end;
  2    0    0  0    0    0  1    0    0    GL(dl_rtld_map).l_text_end = (ElfW(Addr)) _etext;
  .    .    .  .    .    .  .    .    .    /* Copy the TLS related data if necessary.  */
  .    .    .  .    .    .  .    .    .  #ifndef DONT_USE_BOOTSTRAP_MAP
  .    .    .  .    .    .  .    .    .  # if NO_TLS_OFFSET != 0
  .    .    .  .    .    .  .    .    .    GL(dl_rtld_map).l_tls_offset = NO_TLS_OFFSET;
  .    .    .  .    .    .  .    .    .  # endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  5    0    0  0    0    0  1    1    1    HP_TIMING_NOW (GL(dl_cpuclock_offset));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Initialize the stack end variable.  */
  1    1    1  0    0    0  1    1    1    __libc_stack_end = __builtin_frame_address (0);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Call the OS-dependent function to set up life so we can do things like
  .    .    .  .    .    .  .    .    .       file access.  It will call `dl_main' (below) to do all the real work
  .    .    .  .    .    .  .    .    .       of the dynamic linker, and then unwind our frame and run the user
  .    .    .  .    .    .  .    .    .       entry point on the same stack we entered on.  */
  4    0    0  0    0    0  1    0    0    start_addr = _dl_sysdep_start (arg, &dl_main);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .    hp_timing_t rtld_total_time;
  .    .    .  .    .    .  .    .    .    if (HP_SMALL_TIMING_AVAIL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        hp_timing_t end_time;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Get the current time.  */
  4    0    0  0    0    0  0    0    0        HP_TIMING_NOW (end_time);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Compute the difference.  */
  2    0    0  1    1    0  1    1    0        HP_TIMING_DIFF (rtld_total_time, start_time, end_time);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_STATISTICS, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .        print_statistics (&rtld_total_time);
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .        print_statistics (NULL);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return start_addr;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static ElfW(Addr) __attribute_used__ internal_function
  .    .    .  .    .    .  .    .    .  _dl_start (void *arg)
  9    1    1  0    0    0  6    1    1  {
  .    .    .  .    .    .  .    .    .  #ifdef DONT_USE_BOOTSTRAP_MAP
  .    .    .  .    .    .  .    .    .  # define bootstrap_map GL(dl_rtld_map)
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .    struct dl_start_final_info info;
  .    .    .  .    .    .  .    .    .  # define bootstrap_map info.l
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* This #define produces dynamic linking inline functions for
-- line 438 ----------------------------------------
-- line 440 ----------------------------------------
  .    .    .  .    .    .  .    .    .       Since ld.so must not have any undefined symbols the result
  .    .    .  .    .    .  .    .    .       is trivial: always the map of ld.so itself.  */
  .    .    .  .    .    .  .    .    .  #define RTLD_BOOTSTRAP
  .    .    .  .    .    .  .    .    .  #define RESOLVE_MAP(sym, version, flags) (&bootstrap_map)
  .    .    .  .    .    .  .    .    .  #include "dynamic-link.h"
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    if (HP_TIMING_INLINE && HP_SMALL_TIMING_AVAIL)
  .    .    .  .    .    .  .    .    .  #ifdef DONT_USE_BOOTSTRAP_MAP
  5    0    0  0    0    0  1    1    1      HP_TIMING_NOW (start_time);
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .      HP_TIMING_NOW (info.start_time);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Partly clean the `bootstrap_map' structure up.  Don't use
  .    .    .  .    .    .  .    .    .       `memset' since it might not be built in or inlined and we cannot
  .    .    .  .    .    .  .    .    .       make function calls at this point.  Use '__builtin_memset' if we
  .    .    .  .    .    .  .    .    .       know it is available.  We do not have to clear the memory if we
-- line 456 ----------------------------------------
-- line 463 ----------------------------------------
  .    .    .  .    .    .  .    .    .    for (size_t cnt = 0;
  .    .    .  .    .    .  .    .    .         cnt < sizeof (bootstrap_map.l_info) / sizeof (bootstrap_map.l_info[0]);
  .    .    .  .    .    .  .    .    .         ++cnt)
  .    .    .  .    .    .  .    .    .      bootstrap_map.l_info[cnt] = 0;
  .    .    .  .    .    .  .    .    .  # endif
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Figure out the run-time load address of the dynamic linker itself.  */
  1    0    0  0    0    0  1    0    0    bootstrap_map.l_addr = elf_machine_load_address ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Read our own dynamic section and fill in the info array.  */
  1    0    0  0    0    0  1    1    1    bootstrap_map.l_ld = (void *) bootstrap_map.l_addr + elf_machine_dynamic ();
  .    .    .  .    .    .  .    .    .    elf_get_dynamic_info (&bootstrap_map, NULL);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if NO_TLS_OFFSET != 0
  .    .    .  .    .    .  .    .    .    bootstrap_map.l_tls_offset = NO_TLS_OFFSET;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Get the dynamic linker's own program header.  First we need the ELF
  .    .    .  .    .    .  .    .    .       file header.  The `_begin' symbol created by the linker script points
-- line 482 ----------------------------------------
-- line 488 ----------------------------------------
  .    .    .  .    .    .  .    .    .    ELF_MACHINE_BEFORE_RTLD_RELOC (bootstrap_map.l_info);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    if (bootstrap_map.l_addr || ! bootstrap_map.l_info[VALIDX(DT_GNU_PRELINKED)])
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Relocate ourselves so we can do normal function calls and
  .    .    .  .    .    .  .    .    .  	 data access using the global offset table.  */
  .    .    .  .    .    .  .    .    .  
 34    3    3 10    0    0  0    0    0        ELF_DYNAMIC_RELOCATE (&bootstrap_map, 0, 0, 0);
  .    .    .  .    .    .  .    .    .      }
  1    0    0  1    1    1  0    0    0    bootstrap_map.l_relocated = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Please note that we don't allow profiling of this object and
  .    .    .  .    .    .  .    .    .       therefore need not test whether we have to allocate the array
  .    .    .  .    .    .  .    .    .       for the relocation results (as done in dl-reloc.c).  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Now life is sane; we can call functions and access global data.
  .    .    .  .    .    .  .    .    .       Set up to use the operating system facilities, and find out from
  .    .    .  .    .    .  .    .    .       the operating system's program loader where to find the program
-- line 506 ----------------------------------------
-- line 515 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef ELF_MACHINE_START_ADDRESS
  .    .    .  .    .    .  .    .    .  # define ELF_MACHINE_START_ADDRESS(map, start) (start)
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      return ELF_MACHINE_START_ADDRESS (GL(dl_ns)[LM_ID_BASE]._ns_loaded, entry);
  .    .    .  .    .    .  .    .    .    }
  9    0    0  7    1    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Now life is peachy; we can do all normal operations.
  .    .    .  .    .    .  .    .    .     On to the real work.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Some helper functions.  */
  .    .    .  .    .    .  .    .    .  
-- line 531 ----------------------------------------
-- line 571 ----------------------------------------
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    struct relocate_args *args = (struct relocate_args *) a;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    _dl_relocate_object (args->l, args->l->l_scope, args->reloc_mode, 0);
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  map_doit (void *a)
  2    1    1  0    0    0  1    0    0  {
  .    .    .  .    .    .  .    .    .    struct map_args *args = (struct map_args *) a;
  8    0    0  3    0    0  2    0    0    args->map = _dl_map_object (args->loader, args->str, lt_library, 0,
  .    .    .  .    .    .  .    .    .  			      args->mode, LM_ID_BASE);
  2    0    0  2    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  dlmopen_doit (void *a)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    struct dlmopen_args *args = (struct dlmopen_args *) a;
  .    .    .  .    .    .  .    .    .    args->map = _dl_open (args->fname,
  .    .    .  .    .    .  .    .    .  			(RTLD_LAZY | __RTLD_DLOPEN | __RTLD_AUDIT
  .    .    .  .    .    .  .    .    .  			 | __RTLD_SECURE),
-- line 591 ----------------------------------------
-- line 603 ----------------------------------------
  .    .    .  .    .    .  .    .    .  				    args->map->l_local_scope, NULL, 0,
  .    .    .  .    .    .  .    .    .  				    DL_LOOKUP_RETURN_NEWEST, NULL);
  .    .    .  .    .    .  .    .    .    if (ref != NULL)
  .    .    .  .    .    .  .    .    .      args->result = DL_SYMBOL_ADDRESS (l, ref);
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  version_check_doit (void *a)
  2    1    1  0    0    0  1    0    0  {
  .    .    .  .    .    .  .    .    .    struct version_check_args *args = (struct version_check_args *) a;
  6    0    0  2    0    0  1    0    0    if (_dl_check_all_versions (GL(dl_ns)[LM_ID_BASE]._ns_loaded, 1,
  .    .    .  .    .    .  .    .    .  			      args->dotrace) && args->doexit)
  .    .    .  .    .    .  .    .    .      /* We cannot start the application.  Abort now.  */
  .    .    .  .    .    .  .    .    .      _exit (1);
  2    0    0  2    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static inline struct link_map *
  .    .    .  .    .    .  .    .    .  find_needed (const char *name)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    struct r_scope_elem *scope = &GL(dl_ns)[LM_ID_BASE]._ns_loaded->l_searchlist;
  .    .    .  .    .    .  .    .    .    unsigned int n = scope->r_nlist;
  .    .    .  .    .    .  .    .    .  
-- line 625 ----------------------------------------
-- line 663 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return 0;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static bool tls_init_tp_called;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void *
  .    .    .  .    .    .  .    .    .  init_tls (void)
  1    0    0  0    0    0  1    0    0  {
  .    .    .  .    .    .  .    .    .    /* Number of elements in the static TLS block.  */
  2    0    0  1    0    0  1    0    0    GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Do not do this twice.  The audit interface might have required
  .    .    .  .    .    .  .    .    .       the DTV interfaces to be set up early.  */
  2    1    1  1    1    0  0    0    0    if (GL(dl_initial_dtv) != NULL)
  1    1    1  0    0    0  0    0    0      return NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Allocate the array which contains the information about the
  .    .    .  .    .    .  .    .    .       dtv slots.  We allocate a few entries more than needed to
  .    .    .  .    .    .  .    .    .       avoid the need for reallocation.  */
  2    0    0  0    0    0  1    0    0    size_t nelem = GL(dl_tls_max_dtv_idx) + 1 + TLS_SLOTINFO_SURPLUS;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Allocate.  */
  1    0    0  0    0    0  1    0    0    GL(dl_tls_dtv_slotinfo_list) = (struct dtv_slotinfo_list *)
  4    0    0  0    0    0  1    0    0      calloc (sizeof (struct dtv_slotinfo_list)
  .    .    .  .    .    .  .    .    .  	    + nelem * sizeof (struct dtv_slotinfo), 1);
  .    .    .  .    .    .  .    .    .    /* No need to check the return value.  If memory allocation failed
  .    .    .  .    .    .  .    .    .       the program would have been terminated.  */
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  0    0    0    struct dtv_slotinfo *slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
  .    .    .  .    .    .  .    .    .    GL(dl_tls_dtv_slotinfo_list)->len = nelem;
  1    1    1  0    0    0  1    0    0    GL(dl_tls_dtv_slotinfo_list)->next = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Fill in the information from the loaded modules.  No namespace
  .    .    .  .    .    .  .    .    .       but the base one can be filled at this time.  */
  .    .    .  .    .    .  .    .    .    assert (GL(dl_ns)[LM_ID_BASE + 1]._ns_loaded == NULL);
  1    0    0  0    0    0  0    0    0    int i = 0;
 13    0    0  1    0    0  0    0    0    for (struct link_map *l = GL(dl_ns)[LM_ID_BASE]._ns_loaded; l != NULL;
 10    0    0  5    0    0  0    0    0         l = l->l_next)
 10    0    0  5    0    0  0    0    0      if (l->l_tls_blocksize != 0)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* This is a module with TLS data.  Store the map reference.
  .    .    .  .    .    .  .    .    .  	   The generation counter is zero.  */
  3    0    0  0    0    0  1    0    0  	slotinfo[i].map = l;
  .    .    .  .    .    .  .    .    .  	/* slotinfo[i].gen = 0; */
  1    0    0  0    0    0  0    0    0  	++i;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .    assert (i == GL(dl_tls_max_dtv_idx));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Compute the TLS offsets for the various blocks.  */
  1    0    0  0    0    0  1    0    0    _dl_determine_tlsoffset ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Construct the static TLS block and the dtv for the initial
  .    .    .  .    .    .  .    .    .       thread.  For some platforms this will include allocating memory
  .    .    .  .    .    .  .    .    .       for the thread descriptor.  The memory for the TLS block will
  .    .    .  .    .    .  .    .    .       never be freed.  It should be allocated accordingly.  The dtv
  .    .    .  .    .    .  .    .    .       array can be changed if dynamic loading requires it.  */
  2    0    0  0    0    0  1    0    0    void *tcbp = _dl_allocate_tls_storage ();
  2    0    0  0    0    0  0    0    0    if (tcbp == NULL)
  .    .    .  .    .    .  .    .    .      _dl_fatal_printf ("\
  .    .    .  .    .    .  .    .    .  cannot allocate TLS data structures for initial thread");
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Store for detection of the special case by __tls_get_addr
  .    .    .  .    .    .  .    .    .       so it knows not to pass this dtv to the normal realloc.  */
  2    1    1  1    0    0  1    0    0    GL(dl_initial_dtv) = GET_DTV (tcbp);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* And finally install it for the main thread.  If ld.so itself uses
  .    .    .  .    .    .  .    .    .       TLS we know the thread pointer was initialized earlier.  */
  7    1    1  0    0    0  2    0    0    const char *lossage = TLS_INIT_TP (tcbp, 0);
  .    .    .  .    .    .  .    .    .    if (__builtin_expect (lossage != NULL, 0))
  .    .    .  .    .    .  .    .    .      _dl_fatal_printf ("cannot set up thread-local storage: %s\n", lossage);
  2    0    0  0    0    0  1    0    0    tls_init_tp_called = true;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return tcbp;
  2    0    0  2    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef _LIBC_REENTRANT
  .    .    .  .    .    .  .    .    .  /* _dl_error_catch_tsd points to this for the single-threaded case.
  .    .    .  .    .    .  .    .    .     It's reset by the thread library for multithreaded programs.  */
  .    .    .  .    .    .  .    .    .  void ** __attribute__ ((const))
  .    .    .  .    .    .  .    .    .  _dl_initial_error_catch_tsd (void)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    static void *data;
  .    .    .  .    .    .  .    .    .    return &data;
 16    0    0  8    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static unsigned int
  .    .    .  .    .    .  .    .    .  do_preload (char *fname, struct link_map *main_map, const char *where)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    const char *objname;
  1    0    0  0    0    0  1    0    0    const char *err_str = NULL;
  .    .    .  .    .    .  .    .    .    struct map_args args;
  .    .    .  .    .    .  .    .    .    bool malloced;
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  1    0    0    args.str = fname;
  2    0    0  1    0    0  1    0    0    args.loader = main_map;
  1    0    0  0    0    0  1    0    0    args.mode = __RTLD_SECURE;
  .    .    .  .    .    .  .    .    .  
  1    1    1  1    0    0  0    0    0    unsigned int old_nloaded = GL(dl_ns)[LM_ID_BASE]._ns_nloaded;
  .    .    .  .    .    .  .    .    .  
 13    1    1  3    0    0  4    0    0    (void) _dl_catch_error (&objname, &err_str, &malloced, map_doit, &args);
  2    0    0  1    0    0  0    0    0    if (__builtin_expect (err_str != NULL, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        _dl_error_printf ("\
  .    .    .  .    .    .  .    .    .  ERROR: ld.so: object '%s' from %s cannot be preloaded: ignored.\n",
  .    .    .  .    .    .  .    .    .  			fname, where);
  .    .    .  .    .    .  .    .    .        /* No need to call free, this is still before
  .    .    .  .    .    .  .    .    .  	 the libc's malloc is used.  */
  .    .    .  .    .    .  .    .    .      }
  3    0    0  1    0    0  0    0    0    else if (GL(dl_ns)[LM_ID_BASE]._ns_nloaded != old_nloaded)
  .    .    .  .    .    .  .    .    .      /* It is no duplicate.  */
  .    .    .  .    .    .  .    .    .      return 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Nothing loaded.  */
  .    .    .  .    .    .  .    .    .    return 0;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if defined SHARED && defined _LIBC_REENTRANT \
  .    .    .  .    .    .  .    .    .      && defined __rtld_lock_default_lock_recursive
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  rtld_lock_default_lock_recursive (void *lock)
  .    .    .  .    .    .  .    .    .  {
  8    1    1  8    1    1  0    0    0    __rtld_lock_default_lock_recursive (lock);
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  rtld_lock_default_unlock_recursive (void *lock)
  .    .    .  .    .    .  .    .    .  {
  8    0    0  8    0    0  0    0    0    __rtld_lock_default_unlock_recursive (lock);
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  security_init (void)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    /* Set up the stack checker's canary.  */
  1    0    0  1    0    0  0    0    0    uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);
  .    .    .  .    .    .  .    .    .  #ifdef THREAD_SET_STACK_GUARD
  1    0    0  0    0    0  1    0    0    THREAD_SET_STACK_GUARD (stack_chk_guard);
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .    __stack_chk_guard = stack_chk_guard;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Set up the pointer guard as well, if necessary.  */
  .    .    .  .    .    .  .    .    .    uintptr_t pointer_chk_guard
  .    .    .  .    .    .  .    .    .      = _dl_setup_pointer_guard (_dl_random, stack_chk_guard);
  .    .    .  .    .    .  .    .    .  #ifdef THREAD_SET_POINTER_GUARD
  1    1    1  0    0    0  1    0    0    THREAD_SET_POINTER_GUARD (pointer_chk_guard);
  .    .    .  .    .    .  .    .    .  #endif
  1    0    0  0    0    0  1    0    0    __pointer_chk_guard_local = pointer_chk_guard;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We do not need the _dl_random value anymore.  The less
  .    .    .  .    .    .  .    .    .       information we leave behind, the better, so clear the
  .    .    .  .    .    .  .    .    .       variable.  */
  1    0    0  0    0    0  1    0    0    _dl_random = NULL;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #include "setup-vdso.h"
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* The library search path.  */
  .    .    .  .    .    .  .    .    .  static const char *library_path attribute_relro;
  .    .    .  .    .    .  .    .    .  /* The list preloaded objects.  */
  .    .    .  .    .    .  .    .    .  static const char *preloadlist attribute_relro;
-- line 828 ----------------------------------------
-- line 832 ----------------------------------------
  .    .    .  .    .    .  .    .    .  /* The LD_PRELOAD environment variable gives list of libraries
  .    .    .  .    .    .  .    .    .     separated by white space or colons that are loaded before the
  .    .    .  .    .    .  .    .    .     executable's dependencies and prepended to the global scope list.
  .    .    .  .    .    .  .    .    .     (If the binary is running setuid all elements containing a '/' are
  .    .    .  .    .    .  .    .    .     ignored since it is insecure.)  Return the number of preloads
  .    .    .  .    .    .  .    .    .     performed.  */
  .    .    .  .    .    .  .    .    .  unsigned int
  .    .    .  .    .    .  .    .    .  handle_ld_preload (const char *preloadlist, struct link_map *main_map)
 11    1    1  1    1    1  7    1    1  {
  1    0    0  0    0    0  0    0    0    unsigned int npreloads = 0;
  .    .    .  .    .    .  .    .    .    const char *p = preloadlist;
  .    .    .  .    .    .  .    .    .    char fname[PATH_MAX];
  .    .    .  .    .    .  .    .    .  
  6    0    0  2    0    0  0    0    0    while (*p != '\0')
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Split preload list at space/colon.  */
  .    .    .  .    .    .  .    .    .        size_t len = strcspn (p, " :");
  3    0    0  0    0    0  0    0    0        if (len > 0 && len < PATH_MAX)
  .    .    .  .    .    .  .    .    .  	{
  6    1    1  0    0    0  1    0    0  	  memcpy (fname, p, len);
  3    0    0  0    0    0  1    0    0  	  fname[len] = '\0';
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	fname[0] = '\0';
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Skip over the substring and the following delimiter.  */
  .    .    .  .    .    .  .    .    .        p += len;
  4    0    0  0    0    0  0    0    0        if (*p == ' ' || *p == ':')
  .    .    .  .    .    .  .    .    .  	++p;
  .    .    .  .    .    .  .    .    .  
  2    1    1  1    0    0  0    0    0        if (dso_name_valid_for_suid (fname))
  1    0    0  0    0    0  0    0    0  	npreloads += do_preload (fname, main_map, "LD_PRELOAD");
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    return npreloads;
  9    0    0  7    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  dl_main (const ElfW(Phdr) *phdr,
  .    .    .  .    .    .  .    .    .  	 ElfW(Word) phnum,
  .    .    .  .    .    .  .    .    .  	 ElfW(Addr) *user_entry,
  .    .    .  .    .    .  .    .    .  	 ElfW(auxv_t) *auxv)
 14    1    1  1    1    1  7    1    1  {
  .    .    .  .    .    .  .    .    .    const ElfW(Phdr) *ph;
  .    .    .  .    .    .  .    .    .    enum mode mode;
  .    .    .  .    .    .  .    .    .    struct link_map *main_map;
  .    .    .  .    .    .  .    .    .    size_t file_size;
  .    .    .  .    .    .  .    .    .    char *file;
  1    0    0  0    0    0  0    0    0    bool has_interp = false;
  .    .    .  .    .    .  .    .    .    unsigned int i;
  2    0    0  0    0    0  0    0    0    bool prelinked = false;
  1    0    0  0    0    0  0    0    0    bool rtld_is_main = false;
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .    hp_timing_t start;
  .    .    .  .    .    .  .    .    .    hp_timing_t stop;
  .    .    .  .    .    .  .    .    .    hp_timing_t diff;
  .    .    .  .    .    .  .    .    .  #endif
  1    0    0  0    0    0  1    0    0    void *tcbp = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef _LIBC_REENTRANT
  .    .    .  .    .    .  .    .    .    /* Explicit initialization since the reloc would just be more work.  */
  2    1    1  0    0    0  1    0    0    GL(dl_error_catch_tsd) = &_dl_initial_error_catch_tsd;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  1    1    1    GL(dl_init_static_tls) = &_dl_nothread_init_static_tls;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if defined SHARED && defined _LIBC_REENTRANT \
  .    .    .  .    .    .  .    .    .      && defined __rtld_lock_default_lock_recursive
  2    0    0  0    0    0  1    1    1    GL(dl_rtld_lock_recursive) = rtld_lock_default_lock_recursive;
  2    0    0  0    0    0  1    0    0    GL(dl_rtld_unlock_recursive) = rtld_lock_default_unlock_recursive;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* The explicit initialization here is cheaper than processing the reloc
  .    .    .  .    .    .  .    .    .       in the _rtld_local definition's initializer.  */
  2    1    1  0    0    0  1    0    0    GL(dl_make_stack_executable_hook) = &_dl_make_stack_executable;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Process the environment variable which control the behaviour.  */
  .    .    .  .    .    .  .    .    .    process_envvars (&mode);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Set up a flag which tells we are just starting.  */
  1    0    0  0    0    0  1    1    1    INTUSE(_dl_starting_up) = 1;
  .    .    .  .    .    .  .    .    .  
  3    1    1  1    0    0  0    0    0    if (*user_entry == (ElfW(Addr)) ENTRY_POINT)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Ho ho.  We are not the program interpreter!  We are the program
  .    .    .  .    .    .  .    .    .  	 itself!  This means someone ran ld.so as a command.  Well, that
  .    .    .  .    .    .  .    .    .  	 might be convenient to do sometimes.  We support it by
  .    .    .  .    .    .  .    .    .  	 interpreting the args like this:
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	 ld.so PROGRAM ARGS...
  .    .    .  .    .    .  .    .    .  
-- line 923 ----------------------------------------
-- line 1103 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	    break;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Create a link_map for the executable itself.
  .    .    .  .    .    .  .    .    .  	 This will be what dlopen on "" returns.  */
  8    1    1  0    0    0  1    0    0        main_map = _dl_new_object ((char *) "", "", lt_executable, NULL,
  .    .    .  .    .    .  .    .    .  				 __RTLD_OPENEXEC, LM_ID_BASE);
  .    .    .  .    .    .  .    .    .        assert (main_map != NULL);
  1    0    0  0    0    0  1    1    1        main_map->l_phdr = phdr;
  2    0    0  1    0    0  1    0    0        main_map->l_phnum = phnum;
  2    1    1  1    0    0  1    0    0        main_map->l_entry = *user_entry;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Even though the link map is not yet fully initialized we can add
  .    .    .  .    .    .  .    .    .  	 it to the map list since there are no possible users running yet.  */
  6    0    0  1    0    0  2    0    0        _dl_add_to_namespace_list (main_map, LM_ID_BASE);
  .    .    .  .    .    .  .    .    .        assert (main_map == GL(dl_ns)[LM_ID_BASE]._ns_loaded);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* At this point we are in a bit of trouble.  We would have to
  .    .    .  .    .    .  .    .    .  	 fill in the values for l_dev and l_ino.  But in general we
  .    .    .  .    .    .  .    .    .  	 do not know where the file is.  We also do not handle AT_EXECFD
  .    .    .  .    .    .  .    .    .  	 even if it would be passed up.
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	 We leave the values here defined to 0.  This is normally no
-- line 1128 ----------------------------------------
-- line 1134 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	 easy way out and because the dynamic binary must also not
  .    .    .  .    .    .  .    .    .  	 have an SONAME we ignore this program for now.  If it becomes
  .    .    .  .    .    .  .    .    .  	 a problem we can force people using SONAMEs.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* We delay initializing the path structure until we got the dynamic
  .    .    .  .    .    .  .    .    .  	 information for the program.  */
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  1    0    0    main_map->l_map_end = 0;
  1    0    0  0    0    0  1    0    0    main_map->l_text_end = 0;
  .    .    .  .    .    .  .    .    .    /* Perhaps the executable has no PT_LOAD header entries at all.  */
  1    1    1  0    0    0  1    0    0    main_map->l_map_start = ~0;
  .    .    .  .    .    .  .    .    .    /* And it was opened directly.  */
  1    0    0  1    0    0  0    0    0    ++main_map->l_direct_opencount;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Scan the program header table for the dynamic section.  */
 36    1    1  3    0    0  0    0    0    for (ph = phdr; ph < &phdr[phnum]; ++ph)
 71    2    2  9    5    5  0    0    0      switch (ph->p_type)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .        case PT_PHDR:
  .    .    .  .    .    .  .    .    .  	/* Find out the load address.  */
  3    1    1  1    0    0  1    0    0  	main_map->l_addr = (ElfW(Addr)) phdr - ph->p_vaddr;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case PT_DYNAMIC:
  .    .    .  .    .    .  .    .    .  	/* This tells us where to find the dynamic section,
  .    .    .  .    .    .  .    .    .  	   which tells us everything we need to do.  */
  3    1    1  2    0    0  1    0    0  	main_map->l_ld = (void *) main_map->l_addr + ph->p_vaddr;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case PT_INTERP:
  .    .    .  .    .    .  .    .    .  	/* This "interpreter segment" was used by the program loader to
  .    .    .  .    .    .  .    .    .  	   find the program interpreter, which is this program itself, the
  .    .    .  .    .    .  .    .    .  	   dynamic linker.  We note what name finds us, so that a future
  .    .    .  .    .    .  .    .    .  	   dlopen call or DT_NEEDED entry, for something that wants to link
  .    .    .  .    .    .  .    .    .  	   against the dynamic linker as a shared library, will know that
  .    .    .  .    .    .  .    .    .  	   the shared object is already loaded.  */
  1    0    0  0    0    0  1    1    1  	_dl_rtld_libname.name = ((const char *) main_map->l_addr
  2    1    1  2    1    1  0    0    0  				 + ph->p_vaddr);
  .    .    .  .    .    .  .    .    .  	/* _dl_rtld_libname.next = NULL;	Already zero.  */
  2    0    0  0    0    0  1    0    0  	GL(dl_rtld_map).l_libname = &_dl_rtld_libname;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	/* Ordinarilly, we would get additional names for the loader from
  .    .    .  .    .    .  .    .    .  	   our DT_SONAME.  This can't happen if we were actually linked as
  .    .    .  .    .    .  .    .    .  	   a static executable (detect this case when we have no DYNAMIC).
  .    .    .  .    .    .  .    .    .  	   If so, assume the filename component of the interpreter path to
  .    .    .  .    .    .  .    .    .  	   be our SONAME, and add it to our name list.  */
  3    1    1  1    0    0  0    0    0  	if (GL(dl_rtld_map).l_ld == NULL)
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    const char *p = NULL;
  .    .    .  .    .    .  .    .    .  	    const char *cp = _dl_rtld_libname.name;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	    /* Find the filename part of the path.  */
  .    .    .  .    .    .  .    .    .  	    while (*cp != '\0')
  .    .    .  .    .    .  .    .    .  	      if (*cp++ == '/')
  .    .    .  .    .    .  .    .    .  		p = cp;
-- line 1187 ----------------------------------------
-- line 1189 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	    if (p != NULL)
  .    .    .  .    .    .  .    .    .  	      {
  .    .    .  .    .    .  .    .    .  		_dl_rtld_libname2.name = p;
  .    .    .  .    .    .  .    .    .  		/* _dl_rtld_libname2.next = NULL;  Already zero.  */
  .    .    .  .    .    .  .    .    .  		_dl_rtld_libname.next = &_dl_rtld_libname2;
  .    .    .  .    .    .  .    .    .  	      }
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  0    0    0  	has_interp = true;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .        case PT_LOAD:
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  ElfW(Addr) mapstart;
  .    .    .  .    .    .  .    .    .  	  ElfW(Addr) allocend;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Remember where the main program starts in memory.  */
  4    0    0  2    0    0  0    0    0  	  mapstart = (main_map->l_addr
 10    2    2  3    1    1  0    0    0  		      + (ph->p_vaddr & ~(GLRO(dl_pagesize) - 1)));
  4    0    0  2    0    0  0    0    0  	  if (main_map->l_map_start > mapstart)
  1    0    0  0    0    0  1    0    0  	    main_map->l_map_start = mapstart;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Also where it ends.  */
  4    0    0  2    1    1  0    0    0  	  allocend = main_map->l_addr + ph->p_vaddr + ph->p_memsz;
  4    0    0  2    0    0  0    0    0  	  if (main_map->l_map_end < allocend)
  2    0    0  0    0    0  2    0    0  	    main_map->l_map_end = allocend;
  6    0    0  3    0    0  0    0    0  	  if ((ph->p_flags & PF_X) && allocend > main_map->l_text_end)
  2    0    0  0    0    0  1    0    0  	    main_map->l_text_end = allocend;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        case PT_TLS:
  .    .    .  .    .    .  .    .    .  	if (ph->p_memsz > 0)
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    /* Note that in the case the dynamic linker we duplicate work
  .    .    .  .    .    .  .    .    .  	       here since we read the PT_TLS entry already in
-- line 1223 ----------------------------------------
-- line 1234 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	    main_map->l_tls_initimage = (void *) ph->p_vaddr;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	    /* This image gets the ID one.  */
  .    .    .  .    .    .  .    .    .  	    GL(dl_tls_max_dtv_idx) = main_map->l_tls_modid = 1;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        case PT_GNU_STACK:
  2    1    1  1    0    0  1    0    0  	GL(dl_stack_flags) = ph->p_flags;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        case PT_GNU_RELRO:
  2    0    0  1    0    0  1    0    0  	main_map->l_relro_addr = ph->p_vaddr;
  2    0    0  1    0    0  1    0    0  	main_map->l_relro_size = ph->p_memsz;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Adjust the address of the TLS initialization image in case
  .    .    .  .    .    .  .    .    .       the executable is actually an ET_DYN object.  */
  3    1    1  1    1    1  0    0    0    if (main_map->l_tls_initimage != NULL)
  .    .    .  .    .    .  .    .    .      main_map->l_tls_initimage
  .    .    .  .    .    .  .    .    .        = (char *) main_map->l_tls_initimage + main_map->l_addr;
  2    0    0  0    0    0  0    0    0    if (! main_map->l_map_end)
  .    .    .  .    .    .  .    .    .      main_map->l_map_end = ~0;
  2    0    0  0    0    0  0    0    0    if (! main_map->l_text_end)
  .    .    .  .    .    .  .    .    .      main_map->l_text_end = ~0;
  2    0    0  1    0    0  0    0    0    if (! GL(dl_rtld_map).l_libname && GL(dl_rtld_map).l_name)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* We were invoked directly, so the program might not have a
  .    .    .  .    .    .  .    .    .  	 PT_INTERP.  */
  .    .    .  .    .    .  .    .    .        _dl_rtld_libname.name = GL(dl_rtld_map).l_name;
  .    .    .  .    .    .  .    .    .        /* _dl_rtld_libname.next = NULL;	Already zero.  */
  .    .    .  .    .    .  .    .    .        GL(dl_rtld_map).l_libname =  &_dl_rtld_libname;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      assert (GL(dl_rtld_map).l_libname); /* How else did we get here?  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* If the current libname is different from the SONAME, add the
  .    .    .  .    .    .  .    .    .       latter as well.  */
  2    1    1  0    0    0  0    0    0    if (GL(dl_rtld_map).l_info[DT_SONAME] != NULL
 11    0    0  6    0    0  2    0    0        && strcmp (GL(dl_rtld_map).l_libname->name,
  .    .    .  .    .    .  .    .    .  		 (const char *) D_PTR (&GL(dl_rtld_map), l_info[DT_STRTAB])
  .    .    .  .    .    .  .    .    .  		 + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_val) != 0)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        static struct libname_list newname;
  1    0    0  0    0    0  1    0    0        newname.name = ((char *) D_PTR (&GL(dl_rtld_map), l_info[DT_STRTAB])
  .    .    .  .    .    .  .    .    .  		      + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_ptr);
  1    1    1  0    0    0  1    0    0        newname.next = NULL;
  1    0    0  0    0    0  1    0    0        newname.dont_free = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        assert (GL(dl_rtld_map).l_libname->next == NULL);
  2    0    0  0    0    0  1    0    0        GL(dl_rtld_map).l_libname->next = &newname;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    /* The ld.so must be relocated since otherwise loading audit modules
  .    .    .  .    .    .  .    .    .       will fail since they reuse the very same ld.so.  */
  .    .    .  .    .    .  .    .    .    assert (GL(dl_rtld_map).l_relocated);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0    if (! rtld_is_main)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Extract the contents of the dynamic section for easy access.  */
  .    .    .  .    .    .  .    .    .        elf_get_dynamic_info (main_map, NULL);
  .    .    .  .    .    .  .    .    .        /* Set up our cache of pointers into the hash table.  */
  2    1    1  0    0    0  1    0    0        _dl_setup_hash (main_map);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  0    0    0    if (__builtin_expect (mode, normal) == verify)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* We were called just to verify that this is a dynamic
  .    .    .  .    .    .  .    .    .  	 executable using us as the program interpreter.  Exit with an
  .    .    .  .    .    .  .    .    .  	 error if we were not able to load the binary or no interpreter
  .    .    .  .    .    .  .    .    .  	 is specified (i.e., this is no dynamically linked binary.  */
  .    .    .  .    .    .  .    .    .        if (main_map->l_ld == NULL)
  .    .    .  .    .    .  .    .    .  	_exit (1);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* We allow here some platform specific code.  */
  .    .    .  .    .    .  .    .    .  #ifdef DISTINGUISH_LIB_VERSIONS
  .    .    .  .    .    .  .    .    .        DISTINGUISH_LIB_VERSIONS;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .        _exit (has_interp ? 0 : 2);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  3    1    1  0    0    0  1    1    1    struct link_map **first_preload = &GL(dl_rtld_map).l_next;
  .    .    .  .    .    .  .    .    .    /* Set up the data structures for the system-supplied DSO early,
  .    .    .  .    .    .  .    .    .       so they can influence _dl_init_paths.  */
  .    .    .  .    .    .  .    .    .    setup_vdso (main_map, &first_preload);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef DL_SYSDEP_OSCHECK
  9    1    1  1    0    0  2    0    0    DL_SYSDEP_OSCHECK (_dl_fatal_printf);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Initialize the data structures for the search paths for shared
  .    .    .  .    .    .  .    .    .       objects.  */
  2    1    1  1    0    0  1    0    0    _dl_init_paths (library_path);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Initialize _r_debug.  */
  4    0    0  1    0    0  2    0    0    struct r_debug *r = _dl_debug_initialize (GL(dl_rtld_map).l_addr,
  .    .    .  .    .    .  .    .    .  					    LM_ID_BASE);
  1    0    0  0    0    0  1    0    0    r->r_state = RT_CONSISTENT;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Put the link_map for ourselves on the chain so it can be found by
  .    .    .  .    .    .  .    .    .       name.  Note that at this point the global chain of link maps contains
  .    .    .  .    .    .  .    .    .       exactly one element, which is pointed to by dl_loaded.  */
  2    0    0  1    0    0  0    0    0    if (! GL(dl_rtld_map).l_name)
  .    .    .  .    .    .  .    .    .      /* If not invoked directly, the dynamic linker shared object file was
  .    .    .  .    .    .  .    .    .         found by the PT_INTERP name.  */
  3    1    1  2    0    0  1    0    0      GL(dl_rtld_map).l_name = (char *) GL(dl_rtld_map).l_libname->name;
  4    0    0  1    0    0  1    0    0    GL(dl_rtld_map).l_type = lt_library;
  2    0    0  0    0    0  1    0    0    main_map->l_next = &GL(dl_rtld_map);
  1    0    0  0    0    0  1    0    0    GL(dl_rtld_map).l_prev = main_map;
  1    0    0  1    0    0  0    0    0    ++GL(dl_ns)[LM_ID_BASE]._ns_nloaded;
  1    0    0  1    0    0  0    0    0    ++GL(dl_load_adds);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* If LD_USE_LOAD_BIAS env variable has not been seen, default
  .    .    .  .    .    .  .    .    .       to not using bias for non-prelinked PIEs and libraries
  .    .    .  .    .    .  .    .    .       and using it for executables or prelinked PIEs or libraries.  */
  2    1    1  1    0    0  0    0    0    if (GLRO(dl_use_load_bias) == (ElfW(Addr)) -2)
  5    0    0  1    0    0  1    0    0      GLRO(dl_use_load_bias) = main_map->l_addr == 0 ? -1 : 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Set up the program header information for the dynamic linker
  .    .    .  .    .    .  .    .    .       itself.  It is needed in the dl_iterate_phdr() callbacks.  */
  1    0    0  1    0    0  0    0    0    ElfW(Ehdr) *rtld_ehdr = (ElfW(Ehdr) *) GL(dl_rtld_map).l_map_start;
  .    .    .  .    .    .  .    .    .    ElfW(Phdr) *rtld_phdr = (ElfW(Phdr) *) (GL(dl_rtld_map).l_map_start
  4    0    0  1    0    0  0    0    0  					  + rtld_ehdr->e_phoff);
  2    1    1  0    0    0  1    0    0    GL(dl_rtld_map).l_phdr = rtld_phdr;
  4    0    0  1    1    1  1    1    1    GL(dl_rtld_map).l_phnum = rtld_ehdr->e_phnum;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* PT_GNU_RELRO is usually the last phdr.  */
  .    .    .  .    .    .  .    .    .    size_t cnt = rtld_ehdr->e_phnum;
  2    0    0  0    0    0  0    0    0    while (cnt-- > 0)
  6    0    0  1    1    1  0    0    0      if (rtld_phdr[cnt].p_type == PT_GNU_RELRO)
  .    .    .  .    .    .  .    .    .        {
  2    0    0  1    0    0  1    1    1  	GL(dl_rtld_map).l_relro_addr = rtld_phdr[cnt].p_vaddr;
  2    1    1  1    0    0  1    0    0  	GL(dl_rtld_map).l_relro_size = rtld_phdr[cnt].p_memsz;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Add the dynamic linker to the TLS list if it also uses TLS.  */
  2    0    0  1    0    0  0    0    0    if (GL(dl_rtld_map).l_tls_blocksize != 0)
  .    .    .  .    .    .  .    .    .      /* Assign a module ID.  Do this before loading any audit modules.  */
  .    .    .  .    .    .  .    .    .      GL(dl_rtld_map).l_tls_modid = _dl_next_tls_modid ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* If we have auditing DSOs to load, do it now.  */
  1    1    1  0    0    0  1    0    0    bool need_security_init = true;
  4    0    0  2    0    0  0    0    0    if (__builtin_expect (audit_list != NULL, 0)
  2    0    0  0    0    0  0    0    0        || __builtin_expect (audit_list_string != NULL, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        struct audit_ifaces *last_audit = NULL;
  .    .    .  .    .    .  .    .    .        struct audit_list_iter al_iter;
  .    .    .  .    .    .  .    .    .        audit_list_iter_init (&al_iter);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Since we start using the auditing DSOs right away we need to
  .    .    .  .    .    .  .    .    .  	 initialize the data structures now.  */
  .    .    .  .    .    .  .    .    .        tcbp = init_tls ();
-- line 1387 ----------------------------------------
-- line 1550 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		  afct = afct->next;
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Keep track of the currently loaded modules to count how many
  .    .    .  .    .    .  .    .    .       non-audit modules which use TLS are loaded.  */
  2    0    0  0    0    0  2    0    0    size_t count_modids = _dl_count_modids ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Set up debugging before the debugger is notified for the first time.  */
  .    .    .  .    .    .  .    .    .  #ifdef ELF_MACHINE_DEBUG_SETUP
  .    .    .  .    .    .  .    .    .    /* Some machines (e.g. MIPS) don't use DT_DEBUG in this way.  */
  .    .    .  .    .    .  .    .    .    ELF_MACHINE_DEBUG_SETUP (main_map, r);
  .    .    .  .    .    .  .    .    .    ELF_MACHINE_DEBUG_SETUP (&GL(dl_rtld_map), r);
  .    .    .  .    .    .  .    .    .  #else
  3    0    0  1    0    0  0    0    0    if (main_map->l_info[DT_DEBUG] != NULL)
  .    .    .  .    .    .  .    .    .      /* There is a DT_DEBUG entry in the dynamic section.  Fill it in
  .    .    .  .    .    .  .    .    .         with the run-time address of the r_debug structure  */
  2    0    0  1    0    0  1    0    0      main_map->l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) r;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Fill in the pointer in the dynamic linker's own dynamic section, in
  .    .    .  .    .    .  .    .    .       case you run gdb on the dynamic linker directly.  */
  3    1    1  1    0    0  0    0    0    if (GL(dl_rtld_map).l_info[DT_DEBUG] != NULL)
  .    .    .  .    .    .  .    .    .      GL(dl_rtld_map).l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) r;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We start adding objects.  */
  2    1    1  1    0    0  1    0    0    r->r_state = RT_ADD;
  2    1    1  0    0    0  1    0    0    _dl_debug_state ();
  1    0    0  0    0    0  0    0    0    LIBC_PROBE (init_start, 2, LM_ID_BASE, r);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Auditing checkpoint: we are ready to signal that the initial map
  .    .    .  .    .    .  .    .    .       is being constructed.  */
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (GLRO(dl_naudit) > 0, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        struct audit_ifaces *afct = GLRO(dl_audit);
  .    .    .  .    .    .  .    .    .        for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  if (afct->activity != NULL)
  .    .    .  .    .    .  .    .    .  	    afct->activity (&main_map->l_audit[cnt].cookie, LA_ACT_ADD);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  afct = afct->next;
-- line 1592 ----------------------------------------
-- line 1595 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We have two ways to specify objects to preload: via environment
  .    .    .  .    .    .  .    .    .       variable and via the file /etc/ld.so.preload.  The latter can also
  .    .    .  .    .    .  .    .    .       be used when security is enabled.  */
  .    .    .  .    .    .  .    .    .    assert (*first_preload == NULL);
  .    .    .  .    .    .  .    .    .    struct link_map **preloads = NULL;
  .    .    .  .    .    .  .    .    .    unsigned int npreloads = 0;
  .    .    .  .    .    .  .    .    .  
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (preloadlist != NULL, 0))
  .    .    .  .    .    .  .    .    .      {
  5    1    1  0    0    0  0    0    0        HP_TIMING_NOW (start);
  3    0    0  0    0    0  1    0    0        npreloads += handle_ld_preload (preloadlist, main_map);
  4    0    0  0    0    0  0    0    0        HP_TIMING_NOW (stop);
  .    .    .  .    .    .  .    .    .        HP_TIMING_DIFF (diff, start, stop);
  3    0    0  1    0    0  0    0    0        HP_TIMING_ACCUM_NT (load_time, diff);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* There usually is no ld.so.preload file, it should only be used
  .    .    .  .    .    .  .    .    .       for emergencies and testing.  So the open call etc should usually
  .    .    .  .    .    .  .    .    .       fail.  Using access() on a non-existing file is faster than using
  .    .    .  .    .    .  .    .    .       open().  So we do this first.  If it succeeds we do almost twice
  .    .    .  .    .    .  .    .    .       the work but this does not matter, since it is not for production
  .    .    .  .    .    .  .    .    .       use.  */
  .    .    .  .    .    .  .    .    .    static const char preload_file[] = "/etc/ld.so.preload";
  5    1    1  0    0    0  1    0    0    if (__builtin_expect (__access (preload_file, R_OK) == 0, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Read the contents of the file.  */
  .    .    .  .    .    .  .    .    .        file = _dl_sysdep_read_whole_file (preload_file, &file_size,
  .    .    .  .    .    .  .    .    .  					 PROT_READ | PROT_WRITE);
  .    .    .  .    .    .  .    .    .        if (__builtin_expect (file != MAP_FAILED, 0))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  /* Parse the file.  It contains names of libraries to be loaded,
  .    .    .  .    .    .  .    .    .  	     separated by white spaces or `:'.  It may also contain
-- line 1627 ----------------------------------------
-- line 1688 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	  HP_TIMING_DIFF (diff, start, stop);
  .    .    .  .    .    .  .    .    .  	  HP_TIMING_ACCUM_NT (load_time, diff);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* We don't need the file anymore.  */
  .    .    .  .    .    .  .    .    .  	  __munmap (file, file_size);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  4    0    0  2    0    0  0    0    0    if (__builtin_expect (*first_preload != NULL, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Set up PRELOADS with a vector of the preloaded libraries.  */
  .    .    .  .    .    .  .    .    .        struct link_map *l = *first_preload;
 19    4    4  1    0    0  0    0    0        preloads = __alloca (npreloads * sizeof preloads[0]);
  1    0    0  0    0    0  0    0    0        i = 0;
  .    .    .  .    .    .  .    .    .        do
  .    .    .  .    .    .  .    .    .  	{
  2    0    0  0    0    0  1    0    0  	  preloads[i++] = l;
  1    0    0  1    0    0  0    0    0  	  l = l->l_next;
  2    0    0  0    0    0  0    0    0  	} while (l);
  .    .    .  .    .    .  .    .    .        assert (i == npreloads);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Load all the libraries specified by DT_NEEDED entries.  If LD_PRELOAD
  .    .    .  .    .    .  .    .    .       specified some libraries to load, these are inserted before the actual
  .    .    .  .    .    .  .    .    .       dependencies in the executable's searchlist for symbol resolution.  */
  5    1    1  0    0    0  0    0    0    HP_TIMING_NOW (start);
  8    0    0  0    0    0  1    0    0    _dl_map_object_deps (main_map, preloads, npreloads, mode == trace, 0);
  4    0    0  0    0    0  0    0    0    HP_TIMING_NOW (stop);
  .    .    .  .    .    .  .    .    .    HP_TIMING_DIFF (diff, start, stop);
  2    0    0  1    0    0  0    0    0    HP_TIMING_ACCUM_NT (load_time, diff);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Mark all objects as being in the global scope.  */
 15    0    0  2    0    0  0    0    0    for (i = main_map->l_searchlist.r_nlist; i > 0; )
 20    1    1 10    0    0  0    0    0      main_map->l_searchlist.r_list[--i]->l_global = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Remove _dl_rtld_map from the chain.  */
  3    0    0  2    0    0  1    0    0    GL(dl_rtld_map).l_prev->l_next = GL(dl_rtld_map).l_next;
  3    0    0  1    0    0  0    0    0    if (GL(dl_rtld_map).l_next != NULL)
  1    0    0  0    0    0  1    0    0      GL(dl_rtld_map).l_next->l_prev = GL(dl_rtld_map).l_prev;
  .    .    .  .    .    .  .    .    .  
 16    0    0  0    0    0  0    0    0    for (i = 1; i < main_map->l_searchlist.r_nlist; ++i)
 11    1    1  5    0    0  0    0    0      if (main_map->l_searchlist.r_list[i] == &GL(dl_rtld_map))
  .    .    .  .    .    .  .    .    .        break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    bool rtld_multiple_ref = false;
  .    .    .  .    .    .  .    .    .    if (__builtin_expect (i < main_map->l_searchlist.r_nlist, 1))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Some DT_NEEDED entry referred to the interpreter object itself, so
  .    .    .  .    .    .  .    .    .  	 put it back in the list of visible objects.  We insert it into the
  .    .    .  .    .    .  .    .    .  	 chain in symbol search order because gdb uses the chain's order as
  .    .    .  .    .    .  .    .    .  	 its symbol search order.  */
  2    2    2  0    0    0  1    0    0        rtld_multiple_ref = true;
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  1    0    0        GL(dl_rtld_map).l_prev = main_map->l_searchlist.r_list[i - 1];
  2    0    0  1    0    0  0    0    0        if (__builtin_expect (mode, normal) == normal)
  .    .    .  .    .    .  .    .    .  	{
  2    0    0  0    0    0  1    0    0  	  GL(dl_rtld_map).l_next = (i + 1 < main_map->l_searchlist.r_nlist
  .    .    .  .    .    .  .    .    .  				    ? main_map->l_searchlist.r_list[i + 1]
  3    0    0  0    0    0  0    0    0  				    : NULL);
  .    .    .  .    .    .  .    .    .  #if defined NEED_DL_SYSINFO || defined NEED_DL_SYSINFO_DSO
  3    1    1  1    0    0  0    0    0  	  if (GLRO(dl_sysinfo_map) != NULL
  .    .    .  .    .    .  .    .    .  	      && GL(dl_rtld_map).l_prev->l_next == GLRO(dl_sysinfo_map)
  .    .    .  .    .    .  .    .    .  	      && GL(dl_rtld_map).l_next != GLRO(dl_sysinfo_map))
  .    .    .  .    .    .  .    .    .  	    GL(dl_rtld_map).l_prev = GLRO(dl_sysinfo_map);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	/* In trace mode there might be an invisible object (which we
  .    .    .  .    .    .  .    .    .  	   could not find) after the previous one in the search list.
  .    .    .  .    .    .  .    .    .  	   In this case it doesn't matter much where we put the
  .    .    .  .    .    .  .    .    .  	   interpreter object, so we just initialize the list pointer so
  .    .    .  .    .    .  .    .    .  	   that the assertion below holds.  */
  .    .    .  .    .    .  .    .    .  	GL(dl_rtld_map).l_next = GL(dl_rtld_map).l_prev->l_next;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        assert (GL(dl_rtld_map).l_prev->l_next == GL(dl_rtld_map).l_next);
  2    0    0  0    0    0  1    0    0        GL(dl_rtld_map).l_prev->l_next = &GL(dl_rtld_map);
  3    0    0  1    0    0  0    0    0        if (GL(dl_rtld_map).l_next != NULL)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  assert (GL(dl_rtld_map).l_next->l_prev == GL(dl_rtld_map).l_prev);
  .    .    .  .    .    .  .    .    .  	  GL(dl_rtld_map).l_next->l_prev = &GL(dl_rtld_map);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Now let us see whether all libraries are available in the
  .    .    .  .    .    .  .    .    .       versions we need.  */
  .    .    .  .    .    .  .    .    .    {
  .    .    .  .    .    .  .    .    .      struct version_check_args args;
  4    0    0  0    0    0  1    0    0      args.doexit = mode == normal;
  1    0    0  0    0    0  1    0    0      args.dotrace = mode == trace;
  4    1    1  1    0    0  1    0    0      _dl_receive_error (print_missing_version, version_check_doit, &args);
  .    .    .  .    .    .  .    .    .    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We do not initialize any of the TLS functionality unless any of the
  .    .    .  .    .    .  .    .    .       initial modules uses TLS.  This makes dynamic loading of modules with
  .    .    .  .    .    .  .    .    .       TLS impossible, but to support it requires either eagerly doing setup
  .    .    .  .    .    .  .    .    .       now or lazily doing it later.  Doing it now makes us incompatible with
  .    .    .  .    .    .  .    .    .       an old kernel that can't perform TLS_INIT_TP, even if no TLS is ever
  .    .    .  .    .    .  .    .    .       used.  Trying to do it lazily is too hairy to try when there could be
  .    .    .  .    .    .  .    .    .       multiple threads (from a non-TLS-using libpthread).  */
  2    0    0  1    0    0  1    0    0    bool was_tls_init_tp_called = tls_init_tp_called;
  2    1    1  1    0    0  0    0    0    if (tcbp == NULL)
  2    0    0  0    0    0  2    0    0      tcbp = init_tls ();
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  0    0    0    if (need_security_init)
  .    .    .  .    .    .  .    .    .      /* Initialize security features.  But only if we have not done it
  .    .    .  .    .    .  .    .    .         earlier.  */
  .    .    .  .    .    .  .    .    .      security_init ();
  .    .    .  .    .    .  .    .    .  
  2    0    0  1    0    0  0    0    0    if (__builtin_expect (mode, normal) != normal)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* We were run just to list the shared libraries.  It is
  .    .    .  .    .    .  .    .    .  	 important that we do this before real relocation, because the
  .    .    .  .    .    .  .    .    .  	 functions we call below for output may no longer work properly
  .    .    .  .    .    .  .    .    .  	 after relocation.  */
  .    .    .  .    .    .  .    .    .        struct link_map *l;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK)
-- line 1804 ----------------------------------------
-- line 2021 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        _exit (0);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  3    0    0  1    0    0  0    0    0    if (main_map->l_info[ADDRIDX (DT_GNU_LIBLIST)]
  .    .    .  .    .    .  .    .    .        && ! __builtin_expect (GLRO(dl_profile) != NULL, 0)
  .    .    .  .    .    .  .    .    .        && ! __builtin_expect (GLRO(dl_dynamic_weak), 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        ElfW(Lib) *liblist, *liblistend;
  .    .    .  .    .    .  .    .    .        struct link_map **r_list, **r_listend, *l;
  .    .    .  .    .    .  .    .    .        const char *strtab = (const void *) D_PTR (main_map, l_info[DT_STRTAB]);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        assert (main_map->l_info[VALIDX (DT_GNU_LIBLISTSZ)] != NULL);
-- line 2037 ----------------------------------------
-- line 2071 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	  ++liblist;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (r_list == r_listend && liblist == liblistend)
  .    .    .  .    .    .  .    .    .  	prelinked = true;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
  1    1    1  1    0    0  0    0    0  	_dl_debug_printf ("\nprelink checking: %s\n",
  .    .    .  .    .    .  .    .    .  			  prelinked ? "ok" : "failed");
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Now set up the variable which helps the assembler startup code.  */
  2    1    1  0    0    0  1    0    0    GL(dl_ns)[LM_ID_BASE]._ns_main_searchlist = &main_map->l_searchlist;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Save the information about the original global scope list since
  .    .    .  .    .    .  .    .    .       we need it in the memory handling later.  */
  4    1    1  2    0    0  2    0    0    GLRO(dl_initial_searchlist) = *GL(dl_ns)[LM_ID_BASE]._ns_main_searchlist;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Remember the last search directory added at startup, now that
  .    .    .  .    .    .  .    .    .       malloc will no longer be the one from dl-minimal.c.  */
  2    0    0  1    0    0  1    0    0    GLRO(dl_init_all_dirs) = GL(dl_all_dirs);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Print scope information.  */
  2    0    0  0    0    0  0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_SCOPES, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        _dl_debug_printf ("\nInitial object scopes\n");
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        for (struct link_map *l = main_map; l != NULL; l = l->l_next)
  .    .    .  .    .    .  .    .    .  	_dl_show_scope (l, 0);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0    if (prelinked)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        if (main_map->l_info [ADDRIDX (DT_GNU_CONFLICT)] != NULL)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  ElfW(Rela) *conflict, *conflictend;
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .  	  hp_timing_t start;
  .    .    .  .    .    .  .    .    .  	  hp_timing_t stop;
  .    .    .  .    .    .  .    .    .  #endif
-- line 2112 ----------------------------------------
-- line 2142 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	 the dynamic linker itself.  We do this in reverse order so that copy
  .    .    .  .    .    .  .    .    .  	 relocs of earlier objects overwrite the data written by later
  .    .    .  .    .    .  .    .    .  	 objects.  We do not re-relocate the dynamic linker itself in this
  .    .    .  .    .    .  .    .    .  	 loop because that could result in the GOT entries for functions we
  .    .    .  .    .    .  .    .    .  	 call being changed, and that would break us.  It is safe to relocate
  .    .    .  .    .    .  .    .    .  	 the dynamic linker out of order because it has no copy relocs (we
  .    .    .  .    .    .  .    .    .  	 know that because it is self-contained).  */
  .    .    .  .    .    .  .    .    .  
  3    1    1  1    0    0  0    0    0        int consider_profiling = GLRO(dl_profile) != NULL;
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .        hp_timing_t start;
  .    .    .  .    .    .  .    .    .        hp_timing_t stop;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* If we are profiling we also must do lazy reloaction.  */
  1    0    0  1    0    0  0    0    0        GLRO(dl_lazy) |= consider_profiling;
  .    .    .  .    .    .  .    .    .  
 11    1    1  1    0    0  1    0    0        HP_TIMING_NOW (start);
  .    .    .  .    .    .  .    .    .        unsigned i = main_map->l_searchlist.r_nlist;
 15    1    1  1    1    0  0    0    0        while (i-- > 0)
  .    .    .  .    .    .  .    .    .  	{
 15    0    0 10    1    0  0    0    0  	  struct link_map *l = main_map->l_initfini[i];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* While we are at it, help the memory handling a bit.  We have to
  .    .    .  .    .    .  .    .    .  	     mark some data structures as allocated with the fake malloc()
  .    .    .  .    .    .  .    .    .  	     implementation in ld.so.  */
 10    0    0 10    0    0  0    0    0  	  struct libname_list *lnp = l->l_libname->next;
  .    .    .  .    .    .  .    .    .  
 12    0    0  0    0    0  0    0    0  	  while (__builtin_expect (lnp != NULL, 0))
  .    .    .  .    .    .  .    .    .  	    {
  1    1    1  0    0    0  1    0    0  	      lnp->dont_free = 1;
  1    0    0  1    0    0  0    0    0  	      lnp = lnp->next;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  /* Also allocated with the fake malloc().  */
  5    0    0  5    0    0  0    0    0  	  l->l_free_initfini = 0;
  .    .    .  .    .    .  .    .    .  
 15    0    0  0    0    0  0    0    0  	  if (l != &GL(dl_rtld_map))
 32    0    0  8    3    0  4    0    0  	    _dl_relocate_object (l, l->l_scope, GLRO(dl_lazy) ? RTLD_LAZY : 0,
  .    .    .  .    .    .  .    .    .  				 consider_profiling);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Add object to slot information data if necessasy.  */
 17    0    0  6    1    0  0    0    0  	  if (l->l_tls_blocksize != 0 && tls_init_tp_called)
  3    0    0  0    0    0  1    0    0  	    _dl_add_to_slotinfo (l);
  .    .    .  .    .    .  .    .    .  	}
  4    0    0  0    0    0  0    0    0        HP_TIMING_NOW (stop);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  1    1    0        HP_TIMING_DIFF (relocate_time, start, stop);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Now enable profiling if needed.  Like the previous call,
  .    .    .  .    .    .  .    .    .  	 this has to go here because the calls it makes should use the
  .    .    .  .    .    .  .    .    .  	 rtld versions of the functions (particularly calloc()), but it
  .    .    .  .    .    .  .    .    .  	 needs to have _dl_profile_map set up by the relocator.  */
  2    0    0  1    0    0  0    0    0        if (__builtin_expect (GL(dl_profile_map) != NULL, 0))
  .    .    .  .    .    .  .    .    .  	/* We must prepare the profiling.  */
  .    .    .  .    .    .  .    .    .  	_dl_start_profile ();
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef NONTLS_INIT_TP
  .    .    .  .    .    .  .    .    .  # define NONTLS_INIT_TP do { } while (0)
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  4    1    1  2    2    0  0    0    0    if ((!was_tls_init_tp_called && GL(dl_tls_max_dtv_idx) > 0)
  .    .    .  .    .    .  .    .    .        || count_modids != _dl_count_modids ())
  1    0    0  1    1    0  0    0    0      ++GL(dl_tls_generation);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Now that we have completed relocation, the initializer data
  .    .    .  .    .    .  .    .    .       for the TLS blocks has its final values and we can copy them
  .    .    .  .    .    .  .    .    .       into the main thread's TLS area, which we allocated above.  */
  2    0    0  1    0    0  1    0    0    _dl_allocate_tls_init (tcbp);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* And finally install it for the main thread.  If ld.so itself uses
  .    .    .  .    .    .  .    .    .       TLS we know the thread pointer was initialized earlier.  */
  2    0    0  1    0    0  0    0    0    if (! tls_init_tp_called)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        const char *lossage
  .    .    .  .    .    .  .    .    .  	= TLS_INIT_TP (tcbp, 0);
  .    .    .  .    .    .  .    .    .        if (__builtin_expect (lossage != NULL, 0))
  .    .    .  .    .    .  .    .    .  	_dl_fatal_printf ("cannot set up thread-local storage: %s\n",
  .    .    .  .    .    .  .    .    .  			  lossage);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Make sure no new search directories have been added.  */
  .    .    .  .    .    .  .    .    .    assert (GLRO(dl_init_all_dirs) == GL(dl_all_dirs));
  .    .    .  .    .    .  .    .    .  
  4    2    2  1    0    0  0    0    0    if (! prelinked && rtld_multiple_ref)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* There was an explicit ref to the dynamic linker as a shared lib.
  .    .    .  .    .    .  .    .    .  	 Re-relocate ourselves with user-controlled symbol definitions.
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	 We must do this after TLS initialization in case after this
  .    .    .  .    .    .  .    .    .  	 re-relocation, we might call a user-supplied function
  .    .    .  .    .    .  .    .    .  	 (e.g. calloc from _dl_relocate_object) that uses TLS data.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef HP_TIMING_NONAVAIL
  .    .    .  .    .    .  .    .    .        hp_timing_t start;
  .    .    .  .    .    .  .    .    .        hp_timing_t stop;
  .    .    .  .    .    .  .    .    .        hp_timing_t add;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  5    0    0  0    0    0  0    0    0        HP_TIMING_NOW (start);
  .    .    .  .    .    .  .    .    .        /* Mark the link map as not yet relocated again.  */
  1    0    0  1    0    0  0    0    0        GL(dl_rtld_map).l_relocated = 0;
  5    1    1  1    0    0  1    0    0        _dl_relocate_object (&GL(dl_rtld_map), main_map->l_scope, 0, 0);
  4    0    0  0    0    0  0    0    0        HP_TIMING_NOW (stop);
  .    .    .  .    .    .  .    .    .        HP_TIMING_DIFF (add, start, stop);
  3    0    0  1    0    0  0    0    0        HP_TIMING_ACCUM_NT (relocate_time, add);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Do any necessary cleanups for the startup OS interface code.
  .    .    .  .    .    .  .    .    .       We do these now so that no calls are made after rtld re-relocation
  .    .    .  .    .    .  .    .    .       which might be resolved to different functions than we expect.
  .    .    .  .    .    .  .    .    .       We cannot do this before relocating the other objects because
  .    .    .  .    .    .  .    .    .       _dl_relocate_object might need to call `mprotect' for DT_TEXTREL.  */
  1    0    0  0    0    0  1    0    0    _dl_sysdep_start_cleanup ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .    /* Auditing checkpoint: we have added all objects.  */
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (GLRO(dl_naudit) > 0, 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        struct link_map *head = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
  .    .    .  .    .    .  .    .    .        /* Do not call the functions for any auditing object.  */
  .    .    .  .    .    .  .    .    .        if (head->l_auditing == 0)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  struct audit_ifaces *afct = GLRO(dl_audit);
  .    .    .  .    .    .  .    .    .  	  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
  .    .    .  .    .    .  .    .    .  	    {
-- line 2267 ----------------------------------------
-- line 2271 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	      afct = afct->next;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Notify the debugger all new objects are now ready to go.  We must re-get
  .    .    .  .    .    .  .    .    .       the address since by now the variable might be in another object.  */
  4    0    0  0    0    0  1    0    0    r = _dl_debug_initialize (0, LM_ID_BASE);
  1    1    1  0    0    0  1    0    0    r->r_state = RT_CONSISTENT;
  1    0    0  0    0    0  1    0    0    _dl_debug_state ();
  1    0    0  0    0    0  0    0    0    LIBC_PROBE (init_complete, 2, LM_ID_BASE, r);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if defined USE_LDCONFIG && !defined MAP_COPY
  .    .    .  .    .    .  .    .    .    /* We must munmap() the cache file.  */
  1    0    0  0    0    0  1    0    0    _dl_unload_cache ();
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Once we return, _dl_sysdep_start will invoke
  .    .    .  .    .    .  .    .    .       the DT_INIT functions and then *USER_ENTRY.  */
  8    0    0  7    1    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* This is a little helper function for resolving symbols while
  .    .    .  .    .    .  .    .    .     tracing the binary.  */
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  print_unresolved (int errcode __attribute__ ((unused)), const char *objname,
  .    .    .  .    .    .  .    .    .  		  const char *errstring)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    if (objname[0] == '\0')
-- line 2299 ----------------------------------------
-- line 2449 ----------------------------------------
  .    .    .  .    .    .  .    .    .     Since all of them start with `LD_' we are a bit smarter while finding
  .    .    .  .    .    .  .    .    .     all the entries.  */
  .    .    .  .    .    .  .    .    .  extern char **_environ attribute_hidden;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  process_envvars (enum mode *modep)
  .    .    .  .    .    .  .    .    .  {
  2    0    0  1    0    0  1    1    1    char **runp = _environ;
  .    .    .  .    .    .  .    .    .    char *envline;
  1    0    0  0    0    0  0    0    0    enum mode mode = normal;
  4    1    1  0    0    0  3    0    0    char *debug_output = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* This is the default place for profiling data file.  */
  .    .    .  .    .    .  .    .    .    GLRO(dl_profile_output)
  7    0    0  1    0    0  1    1    1      = &"/var/tmp\0/var/profile"[INTUSE(__libc_enable_secure) ? 9 : 0];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* RHEL 7 specific change:
  .    .    .  .    .    .  .    .    .       Without the tunables farmework we simulate tunables only for
  .    .    .  .    .    .  .    .    .       use with enabling transactional memory.  */
  2    0    0  0    0    0  1    1    1    _dl_process_tunable_env_entries ();
  .    .    .  .    .    .  .    .    .  
 15    0    0  3    0    0  3    0    0    while ((envline = _dl_next_ld_env_entry (&runp)) != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        size_t len = 0;
  .    .    .  .    .    .  .    .    .  
105    1    1 21    0    0  0    0    0        while (envline[len] != '\0' && envline[len] != '=')
 19    0    0  0    0    0  0    0    0  	++len;
  .    .    .  .    .    .  .    .    .  
  4    0    0  0    0    0  0    0    0        if (envline[len] != '=')
  .    .    .  .    .    .  .    .    .  	/* This is a "LD_" variable at the end of the string without
  .    .    .  .    .    .  .    .    .  	   a '=' character.  Ignore it since otherwise we will access
  .    .    .  .    .    .  .    .    .  	   invalid memory below.  */
  .    .    .  .    .    .  .    .    .  	continue;
  .    .    .  .    .    .  .    .    .  
 16    0    0  2    1    1  0    0    0        switch (len)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	case 4:
  .    .    .  .    .    .  .    .    .  	  /* Warning level, verbose or not.  */
  .    .    .  .    .    .  .    .    .  	  if (memcmp (envline, "WARN", 4) == 0)
  .    .    .  .    .    .  .    .    .  	    GLRO(dl_verbose) = envline[5] != '\0';
  .    .    .  .    .    .  .    .    .  	  break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	case 5:
-- line 2492 ----------------------------------------
-- line 2497 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  if (memcmp (envline, "AUDIT", 5) == 0)
  .    .    .  .    .    .  .    .    .  	    audit_list_string = &envline[6];
  .    .    .  .    .    .  .    .    .  	  break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	case 7:
  .    .    .  .    .    .  .    .    .  	  /* Print information about versions.  */
  6    1    1  0    0    0  1    0    0  	  if (memcmp (envline, "VERBOSE", 7) == 0)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      version_info = envline[8] != '\0';
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* List of objects to be preloaded.  */
  6    1    1  0    0    0  1    0    0  	  if (memcmp (envline, "PRELOAD", 7) == 0)
  .    .    .  .    .    .  .    .    .  	    {
  3    0    0  0    0    0  1    0    0  	      preloadlist = &envline[8];
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Which shared object shall be profiled.  */
  .    .    .  .    .    .  .    .    .  	  if (memcmp (envline, "PROFILE", 7) == 0 && envline[8] != '\0')
  .    .    .  .    .    .  .    .    .  	    GLRO(dl_profile) = &envline[8];
  .    .    .  .    .    .  .    .    .  	  break;
  .    .    .  .    .    .  .    .    .  
-- line 2522 ----------------------------------------
-- line 2551 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	  /* Path where the binary is found.  */
  .    .    .  .    .    .  .    .    .  	  if (!INTUSE(__libc_enable_secure)
  .    .    .  .    .    .  .    .    .  	      && memcmp (envline, "ORIGIN_PATH", 11) == 0)
  .    .    .  .    .    .  .    .    .  	    GLRO(dl_origin_path) = &envline[12];
  .    .    .  .    .    .  .    .    .  	  break;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	case 12:
  .    .    .  .    .    .  .    .    .  	  /* The library search path.  */
  4    1    1  2    0    0  0    0    0  	  if (!__libc_enable_secure
  6    1    1  0    0    0  1    0    0  	      && memcmp (envline, "LIBRARY_PATH", 12) == 0)
  .    .    .  .    .    .  .    .    .  	    {
  3    0    0  0    0    0  1    0    0  	      library_path = &envline[13];
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Where to place the profiling data file.  */
  .    .    .  .    .    .  .    .    .  	  if (memcmp (envline, "DEBUG_OUTPUT", 12) == 0)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      debug_output = &envline[13];
  .    .    .  .    .    .  .    .    .  	      break;
-- line 2570 ----------------------------------------
-- line 2624 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* The caller wants this information.  */
  .    .    .  .    .    .  .    .    .    *modep = mode;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Extra security for SUID binaries.  Remove all dangerous environment
  .    .    .  .    .    .  .    .    .       variables.  */
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        static const char unsecure_envvars[] =
  .    .    .  .    .    .  .    .    .  #ifdef EXTRA_UNSECURE_ENVVARS
  .    .    .  .    .    .  .    .    .  	EXTRA_UNSECURE_ENVVARS
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  	UNSECURE_ENVVARS;
  .    .    .  .    .    .  .    .    .        const char *nextp;
  .    .    .  .    .    .  .    .    .  
-- line 2640 ----------------------------------------
-- line 2654 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (mode != normal)
  .    .    .  .    .    .  .    .    .  	_exit (5);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    /* If we have to run the dynamic linker in debugging mode and the
  .    .    .  .    .    .  .    .    .       LD_DEBUG_OUTPUT environment variable is given, we write the debug
  .    .    .  .    .    .  .    .    .       messages to this file.  */
  3    1    1  1    0    0  0    0    0    else if (any_debug && debug_output != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .  #ifdef O_NOFOLLOW
  .    .    .  .    .    .  .    .    .        const int flags = O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW;
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .        const int flags = O_WRONLY | O_APPEND | O_CREAT;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .        size_t name_len = strlen (debug_output);
  .    .    .  .    .    .  .    .    .        char buf[name_len + 12];
-- line 2670 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-addr.c
--------------------------------------------------------------------------------
Ir     I1mr ILmr Dr    D1mr DLmr Dw D1mw DLmw 

-- line 22 ----------------------------------------
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  static inline void
     .    .    .     .    .    .  .    .    .  __attribute ((always_inline))
     .    .    .     .    .    .  .    .    .  determine_info (const ElfW(Addr) addr, struct link_map *match, Dl_info *info,
     .    .    .     .    .    .  .    .    .  		struct link_map **mapp, const ElfW(Sym) **symbolp)
     .    .    .     .    .    .  .    .    .  {
     .    .    .     .    .    .  .    .    .    /* Now we know what object the address lies in.  */
     2    1    1     1    0    0  1    0    0    info->dli_fname = match->l_name;
     1    1    1     0    0    0  1    0    0    info->dli_fbase = (void *) match->l_map_start;
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .    /* If this is the main program the information is incomplete.  */
     2    0    0     1    0    0  0    0    0    if (__builtin_expect (match->l_name[0], 'a') == '\0'
     .    .    .     .    .    .  .    .    .        && match->l_type == lt_executable)
     .    .    .     .    .    .  .    .    .      info->dli_fname = _dl_argv[0];
     .    .    .     .    .    .  .    .    .  
     1    0    0     1    0    0  0    0    0    const ElfW(Sym) *symtab
     1    0    0     1    0    0  0    0    0      = (const ElfW(Sym) *) D_PTR (match, l_info[DT_SYMTAB]);
     3    0    0     2    0    0  1    0    0    const char *strtab = (const char *) D_PTR (match, l_info[DT_STRTAB]);
     .    .    .     .    .    .  .    .    .  
     2    0    0     2    0    0  0    0    0    ElfW(Word) strtabsize = match->l_info[DT_STRSZ]->d_un.d_val;
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .    const ElfW(Sym) *matchsym = NULL;
     2    0    0     1    1    0  0    0    0    if (match->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM
     .    .    .     .    .    .  .    .    .  		    + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] != NULL)
     .    .    .     .    .    .  .    .    .      {
     .    .    .     .    .    .  .    .    .        /* We look at all symbol table entries referenced by the hash
     .    .    .     .    .    .  .    .    .  	 table.  */
 2,029    1    1     2    0    0  0    0    0        for (Elf_Symndx bucket = 0; bucket < match->l_nbuckets; ++bucket)
     .    .    .     .    .    .  .    .    .  	{
 1,011    0    0 1,011   58    5  0    0    0  	  Elf32_Word symndx = match->l_gnu_buckets[bucket];
 2,022    0    0     0    0    0  0    0    0  	  if (symndx != 0)
     .    .    .     .    .    .  .    .    .  	    {
 4,963    0    0   909    0    0  0    0    0  	      const Elf32_Word *hasharr = &match->l_gnu_chain_zero[symndx];
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  	      do
     .    .    .     .    .    .  .    .    .  		{
     .    .    .     .    .    .  .    .    .  		  /* The hash table never references local symbols so
     .    .    .     .    .    .  .    .    .  		     we can omit that test here.  */
11,180    1    1 2,236  485  407  0    0    0  		  if ((symtab[symndx].st_shndx != SHN_UNDEF
     .    .    .     .    .    .  .    .    .  		       || symtab[symndx].st_value != 0)
 8,944    0    0 2,236    0    0  0    0    0  		      && ELFW(ST_TYPE) (symtab[symndx].st_info) != STT_TLS
16,335    0    0 5,124  351  281  0    0    0  		      && DL_ADDR_SYM_MATCH (match, &symtab[symndx],
     .    .    .     .    .    .  .    .    .  					    matchsym, addr)
     .    .    .     .    .    .  .    .    .  		      && symtab[symndx].st_name < strtabsize)
     .    .    .     .    .    .  .    .    .  		    matchsym = (ElfW(Sym) *) &symtab[symndx];
     .    .    .     .    .    .  .    .    .  
 2,236    0    0     0    0    0  0    0    0  		  ++symndx;
     .    .    .     .    .    .  .    .    .  		}
 7,719    1    1 2,236  137   46  0    0    0  	      while ((*hasharr++ & 1u) == 0);
     .    .    .     .    .    .  .    .    .  	    }
     .    .    .     .    .    .  .    .    .  	}
     .    .    .     .    .    .  .    .    .      }
     .    .    .     .    .    .  .    .    .    else
     .    .    .     .    .    .  .    .    .      {
     .    .    .     .    .    .  .    .    .        const ElfW(Sym) *symtabend;
     .    .    .     .    .    .  .    .    .        if (match->l_info[DT_HASH] != NULL)
     .    .    .     .    .    .  .    .    .  	symtabend = (symtab
-- line 79 ----------------------------------------
-- line 91 ----------------------------------------
     .    .    .     .    .    .  .    .    .  	    && ELFW(ST_TYPE) (symtab->st_info) != STT_TLS
     .    .    .     .    .    .  .    .    .  	    && (symtab->st_shndx != SHN_UNDEF
     .    .    .     .    .    .  .    .    .  		|| symtab->st_value != 0)
     .    .    .     .    .    .  .    .    .  	    && DL_ADDR_SYM_MATCH (match, symtab, matchsym, addr)
     .    .    .     .    .    .  .    .    .  	    && symtab->st_name < strtabsize)
     .    .    .     .    .    .  .    .    .  	  matchsym = (ElfW(Sym) *) symtab;
     .    .    .     .    .    .  .    .    .      }
     .    .    .     .    .    .  .    .    .  
     3    0    0     1    1    0  0    0    0    if (mapp)
     1    0    0     0    0    0  1    1    0      *mapp = match;
     3    0    0     1    0    0  0    0    0    if (symbolp)
     .    .    .     .    .    .  .    .    .      *symbolp = matchsym;
     .    .    .     .    .    .  .    .    .  
     2    0    0     0    0    0  0    0    0    if (matchsym)
     .    .    .     .    .    .  .    .    .      {
     .    .    .     .    .    .  .    .    .        /* We found a symbol close by.  Fill in its name and exact
     .    .    .     .    .    .  .    .    .  	 address.  */
     .    .    .     .    .    .  .    .    .        lookup_t matchl = LOOKUP_VALUE (match);
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .        info->dli_sname = strtab + matchsym->st_name;
     .    .    .     .    .    .  .    .    .        info->dli_saddr = DL_SYMBOL_ADDRESS (matchl, matchsym);
     .    .    .     .    .    .  .    .    .      }
     .    .    .     .    .    .  .    .    .    else
     .    .    .     .    .    .  .    .    .      {
     .    .    .     .    .    .  .    .    .        /* No symbol matches.  We return only the containing object.  */
     1    1    1     0    0    0  1    1    0        info->dli_sname = NULL;
     1    0    0     0    0    0  1    0    0        info->dli_saddr = NULL;
     .    .    .     .    .    .  .    .    .      }
     .    .    .     .    .    .  .    .    .  }
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  int
     .    .    .     .    .    .  .    .    .  internal_function
     .    .    .     .    .    .  .    .    .  _dl_addr (const void *address, Dl_info *info,
     .    .    .     .    .    .  .    .    .  	  struct link_map **mapp, const ElfW(Sym) **symbolp)
    11    2    2     0    0    0  8    0    0  {
     .    .    .     .    .    .  .    .    .    const ElfW(Addr) addr = DL_LOOKUP_ADDRESS (address);
     .    .    .     .    .    .  .    .    .    int result = 0;
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .    /* Protect against concurrent loads and unloads.  */
     3    0    0     2    0    0  1    0    0    __rtld_lock_lock_recursive (GL(dl_load_lock));
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .    /* Find the highest-addressed object that ADDRESS is not below.  */
     6    0    0     2    0    0  0    0    0    for (Lmid_t ns = 0; ns < GL(dl_nns); ++ns)
    13    1    1     4    0    0  0    0    0      for (struct link_map *l = GL(dl_ns)[ns]._ns_loaded; l; l = l->l_next)
    20    1    1     8    0    0  0    0    0        if (addr >= l->l_map_start && addr < l->l_map_end
     2    0    0     1    0    0  0    0    0  	  && (l->l_contiguous || _dl_addr_inside_object (l, addr)))
     .    .    .     .    .    .  .    .    .  	{
     .    .    .     .    .    .  .    .    .  	  determine_info (addr, l, info, mapp, symbolp);
     2    0    0     0    0    0  0    0    0  	  result = 1;
     .    .    .     .    .    .  .    .    .  	  goto out;
     .    .    .     .    .    .  .    .    .  	}
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .   out:
     3    0    0     2    2    0  1    1    0    __rtld_lock_unlock_recursive (GL(dl_load_lock));
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .    return result;
     9    0    0     7    0    0  0    0    0  }
     .    .    .     .    .    .  .    .    .  libc_hidden_def (_dl_addr)
     .    .    .     .    .    .  .    .    .  
     .    .    .     .    .    .  .    .    .  /* Return non-zero if ADDR lies within one of L's segments.  */
     .    .    .     .    .    .  .    .    .  int
     .    .    .     .    .    .  .    .    .  internal_function
     .    .    .     .    .    .  .    .    .  _dl_addr_inside_object (struct link_map *l, const ElfW(Addr) addr)
     .    .    .     .    .    .  .    .    .  {
     .    .    .     .    .    .  .    .    .    int n = l->l_phnum;
-- line 156 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-strchr.S
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 30 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	   and (more important)
 .    .    .  .    .    .  .    .    .  	   2. we process in the main loop 64 bit in one step although
 .    .    .  .    .    .  .    .    .  	      we don't know the end of the string.  But accessing at
 .    .    .  .    .    .  .    .    .  	      8-byte alignment guarantees that we never access illegal
 .    .    .  .    .    .  .    .    .  	      memory if this would not also be done by the trivial
 .    .    .  .    .    .  .    .    .  	      implementation (this is because all processor inherent
 .    .    .  .    .    .  .    .    .  	      boundaries are multiples of 8).  */
 .    .    .  .    .    .  .    .    .  
13    1    1  0    0    0  0    0    0  	movq	%rdi, %rdx
13    0    0  0    0    0  0    0    0  	andl	$7, %edx	/* Mask alignment bits  */
13    0    0  0    0    0  0    0    0  	movq	%rdi, %rax	/* duplicate destination.  */
13    0    0  0    0    0  0    0    0  	jz	1f		/* aligned => start loop */
10    0    0  0    0    0  0    0    0  	neg	%edx
10    0    0  0    0    0  0    0    0  	addl	$8, %edx	/* Align to 8 bytes.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Search the first bytes directly.  */
41    0    0 41    4    4  0    0    0  0:	movb	(%rax), %cl	/* load byte  */
41    0    0  0    0    0  0    0    0  	cmpb	%cl,%sil	/* compare byte.  */
41    0    0  0    0    0  0    0    0  	je	6f		/* target found */
41    0    0  0    0    0  0    0    0  	testb	%cl,%cl		/* is byte NUL? */
41    0    0  0    0    0  0    0    0  	je	7f		/* yes => return NULL */
41    0    0  0    0    0  0    0    0  	incq	%rax		/* increment pointer */
41    0    0  0    0    0  0    0    0  	decl	%edx
41    0    0  0    0    0  0    0    0  	jnz	0b
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  1:
 .    .    .  .    .    .  .    .    .  	/* At the moment %rsi contains C.  What we need for the
 .    .    .  .    .    .  .    .    .  	   algorithm is C in all bytes of the register.  Avoid
 .    .    .  .    .    .  .    .    .  	   operations on 16 bit words because these require an
 .    .    .  .    .    .  .    .    .  	   prefix byte (and one more cycle).  */
 .    .    .  .    .    .  .    .    .  	/* Populate 8 bit data to full 64-bit.  */
13    1    1  0    0    0  0    0    0  	movabs	$0x0101010101010101,%r9
13    0    0  0    0    0  0    0    0  	movzbl	%sil,%edx
13    0    0  0    0    0  0    0    0  	imul	%rdx,%r9
 .    .    .  .    .    .  .    .    .  
26    0    0  0    0    0  0    0    0  	movq $0xfefefefefefefeff, %r8 /* Save magic.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .        /* We exit the loop if adding MAGIC_BITS to LONGWORD fails to
 .    .    .  .    .    .  .    .    .  	 change any of the hole bits of LONGWORD.
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	 1) Is this safe?  Will it catch all the zero bytes?
 .    .    .  .    .    .  .    .    .  	 Suppose there is a byte with all zeros.  Any carry bits
 .    .    .  .    .    .  .    .    .  	 propagating from its left will fall into the hole at its
 .    .    .  .    .    .  .    .    .  	 least significant bit and stop.  Since there will be no
-- line 74 ----------------------------------------
-- line 90 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	 Good point.  So what we do is XOR LONGWORD with a longword,
 .    .    .  .    .    .  .    .    .  	 each of whose bytes is C.  This turns each byte that is C
 .    .    .  .    .    .  .    .    .  	 into a zero.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	.p2align 4
 .    .    .  .    .    .  .    .    .  4:
 .    .    .  .    .    .  .    .    .  	/* Main Loop is unrolled 4 times.  */
 .    .    .  .    .    .  .    .    .  	/* First unroll.  */
15    0    0 15    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
15    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
15    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
15    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* XOR with qword c|...|c => bytes of str == c
 .    .    .  .    .    .  .    .    .  				   are now 0 */
15    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
15    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
15    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
15    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
15    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
15    1    1  0    0    0  0    0    0  	jnz 3f			/* found c => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* The quadword we looked at does not contain the value we're looking
 .    .    .  .    .    .  .    .    .  	   for.  Let's search now whether we have reached the end of the
 .    .    .  .    .    .  .    .    .  	   string.  */
14    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* restore original dword without reload */
14    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
14    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
14    0    0  0    0    0  0    0    0  	jnc 7f			/* highest byte is NUL => return NULL */
14    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
14    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
14    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
14    0    0  0    0    0  0    0    0  	jnz 7f			/* found NUL => return NULL */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Second unroll.  */
13    0    0 13    1    1  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
13    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
13    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
13    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* XOR with qword c|...|c => bytes of str == c
 .    .    .  .    .    .  .    .    .  				   are now 0 */
13    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
13    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
13    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
13    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
13    1    1  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
13    0    0  0    0    0  0    0    0  	jnz 3f			/* found c => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* The quadword we looked at does not contain the value we're looking
 .    .    .  .    .    .  .    .    .  	   for.  Let's search now whether we have reached the end of the
 .    .    .  .    .    .  .    .    .  	   string.  */
13    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* restore original dword without reload */
13    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
13    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
13    0    0  0    0    0  0    0    0  	jnc 7f			/* highest byte is NUL => return NULL */
13    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
13    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
13    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
13    0    0  0    0    0  0    0    0  	jnz 7f			/* found NUL => return NULL */
 .    .    .  .    .    .  .    .    .  	/* Third unroll.  */
 8    0    0  8    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
 8    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
 8    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
 8    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* XOR with qword c|...|c => bytes of str == c
 .    .    .  .    .    .  .    .    .  				   are now 0 */
 8    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
 8    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
 8    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
 8    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
 8    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
 8    0    0  0    0    0  0    0    0  	jnz 3f			/* found c => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* The quadword we looked at does not contain the value we're looking
 .    .    .  .    .    .  .    .    .  	   for.  Let's search now whether we have reached the end of the
 .    .    .  .    .    .  .    .    .  	   string.  */
 8    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* restore original dword without reload */
 8    1    1  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
 8    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
 8    0    0  0    0    0  0    0    0  	jnc 7f			/* highest byte is NUL => return NULL */
 7    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
 7    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
 7    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
 7    0    0  0    0    0  0    0    0  	jnz 7f			/* found NUL => return NULL */
 .    .    .  .    .    .  .    .    .  	/* Fourth unroll.  */
 5    0    0  5    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
 5    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
 5    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
 5    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* XOR with qword c|...|c => bytes of str == c
 .    .    .  .    .    .  .    .    .  				   are now 0 */
 5    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
 5    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
 5    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
 5    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
 5    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
 5    0    0  0    0    0  0    0    0  	jnz 3f			/* found c => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* The quadword we looked at does not contain the value we're looking
 .    .    .  .    .    .  .    .    .  	   for.  Let's search now whether we have reached the end of the
 .    .    .  .    .    .  .    .    .  	   string.  */
 5    0    0  0    0    0  0    0    0  	xorq %r9, %rcx		/* restore original dword without reload */
 5    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
 5    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
 5    0    0  0    0    0  0    0    0  	jnc 7f			/* highest byte is NUL => return NULL */
 4    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
 4    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
 4    1    1  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
 4    0    0  0    0    0  0    0    0  	jz 4b			/* no NUL found => restart loop */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  7:	/* Return NULL.  */
12    0    0  0    0    0  0    0    0  	xorl %eax, %eax
12    0    0 12    0    0  0    0    0  	retq
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* We now scan for the byte in which the character was matched.
 .    .    .  .    .    .  .    .    .  	   But we have to take care of the case that a NUL char is
 .    .    .  .    .    .  .    .    .  	   found before this in the dword.  Note that we XORed %rcx
 .    .    .  .    .    .  .    .    .  	   with the byte we're looking for, therefore the tests below look
 .    .    .  .    .    .  .    .    .  	   reversed.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	.p2align 4		/* Align, it's a jump target.  */
 1    0    0  0    0    0  0    0    0  3:	movq	%r9,%rdx	/* move to %rdx so that we can access bytes */
 1    0    0  0    0    0  0    0    0  	subq	$8,%rax		/* correct pointer increment.  */
 1    0    0  0    0    0  0    0    0  	testb %cl, %cl		/* is first byte C? */
 1    0    0  0    0    0  0    0    0  	jz 6f			/* yes => return pointer */
 .    .    .  .    .    .  .    .    .  	cmpb %dl, %cl		/* is first byte NUL? */
 .    .    .  .    .    .  .    .    .  	je 7b			/* yes => return NULL */
 .    .    .  .    .    .  .    .    .  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	testb %ch, %ch		/* is second byte C? */
 .    .    .  .    .    .  .    .    .  	jz 6f			/* yes => return pointer */
 .    .    .  .    .    .  .    .    .  	cmpb %dl, %ch		/* is second byte NUL? */
 .    .    .  .    .    .  .    .    .  	je 7b			/* yes => return NULL? */
-- line 244 ----------------------------------------
-- line 275 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	jz 6f			/* yes => return pointer */
 .    .    .  .    .    .  .    .    .  	cmpb %dl, %cl		/* is seventh byte NUL? */
 .    .    .  .    .    .  .    .    .  	je 7b			/* yes => return NULL */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* It must be in the eigth byte and it cannot be NUL.  */
 .    .    .  .    .    .  .    .    .  	incq %rax
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  6:
 1    1    1  0    0    0  0    0    0  	nop
 1    0    0  1    0    0  0    0    0  	retq
 .    .    .  .    .    .  .    .    .  END (strchr)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  weak_alias (strchr, index)
 .    .    .  .    .    .  .    .    .  libc_hidden_builtin_def (strchr)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-lookup.c
--------------------------------------------------------------------------------
Ir     I1mr ILmr Dr    D1mr DLmr Dw    D1mw DLmw 

-- line 69 ----------------------------------------
     .    .    .     .    .    .     .    .    .  #endif
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  /* Inner part of the lookup functions.  We return a value > 0 if we
     .    .    .     .    .    .     .    .    .     found the symbol, the value 0 if nothing is found and < 0 if
     .    .    .     .    .    .     .    .    .     something bad happened.  */
     .    .    .     .    .    .     .    .    .  static int
     .    .    .     .    .    .     .    .    .  __attribute_noinline__
 1,640    1    1   615    0    0 1,025    0    0  do_lookup_x (const char *undef_name, uint_fast32_t new_hash,
     .    .    .     .    .    .     .    .    .  	     unsigned long int *old_hash, const ElfW(Sym) *ref,
     .    .    .     .    .    .     .    .    .  	     struct sym_val *result, struct r_scope_elem *scope, size_t i,
     .    .    .     .    .    .     .    .    .  	     const struct r_found_version *const version, int flags,
     .    .    .     .    .    .     .    .    .  	     struct link_map *skip, int type_class, struct link_map *undef_map)
 2,460    2    2   410    0    0 1,435   16   10  {
   205    0    0   205    1    0     0    0    0    size_t n = scope->r_nlist;
     .    .    .     .    .    .     .    .    .    /* Make sure we read the value before proceeding.  Otherwise we
     .    .    .     .    .    .     .    .    .       might use r_list pointing to the initial scope and r_nlist being
     .    .    .     .    .    .     .    .    .       the value after a resize.  That is the only path in dl-open.c not
     .    .    .     .    .    .     .    .    .       protected by GSCOPE.  A read barrier here might be to expensive.  */
   205    0    0     0    0    0     0    0    0    __asm volatile ("" : "+r" (n), "+m" (scope->r_list));
   205    0    0   205    0    0     0    0    0    struct link_map **list = scope->r_list;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    do
     .    .    .     .    .    .     .    .    .      {
     .    .    .     .    .    .     .    .    .        /* These variables are used in the nested function.  */
     .    .    .     .    .    .     .    .    .        Elf_Symndx symidx;
   826    0    0     0    0    0   826    0    0        int num_versions = 0;
   826    1    1     0    0    0   826    0    0        const ElfW(Sym) *versioned_sym = NULL;
     .    .    .     .    .    .     .    .    .  
 2,478    0    0 1,652   16    0   826    0    0        const struct link_map *map = list[i]->l_real;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* Here come the extra test needed for `_dl_lookup_symbol_skip'.  */
 1,652    0    0     0    0    0     0    0    0        if (map == skip)
     .    .    .     .    .    .     .    .    .  	continue;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* Don't search the executable when resolving a copy reloc.  */
 1,676    0    0   838    0    0     0    0    0        if ((type_class & ELF_RTYPE_CLASS_COPY) && map->l_type == lt_executable)
     .    .    .     .    .    .     .    .    .  	continue;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* Do not look into objects which are going to be removed.  */
 1,646    0    0   823    9    0     0    0    0        if (map->l_removed)
     .    .    .     .    .    .     .    .    .  	continue;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* Print some debugging info if wanted.  */
 1,646    1    1   823    1    0     0    0    0        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_SYMBOLS, 0))
     .    .    .     .    .    .     .    .    .  	_dl_debug_printf ("symbol=%s;  lookup in file=%s [%lu]\n",
     .    .    .     .    .    .     .    .    .  			  undef_name,
     .    .    .     .    .    .     .    .    .  			  map->l_name[0] ? map->l_name : rtld_progname,
     .    .    .     .    .    .     .    .    .  			  map->l_ns);
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* If the hash table is empty there is nothing to do here.  */
 2,469    0    0   823    4    0     0    0    0        if (map->l_nbuckets == 0)
     .    .    .     .    .    .     .    .    .  	continue;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* The tables for this map.  */
 1,646    0    0 1,646   22    0     0    0    0        const ElfW(Sym) *symtab = (const void *) D_PTR (map, l_info[DT_SYMTAB]);
 2,469    0    0 1,646    8    0   823    0    0        const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* Nested routine to check whether the symbol matches.  */
     .    .    .     .    .    .     .    .    .        const ElfW(Sym) *
     .    .    .     .    .    .     .    .    .        __attribute_noinline__
     .    .    .     .    .    .     .    .    .        check_match (const ElfW(Sym) *sym)
 3,829    1    1     0    0    0 2,188    9    7        {
 1,094    0    0   547  126   90     0    0    0  	unsigned int stt = ELFW(ST_TYPE) (sym->st_info);
     .    .    .     .    .    .     .    .    .  	assert (ELF_RTYPE_CLASS_PLT == 1);
 2,188    1    1   776   23   21     0    0    0  	if (__builtin_expect ((sym->st_value == 0 /* No value.  */
     .    .    .     .    .    .     .    .    .  			       && stt != STT_TLS)
   687    0    0   229    0    0     0    0    0  			      || (type_class & (sym->st_shndx == SHN_UNDEF)),
     .    .    .     .    .    .     .    .    .  			      0))
     .    .    .     .    .    .     .    .    .  	  return NULL;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	/* Ignore all but STT_NOTYPE, STT_OBJECT, STT_FUNC,
     .    .    .     .    .    .     .    .    .  	   STT_COMMON, STT_TLS, and STT_GNU_IFUNC since these are no
     .    .    .     .    .    .     .    .    .  	   code/data definitions.  */
     .    .    .     .    .    .     .    .    .  #define ALLOWED_STT \
     .    .    .     .    .    .     .    .    .  	((1 << STT_NOTYPE) | (1 << STT_OBJECT) | (1 << STT_FUNC) \
     .    .    .     .    .    .     .    .    .  	 | (1 << STT_COMMON) | (1 << STT_TLS) | (1 << STT_GNU_IFUNC))
   687    0    0   229    0    0   229   10    7  	if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
     .    .    .     .    .    .     .    .    .  	  return NULL;
     .    .    .     .    .    .     .    .    .  
 1,412    0    0   706    0    0   159    0    0  	if (sym != ref && strcmp (strtab + sym->st_name, undef_name))
     .    .    .     .    .    .     .    .    .  	  /* Not the symbol we are looking for.  */
     .    .    .     .    .    .     .    .    .  	  return NULL;
     .    .    .     .    .    .     .    .    .  
   396    0    0   396    8    0     0    0    0  	const ElfW(Half) *verstab = map->l_versyms;
   594    1    1   198    0    0     0    0    0  	if (version != NULL)
     .    .    .     .    .    .     .    .    .  	  {
   392    0    0     0    0    0     0    0    0  	    if (__builtin_expect (verstab == NULL, 0))
     .    .    .     .    .    .     .    .    .  	      {
     .    .    .     .    .    .     .    .    .  		/* We need a versioned symbol but haven't found any.  If
     .    .    .     .    .    .     .    .    .  		   this is the object which is referenced in the verneed
     .    .    .     .    .    .     .    .    .  		   entry it is a bug in the library since a symbol must
     .    .    .     .    .    .     .    .    .  		   not simply disappear.
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  		   It would also be a bug in the object since it means that
     .    .    .     .    .    .     .    .    .  		   the list of required versions is incomplete and so the
-- line 165 ----------------------------------------
-- line 168 ----------------------------------------
     .    .    .     .    .    .     .    .    .  			|| ! _dl_name_match_p (version->filename, map));
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  		/* Otherwise we accept the symbol.  */
     .    .    .     .    .    .     .    .    .  	      }
     .    .    .     .    .    .     .    .    .  	    else
     .    .    .     .    .    .     .    .    .  	      {
     .    .    .     .    .    .     .    .    .  		/* We can match the version information or use the
     .    .    .     .    .    .     .    .    .  		   default one if it is not hidden.  */
   392    0    0   392   58   30     0    0    0  		ElfW(Half) ndx = verstab[symidx] & 0x7fff;
 1,568    1    1   588   16    0     0    0    0  		if ((map->l_versions[ndx].hash != version->hash
 1,358    0    0   388    1    0   194    0    0  		     || strcmp (map->l_versions[ndx].name, version->name))
    10    0    0     2    0    0     0    0    0  		    && (version->hidden || map->l_versions[ndx].hash
     .    .    .     .    .    .     .    .    .  			|| (verstab[symidx] & 0x8000)))
     .    .    .     .    .    .     .    .    .  		  /* It's not the version we want.  */
     .    .    .     .    .    .     .    .    .  		  return NULL;
     .    .    .     .    .    .     .    .    .  	      }
     .    .    .     .    .    .     .    .    .  	  }
     .    .    .     .    .    .     .    .    .  	else
     .    .    .     .    .    .     .    .    .  	  {
     .    .    .     .    .    .     .    .    .  	    /* No specific version is selected.  There are two ways we
-- line 187 ----------------------------------------
-- line 197 ----------------------------------------
     .    .    .     .    .    .     .    .    .  	       there is no problem at all: we simply use the symbol if it
     .    .    .     .    .    .     .    .    .  	       is defined.
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	       These two lookups need to be handled differently if the
     .    .    .     .    .    .     .    .    .  	       library defines versions.  In the case of the old
     .    .    .     .    .    .     .    .    .  	       unversioned application the oldest (default) version
     .    .    .     .    .    .     .    .    .  	       should be used.  In case of a dlsym() call the latest and
     .    .    .     .    .    .     .    .    .  	       public interface should be returned.  */
     4    0    0     0    0    0     0    0    0  	    if (verstab != NULL)
     .    .    .     .    .    .     .    .    .  	      {
    12    0    0     4    1    0     0    0    0  		if ((verstab[symidx] & 0x7fff)
    10    0    0     2    0    0     0    0    0  		    >= ((flags & DL_LOOKUP_RETURN_NEWEST) ? 2 : 3))
     .    .    .     .    .    .     .    .    .  		  {
     .    .    .     .    .    .     .    .    .  		    /* Don't accept hidden symbols.  */
     .    .    .     .    .    .     .    .    .  		    if ((verstab[symidx] & 0x8000) == 0
     .    .    .     .    .    .     .    .    .  			&& num_versions++ == 0)
     .    .    .     .    .    .     .    .    .  		      /* No version so far.  */
     .    .    .     .    .    .     .    .    .  		      versioned_sym = sym;
     .    .    .     .    .    .     .    .    .  
   987    0    0     0    0    0     0    0    0  		    return NULL;
     .    .    .     .    .    .     .    .    .  		  }
     .    .    .     .    .    .     .    .    .  	      }
     .    .    .     .    .    .     .    .    .  	  }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	/* There cannot be another entry for this symbol so stop here.  */
     .    .    .     .    .    .     .    .    .  	return sym;
 3,282    1    1 2,735    0    0     0    0    0        }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        const ElfW(Sym) *sym;
   823    0    0   823    0    0     0    0    0        const ElfW(Addr) *bitmask = map->l_gnu_bitmask;
 1,646    0    0     0    0    0     0    0    0        if (__builtin_expect (bitmask != NULL, 1))
     .    .    .     .    .    .     .    .    .  	{
   621    0    0   621   73   37     0    0    0  	  ElfW(Addr) bitmask_word
   820    0    0     0    0    0   205    9    6  	    = bitmask[(new_hash / __ELF_NATIVE_CLASS)
 1,242    0    0   621    0    0     0    0    0  		      & map->l_gnu_bitmask_idxbits];
     .    .    .     .    .    .     .    .    .  
   410    0    0     0    0    0     0    0    0  	  unsigned int hashbit1 = new_hash & (__ELF_NATIVE_CLASS - 1);
 2,484    0    0   621    0    0     0    0    0  	  unsigned int hashbit2 = ((new_hash >> map->l_gnu_shift)
     .    .    .     .    .    .     .    .    .  				   & (__ELF_NATIVE_CLASS - 1));
     .    .    .     .    .    .     .    .    .  
 2,484    0    0     0    0    0     0    0    0  	  if (__builtin_expect ((bitmask_word >> hashbit1)
 1,863    0    0     0    0    0     0    0    0  				& (bitmask_word >> hashbit2) & 1, 0))
     .    .    .     .    .    .     .    .    .  	    {
   426    1    1   426   97   73     0    0    0  	      Elf32_Word bucket = map->l_gnu_buckets[new_hash
   852    1    1     0    0    0     0    0    0  						     % map->l_nbuckets];
   426    0    0     0    0    0     0    0    0  	      if (bucket != 0)
     .    .    .     .    .    .     .    .    .  		{
   627    0    0   209    0    0     0    0    0  		  const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  		  do
 2,050    0    0   410  138  107     0    0    0  		    if (((*hasharr ^ new_hash) >> 1) == 0)
     .    .    .     .    .    .     .    .    .  		      {
 1,560    1    1   390    0    0   390    0    0  			symidx = hasharr - map->l_gnu_chain_zero;
 1,365    0    0   195    0    0   780    0    0  			sym = check_match (&symtab[symidx]);
   981    0    0   589    0    0     0    0    0  			if (sym != NULL)
     .    .    .     .    .    .     .    .    .  			  goto found_it;
     .    .    .     .    .    .     .    .    .  		      }
   651    0    0     0    0    0     0    0    0  		  while ((*hasharr++ & 1u) == 0);
     .    .    .     .    .    .     .    .    .  		}
     .    .    .     .    .    .     .    .    .  	    }
     .    .    .     .    .    .     .    .    .  	  /* No symbol found.  */
   428    0    0     0    0    0   428    0    0  	  symidx = SHN_UNDEF;
     .    .    .     .    .    .     .    .    .  	}
     .    .    .     .    .    .     .    .    .        else
     .    .    .     .    .    .     .    .    .  	{
   808    1    1   202    0    0     0    0    0  	  if (*old_hash == 0xffffffff)
   606    2    1   202    0    0   202    0    0  	    *old_hash = _dl_elf_hash (undef_name);
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	  /* Use the old SysV-style hash table.  Search the appropriate
     .    .    .     .    .    .     .    .    .  	     hash bucket in this object's symbol table for a definition
     .    .    .     .    .    .     .    .    .  	     for the same symbol name.  */
 1,739    1    1   404    4    2   202    0    0  	  for (symidx = map->l_buckets[*old_hash % map->l_nbuckets];
     .    .    .     .    .    .     .    .    .  	       symidx != STN_UNDEF;
 1,745    0    0 1,396    4    1   349    0    0  	       symidx = map->l_chain[symidx])
     .    .    .     .    .    .     .    .    .  	    {
 2,464    1    1   352    0    0 1,408    0    0  	      sym = check_match (&symtab[symidx]);
 1,763    0    0 1,056    0    0     0    0    0  	      if (sym != NULL)
     .    .    .     .    .    .     .    .    .  		goto found_it;
     .    .    .     .    .    .     .    .    .  	    }
     .    .    .     .    .    .     .    .    .  	}
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* If we have seen exactly one versioned symbol while we are
     .    .    .     .    .    .     .    .    .  	 looking for an unversioned symbol and the version is not the
     .    .    .     .    .    .     .    .    .  	 default version we still accept this symbol since there are
     .    .    .     .    .    .     .    .    .  	 no possible ambiguities.  */
 1,254    1    1   627    0    0     0    0    0        sym = num_versions == 1 ? versioned_sym : NULL;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        if (sym != NULL)
     .    .    .     .    .    .     .    .    .  	{
     .    .    .     .    .    .     .    .    .  	found_it:
 1,424    0    0   196    0    0     0    0    0  	  switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL))
     .    .    .     .    .    .     .    .    .  	    {
     .    .    .     .    .    .     .    .    .  	    case STB_WEAK:
     .    .    .     .    .    .     .    .    .  	      /* Weak definition.  Use this value if we don't find another.  */
   500    1    1    36    1    0   196    0    0  	      if (__builtin_expect (GLRO(dl_dynamic_weak), 0))
     .    .    .     .    .    .     .    .    .  		{
     .    .    .     .    .    .     .    .    .  		  if (! result->s)
     .    .    .     .    .    .     .    .    .  		    {
     .    .    .     .    .    .     .    .    .  		      result->s = sym;
     .    .    .     .    .    .     .    .    .  		      result->m = (struct link_map *) map;
     .    .    .     .    .    .     .    .    .  		    }
     .    .    .     .    .    .     .    .    .  		  break;
     .    .    .     .    .    .     .    .    .  		}
     .    .    .     .    .    .     .    .    .  	      /* FALLTHROUGH */
     .    .    .     .    .    .     .    .    .  	    case STB_GLOBAL:
     .    .    .     .    .    .     .    .    .  	    success:
     .    .    .     .    .    .     .    .    .  	      /* Global definition.  Just what we need.  */
   392    0    0   196    0    0   196    0    0  	      result->s = sym;
   392    0    0   196    0    0   196    0    0  	      result->m = (struct link_map *) map;
   196    1    1     0    0    0     0    0    0  	      return 1;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	    case STB_GNU_UNIQUE:;
     .    .    .     .    .    .     .    .    .  	      /* We have to determine whether we already found a
     .    .    .     .    .    .     .    .    .  		 symbol with this name before.  If not then we have to
     .    .    .     .    .    .     .    .    .  		 add it to the search table.  If we already found a
     .    .    .     .    .    .     .    .    .  		 definition we have to use it.  */
     .    .    .     .    .    .     .    .    .  	      void enter (struct unique_sym *table, size_t size,
     .    .    .     .    .    .     .    .    .  			  unsigned int hash, const char *name,
-- line 314 ----------------------------------------
-- line 454 ----------------------------------------
     .    .    .     .    .    .     .    .    .  	    default:
     .    .    .     .    .    .     .    .    .  	      /* Local symbols are ignored.  */
     .    .    .     .    .    .     .    .    .  	      break;
     .    .    .     .    .    .     .    .    .  	    }
     .    .    .     .    .    .     .    .    .  	}
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .        /* If this current map is the one mentioned in the verneed entry
     .    .    .     .    .    .     .    .    .  	 and we have not found a weak entry, it is a bug.  */
 3,609    1    1 1,203    1    0     0    0    0        if (symidx == STN_UNDEF && version != NULL && version->filename != NULL
 3,773    0    0 1,372    0    0 1,372    0    0  	  && __builtin_expect (_dl_name_match_p (version->filename, map), 0))
     .    .    .     .    .    .     .    .    .  	return -1;
     .    .    .     .    .    .     .    .    .      }
 1,890    1    1     0    0    0     0    0    0    while (++i < n);
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    /* We have not found anything until now.  */
    18    0    0     0    0    0     0    0    0    return 0;
 1,640    0    0 1,435    0    0     0    0    0  }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  static uint_fast32_t
     .    .    .     .    .    .     .    .    .  dl_new_hash (const char *s)
     .    .    .     .    .    .     .    .    .  {
   410    1    1     0    0    0     0    0    0    uint_fast32_t h = 5381;
11,714    0    0 2,826  135  126   205    0    0    for (unsigned char c = *s; c != '\0'; c = *++s)
10,484    0    0     0    0    0     0    0    0      h = h * 33 + c;
     .    .    .     .    .    .     .    .    .    return h & 0xffffffff;
     .    .    .     .    .    .     .    .    .  }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  /* Add extra dependency on MAP to UNDEF_MAP.  */
     .    .    .     .    .    .     .    .    .  static int
     .    .    .     .    .    .     .    .    .  internal_function
     .    .    .     .    .    .     .    .    .  add_dependency (struct link_map *undef_map, struct link_map *map, int flags)
-- line 486 ----------------------------------------
-- line 708 ----------------------------------------
     .    .    .     .    .    .     .    .    .     code might create a thread which can throw off all the scope locking.  */
     .    .    .     .    .    .     .    .    .  lookup_t
     .    .    .     .    .    .     .    .    .  internal_function
     .    .    .     .    .    .     .    .    .  _dl_lookup_symbol_x (const char *undef_name, struct link_map *undef_map,
     .    .    .     .    .    .     .    .    .  		     const ElfW(Sym) **ref,
     .    .    .     .    .    .     .    .    .  		     struct r_scope_elem *symbol_scope[],
     .    .    .     .    .    .     .    .    .  		     const struct r_found_version *version,
     .    .    .     .    .    .     .    .    .  		     int type_class, int flags, struct link_map *skip_map)
 2,870    1    1     0    0    0 1,640   23   13  {
     .    .    .     .    .    .     .    .    .    const uint_fast32_t new_hash = dl_new_hash (undef_name);
   410    1    1     0    0    0   205    0    0    unsigned long int old_hash = 0xffffffff;
   410    0    0     0    0    0   410    0    0    struct sym_val current_value = { NULL, NULL };
     .    .    .     .    .    .     .    .    .    struct r_scope_elem **scope = symbol_scope;
     .    .    .     .    .    .     .    .    .  
   205    0    0   205    2    0     0    0    0    bump_num_relocations ();
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    /* No other flag than DL_LOOKUP_ADD_DEPENDENCY or DL_LOOKUP_GSCOPE_LOCK
     .    .    .     .    .    .     .    .    .       is allowed if we look up a versioned symbol.  */
     .    .    .     .    .    .     .    .    .    assert (version == NULL
     .    .    .     .    .    .     .    .    .  	  || (flags & ~(DL_LOOKUP_ADD_DEPENDENCY | DL_LOOKUP_GSCOPE_LOCK))
     .    .    .     .    .    .     .    .    .  	     == 0);
     .    .    .     .    .    .     .    .    .  
   410    1    1     0    0    0   205    0    0    size_t i = 0;
   410    0    0   205    0    0     0    0    0    if (__builtin_expect (skip_map != NULL, 0))
     .    .    .     .    .    .     .    .    .      /* Search the relevant loaded objects for a definition.  */
   410    0    0   410    6    0     0    0    0      while ((*scope)->r_list[i] != skip_map)
     .    .    .     .    .    .     .    .    .        ++i;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    /* Search the relevant loaded objects for a definition.  */
 1,676    2    1     9    0    0   410    0    0    for (size_t start = i; *scope != NULL; start = 0, ++scope)
     .    .    .     .    .    .     .    .    .      {
 2,665    1    1 1,230    0    0 1,435    7    4        int res = do_lookup_x (undef_name, new_hash, &old_hash, *ref,
     .    .    .     .    .    .     .    .    .  			     &current_value, *scope, start, version, flags,
     .    .    .     .    .    .     .    .    .  			     skip_map, type_class, undef_map);
   410    0    0     0    0    0     0    0    0        if (res > 0)
     .    .    .     .    .    .     .    .    .  	break;
     .    .    .     .    .    .     .    .    .  
     9    0    0     0    0    0     0    0    0        if (__builtin_expect (res, 0) < 0 && skip_map == NULL)
     .    .    .     .    .    .     .    .    .  	{
     .    .    .     .    .    .     .    .    .  	  /* Oh, oh.  The file named in the relocation entry does not
     .    .    .     .    .    .     .    .    .  	     contain the needed symbol.  This code is never reached
     .    .    .     .    .    .     .    .    .  	     for unversioned lookups.  */
     .    .    .     .    .    .     .    .    .  	  assert (version != NULL);
     .    .    .     .    .    .     .    .    .  	  const char *reference_name = undef_map ? undef_map->l_name : NULL;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	  /* XXX We cannot translate the message.  */
-- line 753 ----------------------------------------
-- line 762 ----------------------------------------
     .    .    .     .    .    .     .    .    .  					  " with link time reference",
     .    .    .     .    .    .     .    .    .  					  res == -2
     .    .    .     .    .    .     .    .    .  					  ? " (no version symbols)" : ""));
     .    .    .     .    .    .     .    .    .  	  *ref = NULL;
     .    .    .     .    .    .     .    .    .  	  return 0;
     .    .    .     .    .    .     .    .    .  	}
     .    .    .     .    .    .     .    .    .      }
     .    .    .     .    .    .     .    .    .  
   410    0    0   205    0    0     0    0    0    if (__builtin_expect (current_value.s == NULL, 0))
     .    .    .     .    .    .     .    .    .      {
    63    1    1    18    0    0     0    0    0        if ((*ref == NULL || ELFW(ST_BIND) ((*ref)->st_info) != STB_WEAK)
     .    .    .     .    .    .     .    .    .  	  && skip_map == NULL
     .    .    .     .    .    .     .    .    .  	  && !(GLRO(dl_debug_mask) & DL_DEBUG_UNUSED))
     .    .    .     .    .    .     .    .    .  	{
     .    .    .     .    .    .     .    .    .  	  /* We could find no value for a strong reference.  */
     .    .    .     .    .    .     .    .    .  	  const char *reference_name = undef_map ? undef_map->l_name : "";
     .    .    .     .    .    .     .    .    .  	  const char *versionstr = version ? ", version " : "";
     .    .    .     .    .    .     .    .    .  	  const char *versionname = (version && version->name
     .    .    .     .    .    .     .    .    .  				     ? version->name : "");
-- line 780 ----------------------------------------
-- line 782 ----------------------------------------
     .    .    .     .    .    .     .    .    .  	  /* XXX We cannot translate the message.  */
     .    .    .     .    .    .     .    .    .  	  _dl_signal_cerror (0, (reference_name[0]
     .    .    .     .    .    .     .    .    .  				 ? reference_name
     .    .    .     .    .    .     .    .    .  				 : (rtld_progname ?: "<main program>")),
     .    .    .     .    .    .     .    .    .  			     N_("symbol lookup error"),
     .    .    .     .    .    .     .    .    .  			     make_string (undefined_msg, undef_name,
     .    .    .     .    .    .     .    .    .  					  versionstr, versionname));
     .    .    .     .    .    .     .    .    .  	}
     9    1    1     0    0    0     9    0    0        *ref = NULL;
    18    0    0     0    0    0     0    0    0        return 0;
     .    .    .     .    .    .     .    .    .      }
     .    .    .     .    .    .     .    .    .  
   196    0    0   196    0    0     0    0    0    int protected = (*ref
 1,372    0    0   392    0    0     0    0    0  		   && ELFW(ST_VISIBILITY) ((*ref)->st_other) == STV_PROTECTED);
     .    .    .     .    .    .     .    .    .    if (__builtin_expect (protected != 0, 0))
     .    .    .     .    .    .     .    .    .      {
     .    .    .     .    .    .     .    .    .        /* It is very tricky.  We need to figure out what value to
     .    .    .     .    .    .     .    .    .  	 return for the protected symbol.  */
     .    .    .     .    .    .     .    .    .        if (type_class == ELF_RTYPE_CLASS_PLT)
     .    .    .     .    .    .     .    .    .  	{
     .    .    .     .    .    .     .    .    .  	  if (current_value.s != NULL && current_value.m != undef_map)
     .    .    .     .    .    .     .    .    .  	    {
-- line 803 ----------------------------------------
-- line 813 ----------------------------------------
     .    .    .     .    .    .     .    .    .  	    if (do_lookup_x (undef_name, new_hash, &old_hash, *ref,
     .    .    .     .    .    .     .    .    .  			     &protected_value, *scope, i, version, flags,
     .    .    .     .    .    .     .    .    .  			     skip_map, ELF_RTYPE_CLASS_PLT, NULL) != 0)
     .    .    .     .    .    .     .    .    .  	      break;
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  	  if (protected_value.s != NULL && protected_value.m != undef_map)
     .    .    .     .    .    .     .    .    .  	    {
     .    .    .     .    .    .     .    .    .  	      current_value.s = *ref;
   196    0    0     0    0    0     0    0    0  	      current_value.m = undef_map;
     .    .    .     .    .    .     .    .    .  	    }
     .    .    .     .    .    .     .    .    .  	}
     .    .    .     .    .    .     .    .    .      }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    /* We have to check whether this would bind UNDEF_MAP to an object
     .    .    .     .    .    .     .    .    .       in the global scope which was dynamically loaded.  In this case
     .    .    .     .    .    .     .    .    .       we have to prevent the latter from being unloaded unless the
     .    .    .     .    .    .     .    .    .       UNDEF_MAP object is also unloaded.  */
   980    1    1   196    0    0     0    0    0    if (__builtin_expect (current_value.m->l_type == lt_loaded, 0)
     .    .    .     .    .    .     .    .    .        /* Don't do this for explicit lookups as opposed to implicit
     .    .    .     .    .    .     .    .    .  	 runtime lookups.  */
     .    .    .     .    .    .     .    .    .        && (flags & DL_LOOKUP_ADD_DEPENDENCY) != 0
     .    .    .     .    .    .     .    .    .        /* Add UNDEF_MAP to the dependencies.  */
     .    .    .     .    .    .     .    .    .        && add_dependency (undef_map, current_value.m, flags) < 0)
     .    .    .     .    .    .     .    .    .        /* Something went wrong.  Perhaps the object we tried to reference
     .    .    .     .    .    .     .    .    .  	 was just removed.  Try finding another definition.  */
     .    .    .     .    .    .     .    .    .        return _dl_lookup_symbol_x (undef_name, undef_map, ref,
     .    .    .     .    .    .     .    .    .  				  (flags & DL_LOOKUP_GSCOPE_LOCK)
     .    .    .     .    .    .     .    .    .  				  ? undef_map->l_scope : symbol_scope,
     .    .    .     .    .    .     .    .    .  				  version, type_class, flags, skip_map);
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .    /* The object is used.  */
   588    0    0   196    8    0     0    0    0    if (__builtin_expect (current_value.m->l_used == 0, 0))
     2    1    1     0    0    0     1    0    0      current_value.m->l_used = 1;
     .    .    .     .    .    .     .    .    .  
   784    0    0   392    0    0     0    0    0    if (__builtin_expect (GLRO(dl_debug_mask)
     .    .    .     .    .    .     .    .    .  			& (DL_DEBUG_BINDINGS|DL_DEBUG_PRELINK), 0))
     .    .    .     .    .    .     .    .    .      _dl_debug_bindings (undef_name, undef_map, ref,
     .    .    .     .    .    .     .    .    .  			&current_value, version, type_class, protected);
     .    .    .     .    .    .     .    .    .  
   196    0    0     0    0    0   196    0    0    *ref = current_value.s;
     .    .    .     .    .    .     .    .    .    return LOOKUP_VALUE (current_value.m);
 1,640    1    1 1,435    0    0     0    0    0  }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  /* Cache the location of MAP's hash table.  */
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  void
     .    .    .     .    .    .     .    .    .  internal_function
     .    .    .     .    .    .     .    .    .  _dl_setup_hash (struct link_map *map)
     .    .    .     .    .    .     .    .    .  {
     .    .    .     .    .    .     .    .    .    Elf_Symndx *hash;
     .    .    .     .    .    .     .    .    .  
    15    1    1     5    0    0     0    0    0    if (__builtin_expect (map->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
     .    .    .     .    .    .     .    .    .  				    + DT_THISPROCNUM + DT_VERSIONTAGNUM
     .    .    .     .    .    .     .    .    .  				    + DT_EXTRANUM + DT_VALNUM] != NULL, 1))
     .    .    .     .    .    .     .    .    .      {
     4    0    0     4    0    0     0    0    0        Elf32_Word *hash32
     .    .    .     .    .    .     .    .    .  	= (void *) D_PTR (map, l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
     .    .    .     .    .    .     .    .    .  				      + DT_THISPROCNUM + DT_VERSIONTAGNUM
     .    .    .     .    .    .     .    .    .  				      + DT_EXTRANUM + DT_VALNUM]);
     8    0    0     4    4    4     4    0    0        map->l_nbuckets = *hash32++;
     4    0    0     4    0    0     0    0    0        Elf32_Word symbias = *hash32++;
     4    0    0     4    1    1     0    0    0        Elf32_Word bitmask_nwords = *hash32++;
     .    .    .     .    .    .     .    .    .        /* Must be a power of two.  */
     .    .    .     .    .    .     .    .    .        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
     8    1    1     0    0    0     4    0    0        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
    12    0    0     4    0    0     4    0    0        map->l_gnu_shift = *hash32++;
     .    .    .     .    .    .     .    .    .  
     4    0    0     0    0    0     4    0    0        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
     8    0    0     0    0    0     0    0    0        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;
     .    .    .     .    .    .     .    .    .  
     4    0    0     0    0    0     4    0    0        map->l_gnu_buckets = hash32;
     4    0    0     0    0    0     0    0    0        hash32 += map->l_nbuckets;
    16    0    0     0    0    0     4    0    0        map->l_gnu_chain_zero = hash32 - symbias;
     4    0    0     4    0    0     0    0    0        return;
     .    .    .     .    .    .     .    .    .      }
     .    .    .     .    .    .     .    .    .  
     3    0    0     1    0    0     0    0    0    if (!map->l_info[DT_HASH])
     .    .    .     .    .    .     .    .    .      return;
     1    0    0     1    0    0     0    0    0    hash = (void *) D_PTR (map, l_info[DT_HASH]);
     .    .    .     .    .    .     .    .    .  
     2    0    0     1    1    1     1    0    0    map->l_nbuckets = *hash++;
     .    .    .     .    .    .     .    .    .    /* Skip nchain.  */
     1    0    0     0    0    0     0    0    0    hash++;
     1    0    0     0    0    0     1    0    0    map->l_buckets = hash;
     3    0    0     1    0    0     1    0    0    hash += map->l_nbuckets;
     .    .    .     .    .    .     .    .    .    map->l_chain = hash;
     .    .    .     .    .    .     .    .    .  }
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  
     .    .    .     .    .    .     .    .    .  static void
     .    .    .     .    .    .     .    .    .  internal_function
     .    .    .     .    .    .     .    .    .  _dl_debug_bindings (const char *undef_name, struct link_map *undef_map,
     .    .    .     .    .    .     .    .    .  		    const ElfW(Sym) **ref, struct sym_val *value,
-- line 906 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/misc/../sysdeps/unix/sysv/linux/wordsize-64/mmap.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 24 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* An architecture may override this.  */
  .    .    .   .    .    .   .    .    .  #ifndef MMAP_PREPARE
  .    .    .   .    .    .   .    .    .  # define MMAP_PREPARE(addr, len, prot, flags, fd, offset)
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  __ptr_t
  .    .    .   .    .    .   .    .    .  __mmap (__ptr_t addr, size_t len, int prot, int flags, int fd, off_t offset)
270    2    2   0    0    0 162    4    4  {
154    3    3   3    0    0   0    0    0    MMAP_PREPARE (addr, len, prot, flags, fd, offset);
270    0    0   0    0    0   0    0    0    return (__ptr_t) INLINE_SYSCALL (mmap, 6, addr, len, prot, flags,
  .    .    .   .    .    .   .    .    .  				   fd, offset);
189    0    0 189    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  weak_alias (__mmap, mmap)
  .    .    .   .    .    .   .    .    .  weak_alias (__mmap, mmap64)
  .    .    .   .    .    .   .    .    .  weak_alias (__mmap, __mmap64)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-load.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 153 ----------------------------------------
  .    .    .   .    .    .   .    .    .  #define nsystem_dirs_len \
  .    .    .   .    .    .   .    .    .    (sizeof (system_dirs_len) / sizeof (system_dirs_len[0]))
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Local version of `strdup' function.  */
  .    .    .   .    .    .   .    .    .  static char *
  .    .    .   .    .    .   .    .    .  local_strdup (const char *s)
  .    .    .   .    .    .   .    .    .  {
 15    1    1   0    0    0   5    0    0    size_t len = strlen (s) + 1;
 10    0    0   0    0    0   5    0    0    void *new = malloc (len);
  .    .    .   .    .    .   .    .    .  
 10    0    0   0    0    0   0    0    0    if (new == NULL)
  .    .    .   .    .    .   .    .    .      return NULL;
  .    .    .   .    .    .   .    .    .  
 20    0    0   0    0    0   0    0    0    return (char *) memcpy (new, s, len);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static bool
  .    .    .   .    .    .   .    .    .  is_trusted_path_normalize (const char *path, size_t len)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    if (len == 0)
  .    .    .   .    .    .   .    .    .      return false;
-- line 175 ----------------------------------------
-- line 274 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* INPUT is the start of a DST sequence at the first '$' occurrence.
  .    .    .   .    .    .   .    .    .     If there is a DST we call into _dl_dst_count to count the number of
  .    .    .   .    .    .   .    .    .     DSTs.  We count all known DSTs regardless of __libc_enable_secure;
  .    .    .   .    .    .   .    .    .     the caller is responsible for enforcing the security of the
  .    .    .   .    .    .   .    .    .     substitution rules (usually _dl_dst_substitute).  */
  .    .    .   .    .    .   .    .    .  size_t
  .    .    .   .    .    .   .    .    .  _dl_dst_count (const char *input)
 25    1    1   0    0    0  20    0    0  {
  .    .    .   .    .    .   .    .    .    size_t cnt = 0;
  .    .    .   .    .    .   .    .    .  
 35    0    0   0    0    0  10    1    1    input = strchr (input, '$');
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Most likely there is no DST.  */
 20    0    0   0    0    0   0    0    0    if (__glibc_likely (input == NULL))
  5    0    0   0    0    0   0    0    0      return 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    do
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        size_t len;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        ++input;
  .    .    .   .    .    .   .    .    .        /* All DSTs must follow ELF gABI rules, see is_dst ().  */
  .    .    .   .    .    .   .    .    .        if ((len = is_dst (input, "ORIGIN")) != 0
-- line 297 ----------------------------------------
-- line 300 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	++cnt;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* There may be more than one DST in the input.  */
  .    .    .   .    .    .   .    .    .        input = strchr (input + len, '$');
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    while (input != NULL);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return cnt;
 30    0    0  25    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Process INPUT for DSTs and store in RESULT using the information
  .    .    .   .    .    .   .    .    .     from link map L to resolve the DSTs. This function only handles one
  .    .    .   .    .    .   .    .    .     path at a time and does not handle colon-separated path lists (see
  .    .    .   .    .    .   .    .    .     fillin_rpath ()).  Lastly the size of result in bytes should be at
  .    .    .   .    .    .   .    .    .     least equal to the value returned by DL_DST_REQUIRED.  Note that it
  .    .    .   .    .    .   .    .    .     is possible for a DT_NEEDED, DT_AUXILIARY, and DT_FILTER entries to
  .    .    .   .    .    .   .    .    .     have colons, but we treat those as literal colons here, not as path
-- line 316 ----------------------------------------
-- line 426 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Return a malloc allocated copy of INPUT with all recognized DSTs
  .    .    .   .    .    .   .    .    .     replaced. On some platforms it might not be possible to determine the
  .    .    .   .    .    .   .    .    .     path from which the object belonging to the map is loaded.  In this
  .    .    .   .    .    .   .    .    .     case the path containing the DST is left out.  On error NULL
  .    .    .   .    .    .   .    .    .     is returned.  */
  .    .    .   .    .    .   .    .    .  static char *
  .    .    .   .    .    .   .    .    .  expand_dynamic_string_token (struct link_map *l, const char *input)
 45    1    1   0    0    0  30    1    1  {
  .    .    .   .    .    .   .    .    .    /* We make two runs over the string.  First we determine how large the
  .    .    .   .    .    .   .    .    .       resulting string is and then we copy it over.  Since this is no
  .    .    .   .    .    .   .    .    .       frequently executed operation we are looking here not for performance
  .    .    .   .    .    .   .    .    .       but rather for code size.  */
  .    .    .   .    .    .   .    .    .    size_t cnt;
  .    .    .   .    .    .   .    .    .    size_t total;
  .    .    .   .    .    .   .    .    .    char *result;
  .    .    .   .    .    .   .    .    .  
-- line 442 ----------------------------------------
-- line 451 ----------------------------------------
  .    .    .   .    .    .   .    .    .    total = DL_DST_REQUIRED (l, input, strlen (input), cnt);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Allocate the necessary memory.  */
  .    .    .   .    .    .   .    .    .    result = (char *) malloc (total + 1);
  .    .    .   .    .    .   .    .    .    if (result == NULL)
  .    .    .   .    .    .   .    .    .      return NULL;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return _dl_dst_substitute (l, input, result);
 35    0    0  30    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Add `name' to the list of names for a particular shared object.
  .    .    .   .    .    .   .    .    .     `name' is expected to have been allocated with malloc and will
  .    .    .   .    .    .   .    .    .     be freed if the shared object already has this name.
  .    .    .   .    .    .   .    .    .     Returns false if the object already had this name.  */
  .    .    .   .    .    .   .    .    .  static void
  .    .    .   .    .    .   .    .    .  internal_function
-- line 467 ----------------------------------------
-- line 468 ----------------------------------------
  .    .    .   .    .    .   .    .    .  add_name_to_object (struct link_map *l, const char *name)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    struct libname_list *lnp, *lastp;
  .    .    .   .    .    .   .    .    .    struct libname_list *newname;
  .    .    .   .    .    .   .    .    .    size_t name_len;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    lastp = NULL;
  .    .    .   .    .    .   .    .    .    for (lnp = l->l_libname; lnp != NULL; lastp = lnp, lnp = lnp->next)
  3    1    1   0    0    0   0    0    0      if (strcmp (name, lnp->name) == 0)
  .    .    .   .    .    .   .    .    .        return;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    name_len = strlen (name) + 1;
  .    .    .   .    .    .   .    .    .    newname = (struct libname_list *) malloc (sizeof *newname + name_len);
  .    .    .   .    .    .   .    .    .    if (newname == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* No more memory.  */
  .    .    .   .    .    .   .    .    .        _dl_signal_error (ENOMEM, name, NULL, N_("cannot allocate name record"));
-- line 484 ----------------------------------------
-- line 496 ----------------------------------------
  .    .    .   .    .    .   .    .    .  /* Standard search directories.  */
  .    .    .   .    .    .   .    .    .  static struct r_search_path_struct rtld_search_dirs attribute_relro;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static size_t max_dirnamelen;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static struct r_search_path_elem **
  .    .    .   .    .    .   .    .    .  fillin_rpath (char *rpath, struct r_search_path_elem **result, const char *sep,
  .    .    .   .    .    .   .    .    .  	      const char *what, const char *where, struct link_map *l)
 16    2    2   0    0    0  12    0    0  {
  .    .    .   .    .    .   .    .    .    char *cp;
  1    0    0   0    0    0   0    0    0    size_t nelems = 0;
  .    .    .   .    .    .   .    .    .  
 30    0    0  10    0    0   5    1    1    while ((cp = __strsep (&rpath, sep)) != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        struct r_search_path_elem *dirp;
  4    0    0   0    0    0   4    0    0        char *to_free = NULL;
  4    0    0   0    0    0   0    0    0        size_t len = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* `strsep' can pass an empty string.  */
  8    1    1   4    0    0   0    0    0        if (*cp != '\0')
  .    .    .   .    .    .   .    .    .  	{
 16    2    2   4    0    0   4    0    0  	  to_free = cp = expand_dynamic_string_token (l, cp);
  .    .    .   .    .    .   .    .    .  	  /* expand_dynamic_string_token can return NULL in case of empty
  .    .    .   .    .    .   .    .    .  	     path or memory allocation failure.  */
  8    0    0   0    0    0   0    0    0  	  if (cp == NULL)
  .    .    .   .    .    .   .    .    .  	    continue;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Compute the length after dynamic string token expansion and
  .    .    .   .    .    .   .    .    .  	     ignore empty paths.  */
  8    0    0   0    0    0   4    0    0  	  len = strlen (cp);
  8    0    0   0    0    0   0    0    0  	  if (len == 0)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      free (to_free);
  .    .    .   .    .    .   .    .    .  	      continue;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Remove trailing slashes (except for "/").  */
 32    1    1   4    0    0   0    0    0  	  while (len > 1 && cp[len - 1] == '/')
  .    .    .   .    .    .   .    .    .  	    --len;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Now add one if there is none so far.  */
  .    .    .   .    .    .   .    .    .  	  if (len > 0 && cp[len - 1] != '/')
 16    1    1   0    0    0   8    0    0  	    cp[len++] = '/';
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* See if this directory is already known.  */
 62    0    0  18    0    0   0    0    0        for (dirp = GL(dl_all_dirs); dirp != NULL; dirp = dirp->next)
 28    0    0  14    0    0   0    0    0  	if (dirp->dirnamelen == len && memcmp (cp, dirp->dirname, len) == 0)
  .    .    .   .    .    .   .    .    .  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        if (dirp != NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* It is available, see whether it's on our own list.  */
  .    .    .   .    .    .   .    .    .  	  size_t cnt;
  .    .    .   .    .    .   .    .    .  	  for (cnt = 0; cnt < nelems; ++cnt)
  .    .    .   .    .    .   .    .    .  	    if (result[cnt] == dirp)
-- line 551 ----------------------------------------
-- line 553 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  if (cnt == nelems)
  .    .    .   .    .    .   .    .    .  	    result[nelems++] = dirp;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  size_t cnt;
  .    .    .   .    .    .   .    .    .  	  enum r_dir_status init_val;
 16    2    2   4    0    0   4    0    0  	  size_t where_len = where ? strlen (where) + 1 : 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* It's a new directory.  Create an entry and add it.  */
  8    0    0   0    0    0   4    0    0  	  dirp = (struct r_search_path_elem *)
 16    1    1   8    0    0   4    0    0  	    malloc (sizeof (*dirp) + ncapstr * sizeof (enum r_dir_status)
 16    0    0   0    0    0   8    0    0  		    + where_len + len + 1);
 16    0    0   8    0    0   0    0    0  	  if (dirp == NULL)
  .    .    .   .    .    .   .    .    .  	    _dl_signal_error (ENOMEM, NULL, NULL,
  .    .    .   .    .    .   .    .    .  			      N_("cannot create cache for search path"));
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   4    3    3  	  dirp->dirname = ((char *) dirp + sizeof (*dirp)
  4    0    0   0    0    0   0    0    0  			   + ncapstr * sizeof (enum r_dir_status));
 20    1    1   0    0    0  12    0    0  	  *((char *) __mempcpy ((char *) dirp->dirname, cp, len)) = '\0';
  4    0    0   0    0    0   4    0    0  	  dirp->dirnamelen = len;
  .    .    .   .    .    .   .    .    .  
 12    0    0   8    0    0   0    0    0  	  if (len > max_dirnamelen)
  1    0    0   0    0    0   1    0    0  	    max_dirnamelen = len;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* We have to make sure all the relative directories are
  .    .    .   .    .    .   .    .    .  	     never ignored.  The current directory might change and
  .    .    .   .    .    .   .    .    .  	     all our saved information would be void.  */
 16    0    0   4    0    0   0    0    0  	  init_val = cp[0] != '/' ? existing : unknown;
 56    1    1   0    0    0   0    0    0  	  for (cnt = 0; cnt < ncapstr; ++cnt)
 40    0    0   0    0    0   8    0    0  	    dirp->status[cnt] = init_val;
  .    .    .   .    .    .   .    .    .  
  8    0    0   4    0    0   4    0    0  	  dirp->what = what;
  8    1    1   4    0    0   0    0    0  	  if (__builtin_expect (where != NULL, 1))
  .    .    .   .    .    .   .    .    .  	    dirp->where = memcpy ((char *) dirp + sizeof (*dirp) + len + 1
  .    .    .   .    .    .   .    .    .  				  + (ncapstr * sizeof (enum r_dir_status)),
  .    .    .   .    .    .   .    .    .  				  where, where_len);
  .    .    .   .    .    .   .    .    .  	  else
  8    1    1   0    0    0   4    0    0  	    dirp->where = NULL;
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   4    0    0  	  dirp->next = GL(dl_all_dirs);
  4    0    0   0    0    0   4    0    0  	  GL(dl_all_dirs) = dirp;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Put it in the result array.  */
 12    0    0   0    0    0   4    0    0  	  result[nelems++] = dirp;
  .    .    .   .    .    .   .    .    .  	}
 12    1    1   4    0    0   4    0    0        free (to_free);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Terminate the array.  */
  1    0    0   0    0    0   1    0    0    result[nelems] = NULL;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return result;
  9    0    0   7    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static bool
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  decompose_rpath (struct r_search_path_struct *sps,
  .    .    .   .    .    .   .    .    .  		 const char *rpath, struct link_map *l, const char *what)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    /* Make a copy we can work with.  */
-- line 615 ----------------------------------------
-- line 708 ----------------------------------------
  .    .    .   .    .    .   .    .    .  /* Make sure cached path information is stored in *SP
  .    .    .   .    .    .   .    .    .     and return true if there are any paths to search there.  */
  .    .    .   .    .    .   .    .    .  static bool
  .    .    .   .    .    .   .    .    .  cache_rpath (struct link_map *l,
  .    .    .   .    .    .   .    .    .  	     struct r_search_path_struct *sp,
  .    .    .   .    .    .   .    .    .  	     int tag,
  .    .    .   .    .    .   .    .    .  	     const char *what)
  .    .    .   .    .    .   .    .    .  {
 18    3    3   6    0    0   0    0    0    if (sp->dirs == (void *) -1)
  .    .    .   .    .    .   .    .    .      return false;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    if (sp->dirs != NULL)
  .    .    .   .    .    .   .    .    .      return true;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    if (l->l_info[tag] == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* There is no path.  */
-- line 724 ----------------------------------------
-- line 731 ----------------------------------------
  .    .    .   .    .    .   .    .    .  					      + l->l_info[tag]->d_un.d_val),
  .    .    .   .    .    .   .    .    .  			  l, what);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  void
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  _dl_init_paths (const char *llp)
  9    1    1   0    0    0   6    0    0  {
  .    .    .   .    .    .   .    .    .    size_t idx;
  .    .    .   .    .    .   .    .    .    const char *strp;
  .    .    .   .    .    .   .    .    .    struct r_search_path_elem *pelem, **aelem;
  .    .    .   .    .    .   .    .    .    size_t round_size;
  .    .    .   .    .    .   .    .    .    struct link_map __attribute__ ((unused)) *l = NULL;
  .    .    .   .    .    .   .    .    .    /* Initialize to please the compiler.  */
  .    .    .   .    .    .   .    .    .    const char *errstring = NULL;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Fill in the information about the application's RPATH and the
  .    .    .   .    .    .   .    .    .       directories addressed by the LD_LIBRARY_PATH environment variable.  */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Get the capabilities.  */
  6    1    1   2    0    0   2    0    0    capstr = _dl_important_hwcaps (GLRO(dl_platform), GLRO(dl_platformlen),
  .    .    .   .    .    .   .    .    .  				 &ncapstr, &max_capstrlen);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* First set up the rest of the default search directory entries.  */
  1    0    0   0    0    0   1    0    0    aelem = rtld_search_dirs.dirs = (struct r_search_path_elem **)
  3    0    0   0    0    0   1    0    0      malloc ((nsystem_dirs_len + 1) * sizeof (struct r_search_path_elem *));
  2    0    0   0    0    0   0    0    0    if (rtld_search_dirs.dirs == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        errstring = N_("cannot create search path array");
  .    .    .   .    .    .   .    .    .      signal_error:
  .    .    .   .    .    .   .    .    .        _dl_signal_error (ENOMEM, NULL, NULL, errstring);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  5    0    0   0    0    0   0    0    0    round_size = ((2 * sizeof (struct r_search_path_elem) - 1
  2    1    1   1    0    0   0    0    0  		 + ncapstr * sizeof (enum r_dir_status))
  .    .    .   .    .    .   .    .    .  		/ sizeof (struct r_search_path_elem));
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    0    0    rtld_search_dirs.dirs[0] = (struct r_search_path_elem *)
  5    0    0   0    0    0   1    0    0      malloc ((sizeof (system_dirs) / sizeof (system_dirs[0]))
  .    .    .   .    .    .   .    .    .  	    * round_size * sizeof (struct r_search_path_elem));
  2    0    0   0    0    0   0    0    0    if (rtld_search_dirs.dirs[0] == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        errstring = N_("cannot create cache for search path");
  .    .    .   .    .    .   .    .    .        goto signal_error;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    0    0    rtld_search_dirs.malloced = 0;
  1    0    0   0    0    0   1    0    0    pelem = GL(dl_all_dirs) = rtld_search_dirs.dirs[0];
  .    .    .   .    .    .   .    .    .    strp = system_dirs;
  .    .    .   .    .    .   .    .    .    idx = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    do
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        size_t cnt;
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    0    0        *aelem++ = pelem;
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   2    1    1        pelem->what = "system search path";
  2    0    0   0    0    0   2    1    1        pelem->where = NULL;
  .    .    .   .    .    .   .    .    .  
 11    1    1   0    0    0   2    0    0        pelem->dirname = strp;
  5    0    0   0    0    0   2    0    0        pelem->dirnamelen = system_dirs_len[idx];
  .    .    .   .    .    .   .    .    .        strp += system_dirs_len[idx] + 1;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* System paths must be absolute.  */
  .    .    .   .    .    .   .    .    .        assert (pelem->dirname[0] == '/');
 14    3    3   0    0    0   0    0    0        for (cnt = 0; cnt < ncapstr; ++cnt)
 21    1    1   0    0    0   6    1    1  	pelem->status[cnt] = unknown;
  .    .    .   .    .    .   .    .    .  
  4    1    1   0    0    0   2    0    0        pelem->next = (++idx == nsystem_dirs_len ? NULL : (pelem + round_size));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        pelem += round_size;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    while (idx < nsystem_dirs_len);
  .    .    .   .    .    .   .    .    .  
  1    1    1   0    0    0   1    1    1    max_dirnamelen = SYSTEM_DIRS_MAX_LEN;
  1    0    0   0    0    0   1    0    0    *aelem = NULL;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* This points to the map of the main object.  */
  1    1    1   1    0    0   0    0    0    l = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
  2    0    0   0    0    0   0    0    0    if (l != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        assert (l->l_type != lt_loaded);
  .    .    .   .    .    .   .    .    .  
  3    0    0   1    0    0   0    0    0        if (l->l_info[DT_RUNPATH])
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* Allocate room for the search path and fill in information
  .    .    .   .    .    .   .    .    .  	     from RUNPATH.  */
  .    .    .   .    .    .   .    .    .  	  decompose_rpath (&l->l_runpath_dirs,
  .    .    .   .    .    .   .    .    .  			   (const void *) (D_PTR (l, l_info[DT_STRTAB])
  .    .    .   .    .    .   .    .    .  					   + l->l_info[DT_RUNPATH]->d_un.d_val),
  .    .    .   .    .    .   .    .    .  			   l, "RUNPATH");
  .    .    .   .    .    .   .    .    .  	  /* During rtld init the memory is allocated by the stub malloc,
-- line 825 ----------------------------------------
-- line 826 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	     prevent any attempt to free it by the normal malloc.  */
  .    .    .   .    .    .   .    .    .  	  l->l_runpath_dirs.malloced = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* The RPATH is ignored.  */
  .    .    .   .    .    .   .    .    .  	  l->l_rpath_dirs.dirs = (void *) -1;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	{
  1    0    0   0    0    0   1    0    0  	  l->l_runpath_dirs.dirs = (void *) -1;
  .    .    .   .    .    .   .    .    .  
  3    1    1   1    0    0   0    0    0  	  if (l->l_info[DT_RPATH])
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* Allocate room for the search path and fill in information
  .    .    .   .    .    .   .    .    .  		 from RPATH.  */
  .    .    .   .    .    .   .    .    .  	      decompose_rpath (&l->l_rpath_dirs,
  .    .    .   .    .    .   .    .    .  			       (const void *) (D_PTR (l, l_info[DT_STRTAB])
  .    .    .   .    .    .   .    .    .  					       + l->l_info[DT_RPATH]->d_un.d_val),
  .    .    .   .    .    .   .    .    .  			       l, "RPATH");
  .    .    .   .    .    .   .    .    .  	      /* During rtld init the memory is allocated by the stub
  .    .    .   .    .    .   .    .    .  		 malloc, prevent any attempt to free it by the normal
  .    .    .   .    .    .   .    .    .  		 malloc.  */
  .    .    .   .    .    .   .    .    .  	      l->l_rpath_dirs.malloced = 0;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	  else
  2    1    1   0    0    0   1    0    0  	    l->l_rpath_dirs.dirs = (void *) -1;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif	/* SHARED */
  .    .    .   .    .    .   .    .    .  
  4    1    1   1    0    0   0    0    0    if (llp != NULL && *llp != '\0')
  .    .    .   .    .    .   .    .    .      {
 23    3    3   1    0    0   2    0    0        char *llp_tmp = strdupa (llp);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Decompose the LD_LIBRARY_PATH contents.  First determine how many
  .    .    .   .    .    .   .    .    .  	 elements it has.  */
  2    0    0   0    0    0   0    0    0        size_t nllp = 1;
553    1    1 138    0    0   0    0    0        for (const char *cp = llp_tmp; *cp != '\0'; ++cp)
137    0    0   0    0    0   0    0    0  	if (*cp == ':' || *cp == ';')
411    0    0   0    0    0   0    0    0  	  ++nllp;
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    0    0        env_path_list.dirs = (struct r_search_path_elem **)
  1    0    0   0    0    0   1    0    0  	malloc ((nllp + 1) * sizeof (struct r_search_path_elem *));
  2    0    0   0    0    0   0    0    0        if (env_path_list.dirs == NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("cannot create cache for search path");
  .    .    .   .    .    .   .    .    .  	  goto signal_error;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  7    0    0   0    0    0   1    0    0        (void) fillin_rpath (llp_tmp, env_path_list.dirs, ":;",
  .    .    .   .    .    .   .    .    .  			   "LD_LIBRARY_PATH", NULL, l);
  .    .    .   .    .    .   .    .    .  
  3    0    0   2    0    0   0    0    0        if (env_path_list.dirs[0] == NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  free (env_path_list.dirs);
  .    .    .   .    .    .   .    .    .  	  env_path_list.dirs = (void *) -1;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    0    0        env_path_list.malloced = 0;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else
  .    .    .   .    .    .   .    .    .      env_path_list.dirs = (void *) -1;
  8    0    0   7    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static void
  .    .    .   .    .    .   .    .    .  __attribute__ ((noreturn, noinline))
  .    .    .   .    .    .   .    .    .  lose (int code, int fd, const char *name, char *realname, struct link_map *l,
  .    .    .   .    .    .   .    .    .        const char *msg, struct r_debug *r, Lmid_t nsid)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    /* The file might already be closed.  */
-- line 895 ----------------------------------------
-- line 917 ----------------------------------------
  .    .    .   .    .    .   .    .    .  #ifndef EXTERNAL_MAP_FROM_FD
  .    .    .   .    .    .   .    .    .  static
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  struct link_map *
  .    .    .   .    .    .   .    .    .  _dl_map_object_from_fd (const char *name, const char *origname, int fd,
  .    .    .   .    .    .   .    .    .  			struct filebuf *fbp, char *realname,
  .    .    .   .    .    .   .    .    .  			struct link_map *loader, int l_type, int mode,
  .    .    .   .    .    .   .    .    .  			void **stack_endp, Lmid_t nsid)
 45    2    2   0    0    0  33    2    2  {
  .    .    .   .    .    .   .    .    .    struct link_map *l = NULL;
  .    .    .   .    .    .   .    .    .    const ElfW(Ehdr) *header;
  .    .    .   .    .    .   .    .    .    const ElfW(Phdr) *phdr;
  .    .    .   .    .    .   .    .    .    const ElfW(Phdr) *ph;
  .    .    .   .    .    .   .    .    .    size_t maplength;
  .    .    .   .    .    .   .    .    .    int type;
  .    .    .   .    .    .   .    .    .    struct stat64 st;
  .    .    .   .    .    .   .    .    .    /* Initialize to keep the compiler happy.  */
  .    .    .   .    .    .   .    .    .    const char *errstring = NULL;
  .    .    .   .    .    .   .    .    .    int errval = 0;
 12    0    0   3    0    0   6    1    1    struct r_debug *r = _dl_debug_initialize (0, nsid);
  3    0    0   0    0    0   3    0    0    bool make_consistent = false;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Get file information.  */
 18    0    0   0    0    0   3    0    0    if (__builtin_expect (__fxstat64 (_STAT_VER, fd, &st) < 0, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        errstring = N_("cannot stat shared object");
  .    .    .   .    .    .   .    .    .      call_lose_errno:
  .    .    .   .    .    .   .    .    .        errval = errno;
  .    .    .   .    .    .   .    .    .      call_lose:
  .    .    .   .    .    .   .    .    .        lose (errval, fd, name, realname, l, errstring,
  .    .    .   .    .    .   .    .    .  	    make_consistent ? r : NULL, nsid);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Look again to see if the real name matched another already loaded.  */
 48    1    1  15    0    0   0    0    0    for (l = GL(dl_ns)[nsid]._ns_loaded; l; l = l->l_next)
 45    1    1  24    1    1   0    0    0      if (l->l_removed == 0 && l->l_ino == st.st_ino && l->l_dev == st.st_dev)
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  	/* The object is already loaded.
  .    .    .   .    .    .   .    .    .  	   Just bump its reference count and return it.  */
  .    .    .   .    .    .   .    .    .  	__close (fd);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	/* If the name is not in the list of names for this object add
  .    .    .   .    .    .   .    .    .  	   it.  */
  .    .    .   .    .    .   .    .    .  	free (realname);
-- line 960 ----------------------------------------
-- line 961 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	add_name_to_object (l, name);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	return l;
  .    .    .   .    .    .   .    .    .        }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* When loading into a namespace other than the base one we must
  .    .    .   .    .    .   .    .    .       avoid loading ld.so since there can only be one copy.  Ever.  */
  6    1    1   3    0    0   0    0    0    if (__builtin_expect (nsid != LM_ID_BASE, 0)
  .    .    .   .    .    .   .    .    .        && ((st.st_ino == GL(dl_rtld_map).l_ino
  .    .    .   .    .    .   .    .    .  	   && st.st_dev == GL(dl_rtld_map).l_dev)
  .    .    .   .    .    .   .    .    .  	  || _dl_name_match_p (name, &GL(dl_rtld_map))))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* This is indeed ld.so.  Create a new link_map which refers to
  .    .    .   .    .    .   .    .    .  	 the real one for almost everything.  */
  .    .    .   .    .    .   .    .    .        l = _dl_new_object (realname, name, l_type, loader, mode, nsid);
  .    .    .   .    .    .   .    .    .        if (l == NULL)
-- line 977 ----------------------------------------
-- line 986 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Add the map for the mirrored object to the object list.  */
  .    .    .   .    .    .   .    .    .        _dl_add_to_namespace_list (l, nsid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        return l;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  6    0    0   3    0    0   0    0    0    if (mode & RTLD_NOLOAD)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* We are not supposed to load the object unless it is already
  .    .    .   .    .    .   .    .    .  	 loaded.  So return now.  */
  .    .    .   .    .    .   .    .    .        free (realname);
  .    .    .   .    .    .   .    .    .        __close (fd);
  .    .    .   .    .    .   .    .    .        return NULL;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Print debugging message.  */
  6    0    0   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0))
  .    .    .   .    .    .   .    .    .      _dl_debug_printf ("file=%s [%lu];  generating link map\n", name, nsid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* This is the ELF header.  We read it in `open_verify'.  */
  .    .    .   .    .    .   .    .    .    header = (void *) fbp->buf;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifndef MAP_ANON
  .    .    .   .    .    .   .    .    .  # define MAP_ANON 0
  .    .    .   .    .    .   .    .    .    if (_dl_zerofd == -1)
-- line 1012 ----------------------------------------
-- line 1018 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	  __close (fd);
  .    .    .   .    .    .   .    .    .  	  _dl_signal_error (errno, NULL, NULL,
  .    .    .   .    .    .   .    .    .  			    N_("cannot open zero fill device"));
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Signal that we are going to add new objects.  */
 12    1    1   6    0    0   0    0    0    if (r->r_state == RT_CONSISTENT)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .        /* Auditing checkpoint: we are going to add new objects.  */
  .    .    .   .    .    .   .    .    .        if ((mode & __RTLD_AUDIT) == 0
  .    .    .   .    .    .   .    .    .  	  && __builtin_expect (GLRO(dl_naudit) > 0, 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  struct link_map *head = GL(dl_ns)[nsid]._ns_loaded;
  .    .    .   .    .    .   .    .    .  	  /* Do not call the functions for any auditing object.  */
-- line 1034 ----------------------------------------
-- line 1053 ----------------------------------------
  .    .    .   .    .    .   .    .    .        _dl_debug_state ();
  .    .    .   .    .    .   .    .    .        LIBC_PROBE (map_start, 2, nsid, r);
  .    .    .   .    .    .   .    .    .        make_consistent = true;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else
  .    .    .   .    .    .   .    .    .      assert (r->r_state == RT_ADD);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Enter the new object in the list of loaded objects.  */
 24    0    0  15    0    0   3    0    0    l = _dl_new_object (realname, name, l_type, loader, mode, nsid);
  6    0    0   0    0    0   0    0    0    if (__builtin_expect (l == NULL, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .      fail_new:
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .        errstring = N_("cannot create shared object descriptor");
  .    .    .   .    .    .   .    .    .        goto call_lose_errno;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Extract the remaining details we need from the ELF header
  .    .    .   .    .    .   .    .    .       and then read in the program header table.  */
  9    1    1   6    0    0   3    2    2    l->l_entry = header->e_entry;
  9    0    0   6    0    0   3    0    0    type = header->e_type;
  6    0    0   3    0    0   3    0    0    l->l_phnum = header->e_phnum;
  .    .    .   .    .    .   .    .    .  
 15    0    0   0    0    0   0    0    0    maplength = header->e_phnum * sizeof (ElfW(Phdr));
 12    1    1   6    0    0   0    0    0    if (header->e_phoff + maplength <= (size_t) fbp->len)
  3    0    0   0    0    0   0    0    0      phdr = (void *) (fbp->buf + header->e_phoff);
  .    .    .   .    .    .   .    .    .    else
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        phdr = alloca (maplength);
  .    .    .   .    .    .   .    .    .        __lseek (fd, header->e_phoff, SEEK_SET);
  .    .    .   .    .    .   .    .    .        if ((size_t) __libc_read (fd, (void *) phdr, maplength) != maplength)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("cannot read file data");
  .    .    .   .    .    .   .    .    .  	  goto call_lose_errno;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .     /* On most platforms presume that PT_GNU_STACK is absent and the stack is
  .    .    .   .    .    .   .    .    .      * executable.  Other platforms default to a nonexecutable stack and don't
  .    .    .   .    .    .   .    .    .      * need PT_GNU_STACK to do so.  */
  3    0    0   0    0    0   3    0    0     uint_fast16_t stack_flags = DEFAULT_STACK_PERMS;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    {
  .    .    .   .    .    .   .    .    .      /* Scan the program header table, collecting its load commands.  */
  .    .    .   .    .    .   .    .    .      struct loadcmd
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  	ElfW(Addr) mapstart, mapend, dataend, allocend;
  .    .    .   .    .    .   .    .    .  	ElfW(Off) mapoff;
  .    .    .   .    .    .   .    .    .  	int prot;
 72    2    2   9    0    0   9    0    0        } loadcmds[l->l_phnum], *c;
  3    0    0   0    0    0   0    0    0      size_t nloadcmds = 0;
  3    0    0   0    0    0   0    0    0      bool has_holes = false;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      /* The struct is initialized to zero so this is not necessary:
  .    .    .   .    .    .   .    .    .      l->l_ld = 0;
  .    .    .   .    .    .   .    .    .      l->l_phdr = 0;
  .    .    .   .    .    .   .    .    .      l->l_addr = 0; */
217    0    0   0    0    0   0    0    0      for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
199    1    1  26    2    2   0    0    0        switch (ph->p_type)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* These entries tell us where to find things once the file's
  .    .    .   .    .    .   .    .    .  	     segments are mapped in.  We record the addresses it says
  .    .    .   .    .    .   .    .    .  	     verbatim, and later correct for the run-time load address.  */
  .    .    .   .    .    .   .    .    .  	case PT_DYNAMIC:
  6    0    0   3    0    0   3    0    0  	  l->l_ld = (void *) ph->p_vaddr;
  9    1    1   3    0    0   3    0    0  	  l->l_ldnum = ph->p_memsz / sizeof (ElfW(Dyn));
  3    0    0   0    0    0   0    0    0  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	case PT_PHDR:
  4    0    0   2    0    0   2    1    1  	  l->l_phdr = (void *) ph->p_vaddr;
  8    0    0   0    0    0   0    0    0  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	case PT_LOAD:
  .    .    .   .    .    .   .    .    .  	  /* A load command tells us to map in part of the file.
  .    .    .   .    .    .   .    .    .  	     We record the load commands and process them all later.  */
 30    1    1  12    0    0   0    0    0  	  if (__builtin_expect ((ph->p_align & (GLRO(dl_pagesize) - 1)) != 0,
  .    .    .   .    .    .   .    .    .  				0))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      errstring = N_("ELF load command alignment not page-aligned");
  .    .    .   .    .    .   .    .    .  	      goto call_lose;
  .    .    .   .    .    .   .    .    .  	    }
 36    0    0  12    0    0   0    0    0  	  if (__builtin_expect (((ph->p_vaddr - ph->p_offset)
  6    1    1   0    0    0   0    0    0  				 & (ph->p_align - 1)) != 0, 0))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      errstring
  .    .    .   .    .    .   .    .    .  		= N_("ELF load command address/offset not properly aligned");
  .    .    .   .    .    .   .    .    .  	      goto call_lose;
  .    .    .   .    .    .   .    .    .  	    }
 24    0    0  12    0    0   0    0    0  	  if (__builtin_expect ((ph->p_offset + ph->p_filesz > st.st_size), 0))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* If the segment requires zeroing of part of its last
  .    .    .   .    .    .   .    .    .  		 page, we'll crash when accessing the unmapped page.
  .    .    .   .    .    .   .    .    .  		 There's still a possibility of a race, if the shared
  .    .    .   .    .    .   .    .    .  		 object is truncated between the fxstat above and the
  .    .    .   .    .    .   .    .    .  		 memset below.  */
  .    .    .   .    .    .   .    .    .  	      errstring = N_("ELF load command past end of file");
  .    .    .   .    .    .   .    .    .  	      goto call_lose;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
 30    1    1   6    0    0   0    0    0  	  c = &loadcmds[nloadcmds++];
 24    0    0   0    0    0   6    2    2  	  c->mapstart = ph->p_vaddr & ~(GLRO(dl_pagesize) - 1);
 12    0    0   0    0    0   0    0    0  	  c->mapend = ((ph->p_vaddr + ph->p_filesz + GLRO(dl_pagesize) - 1)
 12    0    0   0    0    0   6    0    0  		       & ~(GLRO(dl_pagesize) - 1));
  6    0    0   0    0    0   6    0    0  	  c->dataend = ph->p_vaddr + ph->p_filesz;
 12    0    0   6    0    0   6    1    1  	  c->allocend = ph->p_vaddr + ph->p_memsz;
 12    0    0   0    0    0   6    0    0  	  c->mapoff = ph->p_offset & ~(GLRO(dl_pagesize) - 1);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Determine whether there is a gap between the last segment
  .    .    .   .    .    .   .    .    .  	     and this one.  */
 12    0    0   0    0    0   0    0    0  	  if (nloadcmds > 1 && c[-1].mapend != c->mapstart)
  9    0    0   3    0    0   0    0    0  	    has_holes = true;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Optimize a common case.  */
  .    .    .   .    .    .   .    .    .  #if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
  .    .    .   .    .    .   .    .    .  	  c->prot = (PF_TO_PROT
 42    1    1   6    0    0   6    1    1  		     >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
  .    .    .   .    .    .   .    .    .  #else
  .    .    .   .    .    .   .    .    .  	  c->prot = 0;
  .    .    .   .    .    .   .    .    .  	  if (ph->p_flags & PF_R)
  .    .    .   .    .    .   .    .    .  	    c->prot |= PROT_READ;
  .    .    .   .    .    .   .    .    .  	  if (ph->p_flags & PF_W)
  .    .    .   .    .    .   .    .    .  	    c->prot |= PROT_WRITE;
  .    .    .   .    .    .   .    .    .  	  if (ph->p_flags & PF_X)
  .    .    .   .    .    .   .    .    .  	    c->prot |= PROT_EXEC;
  .    .    .   .    .    .   .    .    .  #endif
  6    0    0   0    0    0   0    0    0  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	case PT_TLS:
  3    0    0   1    0    0   0    0    0  	  if (ph->p_memsz == 0)
  .    .    .   .    .    .   .    .    .  	    /* Nothing to do for an empty segment.  */
  .    .    .   .    .    .   .    .    .  	    break;
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   1    1    1  	  l->l_tls_blocksize = ph->p_memsz;
  2    1    1   1    0    0   1    0    0  	  l->l_tls_align = ph->p_align;
  2    0    0   0    0    0   0    0    0  	  if (ph->p_align == 0)
  1    0    0   0    0    0   0    0    0  	    l->l_tls_firstbyte_offset = 0;
  .    .    .   .    .    .   .    .    .  	  else
  3    0    0   1    0    0   1    0    0  	    l->l_tls_firstbyte_offset = ph->p_vaddr & (ph->p_align - 1);
  2    0    0   1    0    0   1    1    1  	  l->l_tls_initimage_size = ph->p_filesz;
  .    .    .   .    .    .   .    .    .  	  /* Since we don't know the load address yet only store the
  .    .    .   .    .    .   .    .    .  	     offset.  We will adjust it later.  */
  2    0    0   1    0    0   1    0    0  	  l->l_tls_initimage = (void *) ph->p_vaddr;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* If not loading the initial set of shared libraries,
  .    .    .   .    .    .   .    .    .  	     check whether we should permit loading a TLS segment.  */
  4    0    0   1    0    0   0    0    0  	  if (__builtin_expect (l->l_type == lt_library, 1)
  .    .    .   .    .    .   .    .    .  	      /* If GL(dl_tls_dtv_slotinfo_list) == NULL, then rtld.c did
  .    .    .   .    .    .   .    .    .  		 not set up TLS data structures, so don't use them now.  */
  .    .    .   .    .    .   .    .    .  	      || __builtin_expect (GL(dl_tls_dtv_slotinfo_list) != NULL, 1))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* Assign the next available module ID.  */
  3    0    0   1    0    0   2    1    1  	      l->l_tls_modid = _dl_next_tls_modid ();
  1    0    0   0    0    0   0    0    0  	      break;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
 12    0    0   3    0    0   3    0    0  	  if (l->l_prev == NULL || (mode & __RTLD_AUDIT) != 0)
  .    .    .   .    .    .   .    .    .  	    /* We are loading the executable itself when the dynamic linker
  .    .    .   .    .    .   .    .    .  	       was executed directly.  The setup will happen later.  */
  .    .    .   .    .    .   .    .    .  	    break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  # ifdef _LIBC_REENTRANT
  .    .    .   .    .    .   .    .    .  	  /* In a static binary there is no way to tell if we dynamically
  .    .    .   .    .    .   .    .    .  	     loaded libpthread.  */
 12    1    1   0    0    0   0    0    0  	  if (GL(dl_error_catch_tsd) == &_dl_initial_error_catch_tsd)
  .    .    .   .    .    .   .    .    .  # endif
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* We have not yet loaded libpthread.
  .    .    .   .    .    .   .    .    .  		 We can do the TLS setup right now!  */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	      void *tcb;
  .    .    .   .    .    .   .    .    .  
-- line 1226 ----------------------------------------
-- line 1254 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	  /* Uh-oh, the binary expects TLS support but we cannot
  .    .    .   .    .    .   .    .    .  	     provide it.  */
  .    .    .   .    .    .   .    .    .  	  errval = 0;
  .    .    .   .    .    .   .    .    .  	  errstring = N_("cannot handle TLS data");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	case PT_GNU_STACK:
  6    1    1   3    0    0   3    0    0  	  stack_flags = ph->p_flags;
  3    0    0   0    0    0   0    0    0  	  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	case PT_GNU_RELRO:
  6    1    1   3    0    0   3    1    1  	  l->l_relro_addr = ph->p_vaddr;
  9    0    0   6    0    0   3    0    0  	  l->l_relro_size = ph->p_memsz;
  3    0    0   0    0    0   0    0    0  	  break;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  9    1    1   0    0    0   0    0    0      if (__builtin_expect (nloadcmds == 0, 0))
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  	/* This only happens for a bogus object that will be caught with
  .    .    .   .    .    .   .    .    .  	   another error below.  But we don't want to go through the
  .    .    .   .    .    .   .    .    .  	   calculations below using NLOADCMDS - 1.  */
  .    .    .   .    .    .   .    .    .  	errstring = N_("object file has no loadable segments");
  .    .    .   .    .    .   .    .    .  	goto call_lose;
  .    .    .   .    .    .   .    .    .        }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      /* Now process the load commands and map segments into memory.  */
  .    .    .   .    .    .   .    .    .      c = loadcmds;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      /* Length of the sections to be loaded.  */
 24    0    0  15    0    0   3    0    0      maplength = loadcmds[nloadcmds - 1].allocend - c->mapstart;
  .    .    .   .    .    .   .    .    .  
  6    1    1   3    0    0   0    0    0      if (__builtin_expect (type, ET_DYN) == ET_DYN)
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  	/* This is a position-independent shared object.  We can let the
  .    .    .   .    .    .   .    .    .  	   kernel map it anywhere it likes, but we must have space for all
  .    .    .   .    .    .   .    .    .  	   the segments in their specified positions relative to the first.
  .    .    .   .    .    .   .    .    .  	   So we map the first segment without MAP_FIXED, but with its
  .    .    .   .    .    .   .    .    .  	   extent increased to cover all the segments.  Then we remove
  .    .    .   .    .    .   .    .    .  	   access from excess portion, and there is known sufficient space
  .    .    .   .    .    .   .    .    .  	   there to remap from the later segments.
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	   As a refinement, sometimes we have an address that we would
  .    .    .   .    .    .   .    .    .  	   prefer to map such objects at; but this is only a preference,
  .    .    .   .    .    .   .    .    .  	   the OS can do whatever it likes. */
  .    .    .   .    .    .   .    .    .  	ElfW(Addr) mappref;
  3    0    0   3    0    0   0    0    0  	mappref = (ELF_PREFERRED_ADDRESS (loader, maplength,
  .    .    .   .    .    .   .    .    .  					  c->mapstart & GLRO(dl_use_load_bias))
  .    .    .   .    .    .   .    .    .  		   - MAP_BASE_ADDR (l));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	/* Remember which part of the address space this object uses.  */
 21    1    1  12    0    0   6    2    2  	l->l_map_start = (ElfW(Addr)) __mmap ((void *) mappref, maplength,
  .    .    .   .    .    .   .    .    .  					      c->prot,
  .    .    .   .    .    .   .    .    .  					      MAP_COPY|MAP_FILE,
  .    .    .   .    .    .   .    .    .  					      fd, c->mapoff);
  6    0    0   0    0    0   0    0    0  	if (__builtin_expect ((void *) l->l_map_start == MAP_FAILED, 0))
  .    .    .   .    .    .   .    .    .  	  {
  .    .    .   .    .    .   .    .    .  	  map_error:
  .    .    .   .    .    .   .    .    .  	    errstring = N_("failed to map segment from shared object");
  .    .    .   .    .    .   .    .    .  	    goto call_lose_errno;
  .    .    .   .    .    .   .    .    .  	  }
  .    .    .   .    .    .   .    .    .  
  9    0    0   3    0    0   3    0    0  	l->l_map_end = l->l_map_start + maplength;
  9    0    0   6    0    0   3    0    0  	l->l_addr = l->l_map_start - c->mapstart;
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0  	if (has_holes)
  .    .    .   .    .    .   .    .    .  	  /* Change protection on the excess portion to disallow all access;
  .    .    .   .    .    .   .    .    .  	     the portions we do not remap later will be inaccessible as if
  .    .    .   .    .    .   .    .    .  	     unallocated.  Then jump into the normal segment-mapping loop to
  .    .    .   .    .    .   .    .    .  	     handle the portion of the segment past the end of the file
  .    .    .   .    .    .   .    .    .  	     mapping.  */
 18    0    0   3    0    0   3    0    0  	  __mprotect ((caddr_t) (l->l_addr + c->mapend),
  3    1    1   3    0    0   0    0    0  		      loadcmds[nloadcmds - 1].mapstart - c->mapend,
  .    .    .   .    .    .   .    .    .  		      PROT_NONE);
  .    .    .   .    .    .   .    .    .  
  3    1    1   3    0    0   0    0    0  	l->l_contiguous = 1;
  .    .    .   .    .    .   .    .    .  
  3    0    0   3    0    0   0    0    0  	goto postmap;
  .    .    .   .    .    .   .    .    .        }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      /* This object is loaded at a fixed address.  This must never
  .    .    .   .    .    .   .    .    .         happen for objects loaded with dlopen().  */
  .    .    .   .    .    .   .    .    .      if (__builtin_expect ((mode & __RTLD_OPENEXEC) == 0, 0))
  .    .    .   .    .    .   .    .    .        {
  .    .    .   .    .    .   .    .    .  	errstring = N_("cannot dynamically load executable");
  .    .    .   .    .    .   .    .    .  	goto call_lose;
-- line 1339 ----------------------------------------
-- line 1344 ----------------------------------------
  .    .    .   .    .    .   .    .    .      ELF_FIXED_ADDRESS (loader, c->mapstart);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      /* Remember which part of the address space this object uses.  */
  .    .    .   .    .    .   .    .    .      l->l_map_start = c->mapstart + l->l_addr;
  .    .    .   .    .    .   .    .    .      l->l_map_end = l->l_map_start + maplength;
  .    .    .   .    .    .   .    .    .      l->l_contiguous = !has_holes;
  .    .    .   .    .    .   .    .    .  
 30    1    1   6    0    0   0    0    0      while (c < &loadcmds[nloadcmds])
  .    .    .   .    .    .   .    .    .        {
 12    0    0   6    0    0   0    0    0  	if (c->mapend > c->mapstart
  .    .    .   .    .    .   .    .    .  	    /* Map the segment contents from the file.  */
 30    1    1  12    0    0   3    0    0  	    && (__mmap ((void *) (l->l_addr + c->mapstart),
  .    .    .   .    .    .   .    .    .  			c->mapend - c->mapstart, c->prot,
  .    .    .   .    .    .   .    .    .  			MAP_FIXED|MAP_COPY|MAP_FILE,
  .    .    .   .    .    .   .    .    .  			fd, c->mapoff)
  .    .    .   .    .    .   .    .    .  		== MAP_FAILED))
  .    .    .   .    .    .   .    .    .  	  goto map_error;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        postmap:
 18    0    0   6    0    0   0    0    0  	if (c->prot & PROT_EXEC)
  9    0    0   6    0    0   3    0    0  	  l->l_text_end = l->l_addr + c->mapend;
  .    .    .   .    .    .   .    .    .  
 12    0    0   6    0    0   0    0    0  	if (l->l_phdr == 0
  5    1    1   3    0    0   0    0    0  	    && c->mapoff <= header->e_phoff
  6    0    0   2    0    0   0    0    0  	    && ((size_t) (c->mapend - c->mapstart + c->mapoff)
  5    1    1   1    0    0   0    0    0  		>= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
  .    .    .   .    .    .   .    .    .  	  /* Found the program header in this segment.  */
  4    0    0   0    0    0   1    0    0  	  l->l_phdr = (void *) (uintptr_t) (c->mapstart + header->e_phoff
  .    .    .   .    .    .   .    .    .  					    - c->mapoff);
  .    .    .   .    .    .   .    .    .  
 24    0    0  12    0    0   0    0    0  	if (c->allocend > c->dataend)
  .    .    .   .    .    .   .    .    .  	  {
  .    .    .   .    .    .   .    .    .  	    /* Extra zero pages should appear at the end of this segment,
  .    .    .   .    .    .   .    .    .  	       after the data mapped from the file.   */
  .    .    .   .    .    .   .    .    .  	    ElfW(Addr) zero, zeroend, zeropage;
  .    .    .   .    .    .   .    .    .  
  6    0    0   3    0    0   0    0    0  	    zero = l->l_addr + c->dataend;
  3    0    0   0    0    0   0    0    0  	    zeroend = l->l_addr + c->allocend;
 15    1    1   3    0    0   0    0    0  	    zeropage = ((zero + GLRO(dl_pagesize) - 1)
  6    0    0   0    0    0   0    0    0  			& ~(GLRO(dl_pagesize) - 1));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	    if (zeroend < zeropage)
  .    .    .   .    .    .   .    .    .  	      /* All the extra data is in the last page of the segment.
  .    .    .   .    .    .   .    .    .  		 We can just zero it.  */
  .    .    .   .    .    .   .    .    .  	      zeropage = zeroend;
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0  	    if (zeropage > zero)
  .    .    .   .    .    .   .    .    .  	      {
  .    .    .   .    .    .   .    .    .  		/* Zero the final part of the last page of the segment.  */
  6    0    0   0    0    0   0    0    0  		if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
  .    .    .   .    .    .   .    .    .  		  {
  .    .    .   .    .    .   .    .    .  		    /* Dag nab it.  */
  .    .    .   .    .    .   .    .    .  		    if (__mprotect ((caddr_t) (zero
  .    .    .   .    .    .   .    .    .  					       & ~(GLRO(dl_pagesize) - 1)),
  .    .    .   .    .    .   .    .    .  				    GLRO(dl_pagesize), c->prot|PROT_WRITE) < 0)
  .    .    .   .    .    .   .    .    .  		      {
  .    .    .   .    .    .   .    .    .  			errstring = N_("cannot change memory protections");
  .    .    .   .    .    .   .    .    .  			goto call_lose_errno;
  .    .    .   .    .    .   .    .    .  		      }
  .    .    .   .    .    .   .    .    .  		  }
 21    0    0   0    0    0   9    0    0  		memset ((void *) zero, '\0', zeropage - zero);
 15    0    0   9    0    0   0    0    0  		if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
  .    .    .   .    .    .   .    .    .  		  __mprotect ((caddr_t) (zero & ~(GLRO(dl_pagesize) - 1)),
  .    .    .   .    .    .   .    .    .  			      GLRO(dl_pagesize), c->prot);
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0  	    if (zeroend > zeropage)
  .    .    .   .    .    .   .    .    .  	      {
  .    .    .   .    .    .   .    .    .  		/* Map the remaining zero pages in from the zero fill FD.  */
  .    .    .   .    .    .   .    .    .  		caddr_t mapat;
 16    0    0   2    0    0   2    0    0  		mapat = __mmap ((caddr_t) zeropage, zeroend - zeropage,
  .    .    .   .    .    .   .    .    .  				c->prot, MAP_ANON|MAP_PRIVATE|MAP_FIXED,
  .    .    .   .    .    .   .    .    .  				-1, 0);
  4    0    0   0    0    0   0    0    0  		if (__builtin_expect (mapat == MAP_FAILED, 0))
  .    .    .   .    .    .   .    .    .  		  {
  .    .    .   .    .    .   .    .    .  		    errstring = N_("cannot map zero-fill pages");
  .    .    .   .    .    .   .    .    .  		    goto call_lose_errno;
  .    .    .   .    .    .   .    .    .  		  }
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  	  }
  .    .    .   .    .    .   .    .    .  
  6    1    1   0    0    0   0    0    0  	++c;
  .    .    .   .    .    .   .    .    .        }
  .    .    .   .    .    .   .    .    .    }
  .    .    .   .    .    .   .    .    .  
 12    0    0   6    0    0   0    0    0    if (l->l_ld == 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (__builtin_expect (type == ET_DYN, 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("object file has no dynamic section");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else
  9    1    1   3    0    0   3    0    0      l->l_ld = (ElfW(Dyn) *) ((ElfW(Addr)) l->l_ld + l->l_addr);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    elf_get_dynamic_info (l, NULL);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Make sure we are not dlopen'ing an object that has the
  .    .    .   .    .    .   .    .    .       DF_1_NOOPEN flag set.  */
  6    0    0   0    0    0   0    0    0    if (__builtin_expect (l->l_flags_1 & DF_1_NOOPEN, 0)
  .    .    .   .    .    .   .    .    .        && (mode & __RTLD_DLOPEN))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* We are not supposed to load this object.  Free all resources.  */
  .    .    .   .    .    .   .    .    .        __munmap ((void *) l->l_map_start, l->l_map_end - l->l_map_start);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        if (!l->l_libname->dont_free)
  .    .    .   .    .    .   .    .    .  	free (l->l_libname);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        if (l->l_phdr_allocated)
  .    .    .   .    .    .   .    .    .  	free ((void *) l->l_phdr);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        errstring = N_("shared object cannot be dlopen()ed");
  .    .    .   .    .    .   .    .    .        goto call_lose;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  9    1    1   3    0    0   0    0    0    if (l->l_phdr == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* The program header is not contained in any of the segments.
  .    .    .   .    .    .   .    .    .  	 We have to allocate memory ourself and copy it over from out
  .    .    .   .    .    .   .    .    .  	 temporary place.  */
  .    .    .   .    .    .   .    .    .        ElfW(Phdr) *newp = (ElfW(Phdr) *) malloc (header->e_phnum
  .    .    .   .    .    .   .    .    .  						* sizeof (ElfW(Phdr)));
  .    .    .   .    .    .   .    .    .        if (newp == NULL)
  .    .    .   .    .    .   .    .    .  	{
-- line 1469 ----------------------------------------
-- line 1472 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        l->l_phdr = memcpy (newp, phdr,
  .    .    .   .    .    .   .    .    .  			  (header->e_phnum * sizeof (ElfW(Phdr))));
  .    .    .   .    .    .   .    .    .        l->l_phdr_allocated = 1;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else
  .    .    .   .    .    .   .    .    .      /* Adjust the PT_PHDR value by the runtime load address.  */
  6    0    0   3    0    0   3    0    0      l->l_phdr = (ElfW(Phdr) *) ((ElfW(Addr)) l->l_phdr + l->l_addr);
  .    .    .   .    .    .   .    .    .  
 15    0    0   6    0    0   0    0    0    if (__builtin_expect ((stack_flags &~ GL(dl_stack_flags)) & PF_X, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (__builtin_expect (__check_caller (RETURN_ADDRESS (0), allow_ldso),
  .    .    .   .    .    .   .    .    .  			    0) != 0)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("invalid caller");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
-- line 1490 ----------------------------------------
-- line 1525 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("\
  .    .    .   .    .    .   .    .    .  cannot enable executable stack as shared object requires");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Adjust the address of the TLS initialization image.  */
  9    0    0   3    2    2   0    0    0    if (l->l_tls_initimage != NULL)
  2    0    0   1    0    0   1    0    0      l->l_tls_initimage = (char *) l->l_tls_initimage + l->l_addr;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* We are done mapping in the file.  We no longer need the descriptor.  */
 12    1    1   3    0    0   3    0    0    if (__builtin_expect (__close (fd) != 0, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        errstring = N_("cannot close file descriptor");
  .    .    .   .    .    .   .    .    .        goto call_lose_errno;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    /* Signal that we closed the file.  */
  .    .    .   .    .    .   .    .    .    fd = -1;
  .    .    .   .    .    .   .    .    .  
 21    1    1   3    0    0   0    0    0    if (l->l_type == lt_library && type == ET_EXEC)
  .    .    .   .    .    .   .    .    .      l->l_type = lt_executable;
  .    .    .   .    .    .   .    .    .  
 12    0    0   6    0    0   3    0    0    l->l_entry += l->l_addr;
  .    .    .   .    .    .   .    .    .  
  6    1    1   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0))
  .    .    .   .    .    .   .    .    .      _dl_debug_printf ("\
  .    .    .   .    .    .   .    .    .    dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*Zx\n\
  .    .    .   .    .    .   .    .    .      entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2,
  .    .    .   .    .    .   .    .    .  			   (unsigned long int) l->l_ld,
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2,
  .    .    .   .    .    .   .    .    .  			   (unsigned long int) l->l_addr,
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2, maplength,
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2,
  .    .    .   .    .    .   .    .    .  			   (unsigned long int) l->l_entry,
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2,
  .    .    .   .    .    .   .    .    .  			   (unsigned long int) l->l_phdr,
  .    .    .   .    .    .   .    .    .  			   (int) sizeof (void *) * 2, l->l_phnum);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Set up the symbol hash table.  */
  6    0    0   0    0    0   3    0    0    _dl_setup_hash (l);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* If this object has DT_SYMBOLIC set modify now its scope.  We don't
  .    .    .   .    .    .   .    .    .       have to do this for the main map.  */
  6    0    0   3    0    0   0    0    0    if ((mode & RTLD_DEEPBIND) == 0
  6    0    0   3    0    0   0    0    0        && __builtin_expect (l->l_info[DT_SYMBOLIC] != NULL, 0)
  .    .    .   .    .    .   .    .    .        && &l->l_searchlist != l->l_scope[0])
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Create an appropriate searchlist.  It contains only this map.
  .    .    .   .    .    .   .    .    .  	 This is the definition of DT_SYMBOLIC in SysVr4.  */
  .    .    .   .    .    .   .    .    .        l->l_symbolic_searchlist.r_list[0] = l;
  .    .    .   .    .    .   .    .    .        l->l_symbolic_searchlist.r_nlist = 1;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Now move the existing entries one back.  */
-- line 1579 ----------------------------------------
-- line 1580 ----------------------------------------
  .    .    .   .    .    .   .    .    .        memmove (&l->l_scope[1], &l->l_scope[0],
  .    .    .   .    .    .   .    .    .  	       (l->l_scope_max - 1) * sizeof (l->l_scope[0]));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Now add the new entry.  */
  .    .    .   .    .    .   .    .    .        l->l_scope[0] = &l->l_symbolic_searchlist;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Remember whether this object must be initialized first.  */
  6    0    0   3    0    0   0    0    0    if (l->l_flags_1 & DF_1_INITFIRST)
  2    0    0   0    0    0   2    0    0      GL(dl_initfirst) = l;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Finally the file information.  */
  6    1    1   3    0    0   3    0    0    l->l_dev = st.st_dev;
  6    0    0   3    0    0   3    0    0    l->l_ino = st.st_ino;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* When auditing is used the recorded names might not include the
  .    .    .   .    .    .   .    .    .       name by which the DSO is actually known.  Add that as well.  */
  6    0    0   3    0    0   0    0    0    if (__glibc_unlikely (origname != NULL))
  .    .    .   .    .    .   .    .    .      add_name_to_object (l, origname);
  .    .    .   .    .    .   .    .    .  #else
  .    .    .   .    .    .   .    .    .    /* Audit modules only exist when linking is dynamic so ORIGNAME
  .    .    .   .    .    .   .    .    .       cannot be non-NULL.  */
  .    .    .   .    .    .   .    .    .    assert (origname == NULL);
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* When we profile the SONAME might be needed for something else but
  .    .    .   .    .    .   .    .    .       loading.  Add it right away.  */
  6    0    0   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_profile) != NULL, 0)
  .    .    .   .    .    .   .    .    .        && l->l_info[DT_SONAME] != NULL)
  .    .    .   .    .    .   .    .    .      add_name_to_object (l, ((const char *) D_PTR (l, l_info[DT_STRTAB])
  .    .    .   .    .    .   .    .    .  			    + l->l_info[DT_SONAME]->d_un.d_val));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef DL_AFTER_LOAD
  .    .    .   .    .    .   .    .    .    DL_AFTER_LOAD (l);
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Now that the object is fully initialized add it to the object list.  */
  9    1    1   3    0    0   3    0    0    _dl_add_to_namespace_list (l, nsid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* Auditing checkpoint: we have a new object.  */
  9    0    0   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_naudit) > 0, 0)
  .    .    .   .    .    .   .    .    .        && !GL(dl_ns)[l->l_ns]._ns_loaded->l_auditing)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        struct audit_ifaces *afct = GLRO(dl_audit);
  .    .    .   .    .    .   .    .    .        for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  if (afct->objopen != NULL)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      l->l_audit[cnt].bindflags
-- line 1630 ----------------------------------------
-- line 1634 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  afct = afct->next;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return l;
 24    0    0  21    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Print search path.  */
  .    .    .   .    .    .   .    .    .  static void
  .    .    .   .    .    .   .    .    .  print_search_path (struct r_search_path_elem **list,
  .    .    .   .    .    .   .    .    .  		   const char *what, const char *name)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    char buf[max_dirnamelen + max_capstrlen];
  .    .    .   .    .    .   .    .    .    int first = 1;
-- line 1650 ----------------------------------------
-- line 1682 ----------------------------------------
  .    .    .   .    .    .   .    .    .  /* Open a file and verify it is an ELF file for this architecture.  We
  .    .    .   .    .    .   .    .    .     ignore only ELF files for other architectures.  Non-ELF files and
  .    .    .   .    .    .   .    .    .     ELF files with different header information cause fatal errors since
  .    .    .   .    .    .   .    .    .     this could mean there is something wrong in the installation and the
  .    .    .   .    .    .   .    .    .     user might want to know about this.  */
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  open_verify (const char *name, struct filebuf *fbp, struct link_map *loader,
  .    .    .   .    .    .   .    .    .  	     int whatcode, int mode, bool *found_other_class, bool free_name)
322    2    2  23    0    0 207    2    2  {
  .    .    .   .    .    .   .    .    .    /* This is the expected ELF header.  */
  .    .    .   .    .    .   .    .    .  #define ELF32_CLASS ELFCLASS32
  .    .    .   .    .    .   .    .    .  #define ELF64_CLASS ELFCLASS64
  .    .    .   .    .    .   .    .    .  #ifndef VALID_ELF_HEADER
  .    .    .   .    .    .   .    .    .  # define VALID_ELF_HEADER(hdr,exp,size)	(memcmp (hdr, exp, size) == 0)
  .    .    .   .    .    .   .    .    .  # define VALID_ELF_OSABI(osabi)		(osabi == ELFOSABI_SYSV)
  .    .    .   .    .    .   .    .    .  # define VALID_ELF_ABIVERSION(osabi,ver) (ver == 0)
  .    .    .   .    .    .   .    .    .  #elif defined MORE_ELF_HEADER_DATA
-- line 1698 ----------------------------------------
-- line 1718 ----------------------------------------
  .    .    .   .    .    .   .    .    .      char vendor[4];
  .    .    .   .    .    .   .    .    .    } expected_note = { 4, 16, 1, "GNU" };
  .    .    .   .    .    .   .    .    .    /* Initialize it to make the compiler happy.  */
  .    .    .   .    .    .   .    .    .    const char *errstring = NULL;
  .    .    .   .    .    .   .    .    .    int errval = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* Give the auditing libraries a chance.  */
 69    0    0  23    0    0   0    0    0    if (__builtin_expect (GLRO(dl_naudit) > 0, 0) && whatcode != 0
  .    .    .   .    .    .   .    .    .        && loader->l_auditing == 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        struct audit_ifaces *afct = GLRO(dl_audit);
  .    .    .   .    .    .   .    .    .        for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  if (afct->objsearch != NULL)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      name = afct->objsearch (name, &loader->l_audit[cnt].cookie,
  .    .    .   .    .    .   .    .    .  				      whatcode);
  .    .    .   .    .    .   .    .    .  	      if (name == NULL)
  .    .    .   .    .    .   .    .    .  		/* Ignore the path.  */
 20    0    0   0    0    0   0    0    0  		return -1;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  afct = afct->next;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Open the file.  We always open files read-only.  */
115    0    0  23    0    0  46    1    1    int fd = __open (name, O_RDONLY | O_CLOEXEC);
 46    0    0   0    0    0   0    0    0    if (fd != -1)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        ElfW(Ehdr) *ehdr;
  .    .    .   .    .    .   .    .    .        ElfW(Phdr) *phdr, *ph;
  .    .    .   .    .    .   .    .    .        ElfW(Word) *abi_note;
  6    1    1   0    0    0   3    0    0        ElfW(Word) *abi_note_malloced = NULL;
  .    .    .   .    .    .   .    .    .        unsigned int osversion;
  .    .    .   .    .    .   .    .    .        size_t maplength;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* We successfully openened the file.  Now verify it is a file
  .    .    .   .    .    .   .    .    .  	 we can use.  */
  3    0    0   0    0    0   3    0    0        __set_errno (0);
  6    1    1   0    0    0   3    1    1        fbp->len = 0;
  .    .    .   .    .    .   .    .    .        assert (sizeof (fbp->buf) > sizeof (ElfW(Ehdr)));
  .    .    .   .    .    .   .    .    .        /* Read in the header.  */
  .    .    .   .    .    .   .    .    .        do
  .    .    .   .    .    .   .    .    .          {
 18    0    0   3    0    0   3    0    0            ssize_t retlen = __libc_read (fd, fbp->buf + fbp->len,
  .    .    .   .    .    .   .    .    .  					sizeof (fbp->buf) - fbp->len);
  6    0    0   0    0    0   0    0    0  	  if (retlen <= 0)
  .    .    .   .    .    .   .    .    .  	    break;
  9    0    0   3    0    0   3    0    0  	  fbp->len += retlen;
  .    .    .   .    .    .   .    .    .  	}
  6    0    0   0    0    0   0    0    0        while (__builtin_expect (fbp->len < sizeof (ElfW(Ehdr)), 0));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* This is where the ELF header is loaded.  */
  .    .    .   .    .    .   .    .    .        ehdr = (ElfW(Ehdr) *) fbp->buf;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Now run the tests.  */
  6    0    0   0    0    0   0    0    0        if (__builtin_expect (fbp->len < (ssize_t) sizeof (ElfW(Ehdr)), 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errval = errno;
  .    .    .   .    .    .   .    .    .  	  errstring = (errval == 0
  .    .    .   .    .    .   .    .    .  		       ? N_("file too short") : N_("cannot read file data"));
  .    .    .   .    .    .   .    .    .  	call_lose:
  .    .    .   .    .    .   .    .    .  	  if (free_name)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      char *realname = (char *) name;
  .    .    .   .    .    .   .    .    .  	      name = strdupa (realname);
  .    .    .   .    .    .   .    .    .  	      free (realname);
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	  lose (errval, fd, name, NULL, NULL, errstring, NULL, 0);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* See whether the ELF header is what we expect.  */
 39    4    4   0    0    0   4    0    0        if (__builtin_expect (! VALID_ELF_HEADER (ehdr->e_ident, expected,
  .    .    .   .    .    .   .    .    .  						EI_ABIVERSION)
  3    0    0   3    0    0   0    0    0  			    || !VALID_ELF_ABIVERSION (ehdr->e_ident[EI_OSABI],
  .    .    .   .    .    .   .    .    .  						      ehdr->e_ident[EI_ABIVERSION])
 12    0    0   0    0    0   3    0    0  			    || memcmp (&ehdr->e_ident[EI_PAD],
  .    .    .   .    .    .   .    .    .  				       &expected[EI_PAD],
  .    .    .   .    .    .   .    .    .  				       EI_NIDENT - EI_PAD) != 0,
  .    .    .   .    .    .   .    .    .  			    0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* Something is wrong.  */
  .    .    .   .    .    .   .    .    .  	  const Elf32_Word *magp = (const void *) ehdr->e_ident;
  .    .    .   .    .    .   .    .    .  	  if (*magp !=
  .    .    .   .    .    .   .    .    .  #if BYTE_ORDER == LITTLE_ENDIAN
-- line 1805 ----------------------------------------
-- line 1845 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	    errstring = N_("nonzero padding in e_ident");
  .    .    .   .    .    .   .    .    .  	  else
  .    .    .   .    .    .   .    .    .  	    /* Otherwise we don't know what went wrong.  */
  .    .    .   .    .    .   .    .    .  	    errstring = N_("internal error");
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  6    0    0   3    0    0   0    0    0        if (__builtin_expect (ehdr->e_version, EV_CURRENT) != EV_CURRENT)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("ELF file version does not match current one");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  6    0    0   3    0    0   0    0    0        if (! __builtin_expect (elf_machine_matches_host (ehdr), 1))
  .    .    .   .    .    .   .    .    .  	goto close_and_out;
  3    0    0   3    0    0   0    0    0        else if (__builtin_expect (ehdr->e_type, ET_DYN) != ET_DYN
  9    0    0   0    0    0   0    0    0  	       && __builtin_expect (ehdr->e_type, ET_EXEC) != ET_EXEC)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("only ET_DYN and ET_EXEC can be loaded");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  6    0    0   0    0    0   0    0    0        else if (__glibc_unlikely (ehdr->e_type == ET_EXEC
  .    .    .   .    .    .   .    .    .  				 && (mode & __RTLD_OPENEXEC) == 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* BZ #16634. It is an error to dlopen ET_EXEC (unless
  .    .    .   .    .    .   .    .    .  	     __RTLD_OPENEXEC is explicitly set).  We return error here
  .    .    .   .    .    .   .    .    .  	     so that code in _dl_map_object_from_fd does not try to set
  .    .    .   .    .    .   .    .    .  	     l_tls_modid for this module.  */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  errstring = N_("cannot dynamically load executable");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  6    1    1   3    2    2   0    0    0        else if (__builtin_expect (ehdr->e_phentsize, sizeof (ElfW(Phdr)))
  .    .    .   .    .    .   .    .    .  	       != sizeof (ElfW(Phdr)))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("ELF file's phentsize not the expected size");
  .    .    .   .    .    .   .    .    .  	  goto call_lose;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
 15    0    0   3    0    0   0    0    0        maplength = ehdr->e_phnum * sizeof (ElfW(Phdr));
 12    0    0   3    0    0   0    0    0        if (ehdr->e_phoff + maplength <= (size_t) fbp->len)
  3    0    0   0    0    0   0    0    0  	phdr = (void *) (fbp->buf + ehdr->e_phoff);
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  phdr = alloca (maplength);
  .    .    .   .    .    .   .    .    .  	  __lseek (fd, ehdr->e_phoff, SEEK_SET);
  .    .    .   .    .    .   .    .    .  	  if ((size_t) __libc_read (fd, (void *) phdr, maplength) != maplength)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	    read_error:
  .    .    .   .    .    .   .    .    .  	      errval = errno;
  .    .    .   .    .    .   .    .    .  	      errstring = N_("cannot read file data");
  .    .    .   .    .    .   .    .    .  	      goto call_lose;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Check .note.ABI-tag if present.  */
148    0    0   0    0    0   0    0    0        for (ph = phdr; ph < &phdr[ehdr->e_phnum]; ++ph)
 53    1    1  25   10   10   0    0    0  	if (ph->p_type == PT_NOTE && ph->p_filesz >= 32 && ph->p_align >= 4)
  .    .    .   .    .    .   .    .    .  	  {
  .    .    .   .    .    .   .    .    .  	    ElfW(Addr) size = ph->p_filesz;
  .    .    .   .    .    .   .    .    .  
 12    0    0   6    0    0   0    0    0  	    if (ph->p_offset + size <= (size_t) fbp->len)
  3    0    0   0    0    0   0    0    0  	      abi_note = (void *) (fbp->buf + ph->p_offset);
  .    .    .   .    .    .   .    .    .  	    else
  .    .    .   .    .    .   .    .    .  	      {
  .    .    .   .    .    .   .    .    .  		/* Note: __libc_use_alloca is not usable here, because
  .    .    .   .    .    .   .    .    .  		   thread info may not have been set up yet.  */
  .    .    .   .    .    .   .    .    .  		if (size < __MAX_ALLOCA_CUTOFF)
  .    .    .   .    .    .   .    .    .  		  abi_note = alloca (size);
  .    .    .   .    .    .   .    .    .  		else
  .    .    .   .    .    .   .    .    .  		  {
-- line 1915 ----------------------------------------
-- line 1923 ----------------------------------------
  .    .    .   .    .    .   .    .    .  		__lseek (fd, ph->p_offset, SEEK_SET);
  .    .    .   .    .    .   .    .    .  		if (__libc_read (fd, (void *) abi_note, size) != size)
  .    .    .   .    .    .   .    .    .  		  {
  .    .    .   .    .    .   .    .    .  		    free (abi_note_malloced);
  .    .    .   .    .    .   .    .    .  		    goto read_error;
  .    .    .   .    .    .   .    .    .  		  }
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  
 30    1    1   0    0    0   5    0    0  	    while (memcmp (abi_note, &expected_note, sizeof (expected_note)))
  .    .    .   .    .    .   .    .    .  	      {
  .    .    .   .    .    .   .    .    .  #define ROUND(len) (((len) + sizeof (ElfW(Word)) - 1) & -sizeof (ElfW(Word)))
  3    0    0   0    0    0   0    0    0  		ElfW(Addr) note_size = 3 * sizeof (ElfW(Word))
  9    1    1   3    0    0   0    0    0  				       + ROUND (abi_note[0])
  9    0    0   3    0    0   0    0    0  				       + ROUND (abi_note[1]);
  .    .    .   .    .    .   .    .    .  
  9    0    0   0    0    0   0    0    0  		if (size - 32 < note_size)
  .    .    .   .    .    .   .    .    .  		  {
  .    .    .   .    .    .   .    .    .  		    size = 0;
  .    .    .   .    .    .   .    .    .  		    break;
  .    .    .   .    .    .   .    .    .  		  }
  2    0    0   0    0    0   0    0    0  		size -= note_size;
  2    0    0   0    0    0   0    0    0  		abi_note = (void *) abi_note + note_size;
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   0    0    0  	    if (size == 0)
  .    .    .   .    .    .   .    .    .  	      continue;
  .    .    .   .    .    .   .    .    .  
  6    0    0   2    0    0   0    0    0  	    osversion = (abi_note[5] & 0xff) * 65536
 10    0    0   2    0    0   0    0    0  			+ (abi_note[6] & 0xff) * 256
  4    0    0   2    0    0   0    0    0  			+ (abi_note[7] & 0xff);
  6    0    0   2    0    0   0    0    0  	    if (abi_note[4] != __ABI_TAG_OS
 10    1    1   2    0    0   0    0    0  		|| (GLRO(dl_osversion) && GLRO(dl_osversion) < osversion))
  .    .    .   .    .    .   .    .    .  	      {
  .    .    .   .    .    .   .    .    .  	      close_and_out:
  .    .    .   .    .    .   .    .    .  		__close (fd);
  .    .    .   .    .    .   .    .    .  		__set_errno (ENOENT);
  .    .    .   .    .    .   .    .    .  		fd = -1;
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	    break;
  .    .    .   .    .    .   .    .    .  	  }
  9    1    1   6    0    0   3    0    0        free (abi_note_malloced);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return fd;
186    1    1 162    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Try to open NAME in one of the directories in *DIRSP.
  .    .    .   .    .    .   .    .    .     Return the fd, or -1.  If successful, fill in *REALNAME
  .    .    .   .    .    .   .    .    .     with the malloc'd full directory name.  If it turns out
  .    .    .   .    .    .   .    .    .     that none of the directories in *DIRSP exists, *DIRSP is
  .    .    .   .    .    .   .    .    .     replaced with (void *) -1, and the old value is free()d
  .    .    .   .    .    .   .    .    .     if MAY_FREE_DIRS is true.  */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  open_path (const char *name, size_t namelen, int mode,
  .    .    .   .    .    .   .    .    .  	   struct r_search_path_struct *sps, char **realname,
  .    .    .   .    .    .   .    .    .  	   struct filebuf *fbp, struct link_map *loader, int whatcode,
  .    .    .   .    .    .   .    .    .  	   bool *found_other_class)
 28    2    2   0    0    0  24    2    2  {
  4    0    0   2    0    0   2    0    0    struct r_search_path_elem **dirs = sps->dirs;
  .    .    .   .    .    .   .    .    .    char *buf;
  .    .    .   .    .    .   .    .    .    int fd = -1;
  2    0    0   0    0    0   2    0    0    const char *current_what = NULL;
  2    0    0   0    0    0   2    0    0    int any = 0;
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0    if (__builtin_expect (dirs == NULL, 0))
  .    .    .   .    .    .   .    .    .      /* We're called before _dl_init_paths when loading the main executable
  .    .    .   .    .    .   .    .    .         given on the command line when rtld is run directly.  */
  .    .    .   .    .    .   .    .    .      return -1;
  .    .    .   .    .    .   .    .    .  
 38    2    2   6    1    1   0    0    0    buf = alloca (max_dirnamelen + max_capstrlen + namelen);
  .    .    .   .    .    .   .    .    .    do
  .    .    .   .    .    .   .    .    .      {
  8    0    0   8    0    0   0    0    0        struct r_search_path_elem *this_dir = *dirs;
  .    .    .   .    .    .   .    .    .        size_t buflen = 0;
  .    .    .   .    .    .   .    .    .        size_t cnt;
  .    .    .   .    .    .   .    .    .        char *edp;
 16    0    0   0    0    0   0    0    0        int here_any = 0;
  .    .    .   .    .    .   .    .    .        int err;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* If we are debugging the search for libraries print the path
  .    .    .   .    .    .   .    .    .  	 now if it hasn't happened now.  */
 16    0    0   8    0    0   0    0    0        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0)
  .    .    .   .    .    .   .    .    .  	  && current_what != this_dir->what)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  current_what = this_dir->what;
  .    .    .   .    .    .   .    .    .  	  print_search_path (dirs, current_what, this_dir->where);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
 40    0    0  16    0    0  16    1    1        edp = (char *) __mempcpy (buf, this_dir->dirname, this_dir->dirnamelen);
144    1    1  12    0    0   0    0    0        for (cnt = 0; fd == -1 && cnt < ncapstr; ++cnt)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* Skip this directory if we know it does not exist.  */
 64    1    1  32    0    0   0    0    0  	  if (this_dir->status[cnt] == nonexisting)
  .    .    .   .    .    .   .    .    .  	    continue;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  buflen =
260    1    1 120    0    0  40    0    0  	    ((char *) __mempcpy (__mempcpy (edp, capstr[cnt].str,
  .    .    .   .    .    .   .    .    .  					    capstr[cnt].len),
  .    .    .   .    .    .   .    .    .  				 name, namelen)
 20    0    0   0    0    0   0    0    0  	     - buf);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Print name we try if this is wanted.  */
 40    1    1  20    0    0   0    0    0  	  if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
  .    .    .   .    .    .   .    .    .  	    _dl_debug_printf ("  trying file=%s\n", buf);
  .    .    .   .    .    .   .    .    .  
180    0    0 100    0    0  40    0    0  	  fd = open_verify (buf, fbp, loader, whatcode, mode,
  .    .    .   .    .    .   .    .    .  			    found_other_class, false);
 60    0    0  20    0    0   0    0    0  	  if (this_dir->status[cnt] == unknown)
  .    .    .   .    .    .   .    .    .  	    {
 32    0    0   0    0    0   0    0    0  	      if (fd != -1)
  .    .    .   .    .    .   .    .    .  		this_dir->status[cnt] = existing;
  .    .    .   .    .    .   .    .    .  	      /* Do not update the directory information when loading
  .    .    .   .    .    .   .    .    .  		 auditing code.  We must try to disturb the program as
  .    .    .   .    .    .   .    .    .  		 little as possible.  */
 32    1    1  16    0    0   0    0    0  	      else if (loader == NULL
144    1    1  64    0    0   0    0    0  		       || GL(dl_ns)[loader->l_ns]._ns_loaded->l_auditing == 0)
  .    .    .   .    .    .   .    .    .  		{
  .    .    .   .    .    .   .    .    .  		  /* We failed to open machine dependent library.  Let's
  .    .    .   .    .    .   .    .    .  		     test whether there is any directory at all.  */
  .    .    .   .    .    .   .    .    .  		  struct stat64 st;
  .    .    .   .    .    .   .    .    .  
 58    0    0  20    0    0  18    0    0  		  buf[buflen - namelen - 1] = '\0';
  .    .    .   .    .    .   .    .    .  
 96    1    1  16    0    0  16    0    0  		  if (__xstat64 (_STAT_VER, buf, &st) != 0
  8    0    0   4    1    1   0    0    0  		      || ! S_ISDIR (st.st_mode))
  .    .    .   .    .    .   .    .    .  		    /* The directory does not exist or it is no directory.  */
 84    2    2  16    0    0  16    0    0  		    this_dir->status[cnt] = nonexisting;
  .    .    .   .    .    .   .    .    .  		  else
  .    .    .   .    .    .   .    .    .  		    this_dir->status[cnt] = existing;
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Remember whether we found any existing directory.  */
 48    0    0   0    0    0   0    0    0  	  here_any |= this_dir->status[cnt] != nonexisting;
  .    .    .   .    .    .   .    .    .  
 18    0    0   2    0    0   2    0    0  	  if (fd != -1 && __builtin_expect (mode & __RTLD_SECURE, 0)
  .    .    .   .    .    .   .    .    .  	      && INTUSE(__libc_enable_secure))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* This is an extra security effort to make sure nobody can
  .    .    .   .    .    .   .    .    .  		 preload broken shared objects which are in the trusted
  .    .    .   .    .    .   .    .    .  		 directories and so exploit the bugs.  */
  .    .    .   .    .    .   .    .    .  	      struct stat64 st;
  .    .    .   .    .    .   .    .    .  
  4    1    1   0    0    0   2    0    0  	      if (__fxstat64 (_STAT_VER, fd, &st) != 0
  .    .    .   .    .    .   .    .    .  		  || (st.st_mode & S_ISUID) == 0)
  .    .    .   .    .    .   .    .    .  		{
  .    .    .   .    .    .   .    .    .  		  /* The shared object cannot be tested for being SUID
  .    .    .   .    .    .   .    .    .  		     or this bit is not set.  In this case we must not
  .    .    .   .    .    .   .    .    .  		     use this object.  */
  .    .    .   .    .    .   .    .    .  		  __close (fd);
  .    .    .   .    .    .   .    .    .  		  fd = -1;
  .    .    .   .    .    .   .    .    .  		  /* We simply ignore the file, signal this by setting
-- line 2076 ----------------------------------------
-- line 2088 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	      memcpy (*realname, buf, buflen);
  .    .    .   .    .    .   .    .    .  	      return fd;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	  else
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* No memory for the name, we certainly won't be able
  .    .    .   .    .    .   .    .    .  		 to load and link it.  */
  .    .    .   .    .    .   .    .    .  	      __close (fd);
  2    0    0   0    0    0   0    0    0  	      return -1;
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	}
 40    0    0   8    0    0   0    0    0        if (here_any && (err = errno) != ENOENT && err != EACCES)
  .    .    .   .    .    .   .    .    .  	/* The file exists and is readable, but something went wrong.  */
  .    .    .   .    .    .   .    .    .  	return -1;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Remember whether we found anything.  */
  8    0    0   8    0    0   0    0    0        any |= here_any;
  .    .    .   .    .    .   .    .    .      }
 32    1    1  24    0    0   0    0    0    while (*++dirs != NULL);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Remove the whole path if none of the directories exists.  */
  6    0    0   2    0    0   0    0    0    if (__builtin_expect (! any, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Paths which were allocated using the minimal malloc() in ld.so
  .    .    .   .    .    .   .    .    .  	 must not be freed using the general free() in libc.  */
  .    .    .   .    .    .   .    .    .        if (sps->malloced)
  .    .    .   .    .    .   .    .    .  	free (sps->dirs);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* rtld_search_dirs and env_path_list are attribute_relro, therefore
  .    .    .   .    .    .   .    .    .           avoid writing into it.  */
  .    .    .   .    .    .   .    .    .        if (sps != &rtld_search_dirs && sps != &env_path_list)
  .    .    .   .    .    .   .    .    .  	sps->dirs = (void *) -1;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return -1;
 28    1    1  14    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Map in the shared object file NAME.  */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  struct link_map *
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  _dl_map_object (struct link_map *loader, const char *name,
  .    .    .   .    .    .   .    .    .  		int type, int trace_mode, int mode, Lmid_t nsid)
 78    2    2   0    0    0  48    5    5  {
  .    .    .   .    .    .   .    .    .    int fd;
  6    0    0   0    0    0   3    0    0    const char *origname = NULL;
  .    .    .   .    .    .   .    .    .    char *realname;
  .    .    .   .    .    .   .    .    .    char *name_copy;
  .    .    .   .    .    .   .    .    .    struct link_map *l;
  .    .    .   .    .    .   .    .    .    struct filebuf fb;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    assert (nsid >= 0);
  .    .    .   .    .    .   .    .    .    assert (nsid < GL(dl_nns));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Look for this name among those already loaded.  */
 81    0    0  21    0    0   0    0    0    for (l = GL(dl_ns)[nsid]._ns_loaded; l; l = l->l_next)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* If the requested name matches the soname of a loaded object,
  .    .    .   .    .    .   .    .    .  	 use that object.  Elide this check for names that have not
  .    .    .   .    .    .   .    .    .  	 yet been opened.  */
 54    1    1  18    0    0   0    0    0        if (__builtin_expect (l->l_faked, 0) != 0
 36    0    0   0    0    0   0    0    0  	  || __builtin_expect (l->l_removed, 0) != 0)
  .    .    .   .    .    .   .    .    .  	continue;
 93    0    0   0    0    0  18    2    2        if (!_dl_name_match_p (name, l))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  const char *soname;
  .    .    .   .    .    .   .    .    .  
 30    0    0  15    0    0   0    0    0  	  if (__builtin_expect (l->l_soname_added, 1)
 45    1    1  15    0    0   0    0    0  	      || l->l_info[DT_SONAME] == NULL)
  .    .    .   .    .    .   .    .    .  	    continue;
  .    .    .   .    .    .   .    .    .  
  6    0    0   6    0    0   0    0    0  	  soname = ((const char *) D_PTR (l, l_info[DT_STRTAB])
 12    0    0  12    0    0   0    0    0  		    + l->l_info[DT_SONAME]->d_un.d_val);
 24    0    0   0    0    0   6    0    0  	  if (strcmp (name, soname) != 0)
  .    .    .   .    .    .   .    .    .  #ifdef __arm__
  .    .    .   .    .    .   .    .    .  	    if (strcmp (name, "ld-linux.so.3")
  .    .    .   .    .    .   .    .    .  		|| strcmp (soname, "ld-linux-armhf.so.3"))
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  	      continue;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* We have a match on a new name -- cache it.  */
  .    .    .   .    .    .   .    .    .  	  add_name_to_object (l, name);
-- line 2169 ----------------------------------------
-- line 2170 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	  l->l_soname_added = 1;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* We have a match.  */
  .    .    .   .    .    .   .    .    .        return l;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Display information if we are debugging.  */
  6    0    0   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0)
  .    .    .   .    .    .   .    .    .        && loader != NULL)
  .    .    .   .    .    .   .    .    .      _dl_debug_printf ((mode & __RTLD_CALLMAP) == 0
  .    .    .   .    .    .   .    .    .  		      ? "\nfile=%s [%lu];  needed by %s [%lu]\n"
  .    .    .   .    .    .   .    .    .  		      : "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n",
  .    .    .   .    .    .   .    .    .  		      name, nsid, loader->l_name[0]
  .    .    .   .    .    .   .    .    .  		      ? loader->l_name : rtld_progname, loader->l_ns);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .    /* Give the auditing libraries a chance to change the name before we
  .    .    .   .    .    .   .    .    .       try anything.  */
 12    1    1   3    0    0   0    0    0    if (__builtin_expect (GLRO(dl_naudit) > 0, 0)
  .    .    .   .    .    .   .    .    .        && (loader == NULL || loader->l_auditing == 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        struct audit_ifaces *afct = GLRO(dl_audit);
  .    .    .   .    .    .   .    .    .        for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  if (afct->objsearch != NULL)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      const char *before = name;
-- line 2197 ----------------------------------------
-- line 2215 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  afct = afct->next;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Will be true if we found a DSO which is of the other ELF class.  */
  3    0    0   0    0    0   3    2    2    bool found_other_class = false;
  .    .    .   .    .    .   .    .    .  
 15    0    0   0    0    0   3    0    0    if (strchr (name, '/') == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Search for NAME in several places.  */
  .    .    .   .    .    .   .    .    .  
  8    2    2   0    0    0   4    0    0        size_t namelen = strlen (name) + 1;
  .    .    .   .    .    .   .    .    .  
  4    0    0   2    0    0   0    0    0        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
  .    .    .   .    .    .   .    .    .  	_dl_debug_printf ("find library=%s [%lu]; searching\n", name, nsid);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        fd = -1;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* When the object has the RUNPATH information we don't use any
  .    .    .   .    .    .   .    .    .  	 RPATHs.  */
  8    0    0   2    0    0   0    0    0        if (loader == NULL || loader->l_info[DT_RUNPATH] == NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* This is the executable's map (if there is one).  Make sure that
  .    .    .   .    .    .   .    .    .  	     we do not look at it twice.  */
  8    1    1   2    0    0   6    0    0  	  struct link_map *main_map = GL(dl_ns)[LM_ID_BASE]._ns_loaded;
  4    0    0   0    0    0   2    0    0  	  bool did_main_map = false;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* First try the DT_RPATH of the dependent object that caused NAME
  .    .    .   .    .    .   .    .    .  	     to be loaded.  Then that object's dependent, and on up.  */
  6    0    0   2    0    0   0    0    0  	  for (l = loader; l; l = l->l_loader)
  2    0    0   0    0    0   0    0    0  	    if (cache_rpath (l, &l->l_rpath_dirs, DT_RPATH, "RPATH"))
  .    .    .   .    .    .   .    .    .  	      {
 14    1    1   0    0    0   4    0    0  		fd = open_path (name, namelen, mode,
  .    .    .   .    .    .   .    .    .  				&l->l_rpath_dirs,
  .    .    .   .    .    .   .    .    .  				&realname, &fb, loader, LA_SER_RUNPATH,
  .    .    .   .    .    .   .    .    .  				&found_other_class);
  .    .    .   .    .    .   .    .    .  		if (fd != -1)
  .    .    .   .    .    .   .    .    .  		  break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  		did_main_map |= l == main_map;
  .    .    .   .    .    .   .    .    .  	      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* If dynamically linked, try the DT_RPATH of the executable
  .    .    .   .    .    .   .    .    .  	     itself.  NB: we do this for lookups in any namespace.  */
  8    1    1   6    0    0   0    0    0  	  if (fd == -1 && !did_main_map
 14    1    1   4    0    0   0    0    0  	      && main_map != NULL && main_map->l_type != lt_loaded
  2    0    0   0    0    0   0    0    0  	      && cache_rpath (main_map, &main_map->l_rpath_dirs, DT_RPATH,
  .    .    .   .    .    .   .    .    .  			      "RPATH"))
  .    .    .   .    .    .   .    .    .  	    fd = open_path (name, namelen, mode,
  .    .    .   .    .    .   .    .    .  			    &main_map->l_rpath_dirs,
  .    .    .   .    .    .   .    .    .  			    &realname, &fb, loader ?: main_map, LA_SER_RUNPATH,
  .    .    .   .    .    .   .    .    .  			    &found_other_class);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Try the LD_LIBRARY_PATH environment variable.  */
  4    0    0   2    0    0   0    0    0        if (fd == -1 && env_path_list.dirs != (void *) -1)
 34    1    1   4    0    0   8    0    0  	fd = open_path (name, namelen, mode, &env_path_list,
  .    .    .   .    .    .   .    .    .  			&realname, &fb,
  .    .    .   .    .    .   .    .    .  			loader ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded,
  .    .    .   .    .    .   .    .    .  			LA_SER_LIBPATH, &found_other_class);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Look at the RUNPATH information for this binary.  */
 12    1    1   0    0    0   4    0    0        if (fd == -1 && loader != NULL
  2    0    0   0    0    0   0    0    0  	  && cache_rpath (loader, &loader->l_runpath_dirs,
  .    .    .   .    .    .   .    .    .  			  DT_RUNPATH, "RUNPATH"))
  4    1    1   2    0    0   2    0    0  	fd = open_path (name, namelen, mode,
  .    .    .   .    .    .   .    .    .  			&loader->l_runpath_dirs, &realname, &fb, loader,
  .    .    .   .    .    .   .    .    .  			LA_SER_RUNPATH, &found_other_class);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef USE_LDCONFIG
  .    .    .   .    .    .   .    .    .        if (fd == -1
  4    0    0   0    0    0   0    0    0  	  && (__builtin_expect (! (mode & __RTLD_SECURE), 1)
  .    .    .   .    .    .   .    .    .  	      || ! INTUSE(__libc_enable_secure))
  6    0    0   2    0    0   0    0    0  	  && __builtin_expect (GLRO(dl_inhibit_cache) == 0, 1))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* Check the list of libraries in the file /etc/ld.so.cache,
  .    .    .   .    .    .   .    .    .  	     for compatibility with Linux's ldconfig program.  */
  6    1    1   0    0    0   2    0    0  	  char *cached = _dl_load_cache_lookup (name);
  .    .    .   .    .    .   .    .    .  
  4    0    0   0    0    0   0    0    0  	  if (cached != NULL)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  # ifdef SHARED
  .    .    .   .    .    .   .    .    .  	      // XXX Correct to unconditionally default to namespace 0?
  .    .    .   .    .    .   .    .    .  	      l = (loader
  6    0    0   2    0    0   0    0    0  		   ?: GL(dl_ns)[LM_ID_BASE]._ns_loaded
  .    .    .   .    .    .   .    .    .  		   ?: &GL(dl_rtld_map));
  .    .    .   .    .    .   .    .    .  # else
  .    .    .   .    .    .   .    .    .  	      l = loader;
  .    .    .   .    .    .   .    .    .  # endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	      /* If the loader has the DF_1_NODEFLIB flag set we must not
  .    .    .   .    .    .   .    .    .  		 use a cache entry from any of these directories.  */
  4    0    0   2    0    0   0    0    0  	      if (
  .    .    .   .    .    .   .    .    .  # ifndef SHARED
  .    .    .   .    .    .   .    .    .  		  /* 'l' is always != NULL for dynamically linked objects.  */
  .    .    .   .    .    .   .    .    .  		  l != NULL &&
  .    .    .   .    .    .   .    .    .  # endif
  .    .    .   .    .    .   .    .    .  		  __builtin_expect (l->l_flags_1 & DF_1_NODEFLIB, 0))
  .    .    .   .    .    .   .    .    .  		{
  .    .    .   .    .    .   .    .    .  		  const char *dirp = system_dirs;
  .    .    .   .    .    .   .    .    .  		  unsigned int cnt = 0;
-- line 2318 ----------------------------------------
-- line 2330 ----------------------------------------
  .    .    .   .    .    .   .    .    .  		      dirp += system_dirs_len[cnt] + 1;
  .    .    .   .    .    .   .    .    .  		      ++cnt;
  .    .    .   .    .    .   .    .    .  		    }
  .    .    .   .    .    .   .    .    .  		  while (cnt < nsystem_dirs_len);
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	      if (cached != NULL)
  .    .    .   .    .    .   .    .    .  		{
 24    1    1   2    0    0   6    0    0  		  fd = open_verify (cached,
  .    .    .   .    .    .   .    .    .  				    &fb, loader ?: GL(dl_ns)[nsid]._ns_loaded,
  .    .    .   .    .    .   .    .    .  				    LA_SER_CONFIG, mode, &found_other_class,
  .    .    .   .    .    .   .    .    .  				    false);
  6    0    0   2    0    0   0    0    0  		  if (__builtin_expect (fd != -1, 1))
  4    0    0   0    0    0   2    0    0  		    realname = cached;
  .    .    .   .    .    .   .    .    .  		  else
  .    .    .   .    .    .   .    .    .  		    free (cached);
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Finally, try the default path.  */
-- line 2351 ----------------------------------------
-- line 2352 ----------------------------------------
  .    .    .   .    .    .   .    .    .        if (fd == -1
  .    .    .   .    .    .   .    .    .  	  && ((l = loader ?: GL(dl_ns)[nsid]._ns_loaded) == NULL
  .    .    .   .    .    .   .    .    .  	      || __builtin_expect (!(l->l_flags_1 & DF_1_NODEFLIB), 1))
  .    .    .   .    .    .   .    .    .  	  && rtld_search_dirs.dirs != (void *) -1)
  .    .    .   .    .    .   .    .    .  	fd = open_path (name, namelen, mode, &rtld_search_dirs,
  .    .    .   .    .    .   .    .    .  			&realname, &fb, l, LA_SER_DEFAULT, &found_other_class);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Add another newline when we are tracing the library loading.  */
  4    1    1   2    0    0   0    0    0        if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_LIBS, 0))
  .    .    .   .    .    .   .    .    .  	_dl_debug_printf ("\n");
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* The path may contain dynamic string tokens.  */
  1    0    0   0    0    0   1    0    0        realname = (loader
  .    .    .   .    .    .   .    .    .  		  ? expand_dynamic_string_token (loader, name)
  5    1    1   0    0    0   1    0    0  		  : local_strdup (name));
  3    0    0   0    0    0   0    0    0        if (realname == NULL)
  1    0    0   0    0    0   0    0    0  	fd = -1;
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	{
  8    0    0   0    0    0   2    0    0  	  fd = open_verify (realname, &fb,
  .    .    .   .    .    .   .    .    .  			    loader ?: GL(dl_ns)[nsid]._ns_loaded, 0, mode,
  .    .    .   .    .    .   .    .    .  			    &found_other_class, true);
  2    1    1   0    0    0   0    0    0  	  if (__builtin_expect (fd, 0) == -1)
  .    .    .   .    .    .   .    .    .  	    free (realname);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  #ifdef SHARED
  .    .    .   .    .    .   .    .    .   no_file:
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .    /* In case the LOADER information has only been provided to get to
  .    .    .   .    .    .   .    .    .       the appropriate RUNPATH/RPATH information we do not need it
  .    .    .   .    .    .   .    .    .       anymore.  */
  .    .    .   .    .    .   .    .    .    if (mode & __RTLD_CALLMAP)
  9    0    0   0    0    0   0    0    0      loader = NULL;
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0    if (__builtin_expect (fd, 0) == -1)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (trace_mode
  .    .    .   .    .    .   .    .    .  	  && __builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK, 0) == 0)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* We haven't found an appropriate library.  But since we
  .    .    .   .    .    .   .    .    .  	     are only interested in the list of libraries this isn't
  .    .    .   .    .    .   .    .    .  	     so severe.  Fake an entry with all the information we
  .    .    .   .    .    .   .    .    .  	     have.  */
-- line 2398 ----------------------------------------
-- line 2426 ----------------------------------------
  .    .    .   .    .    .   .    .    .  			  ELFW(CLASS) == ELFCLASS32
  .    .    .   .    .    .   .    .    .  			  ? N_("wrong ELF class: ELFCLASS64")
  .    .    .   .    .    .   .    .    .  			  : N_("wrong ELF class: ELFCLASS32"));
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	_dl_signal_error (errno, name, NULL,
  .    .    .   .    .    .   .    .    .  			  N_("cannot open shared object file"));
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  6    0    0   3    0    0   3    0    0    void *stack_end = __libc_stack_end;
 39    1    1   9    0    0  15    0    0    return _dl_map_object_from_fd (name, origname, fd, &fb, realname, loader,
  .    .    .   .    .    .   .    .    .  				 type, mode, &stack_end, nsid);
 48    0    0  42    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  void
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  _dl_rtld_di_serinfo (struct link_map *loader, Dl_serinfo *si, bool counting)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    if (counting)
  .    .    .   .    .    .   .    .    .      {
-- line 2445 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/strcmp.S
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr    D1mr DLmr Dw D1mw DLmw 

-- line 124 ----------------------------------------
    .    .    .     .    .    .  .    .    .  libc_hidden_def (__strncasecmp)
    .    .    .     .    .    .  .    .    .  # endif
    .    .    .     .    .    .  .    .    .  	/* FALLTHROUGH to strncasecmp_l.  */
    .    .    .     .    .    .  .    .    .  #endif
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  ENTRY (STRCMP)
    .    .    .     .    .    .  .    .    .  #if !IS_IN (libc)
    .    .    .     .    .    .  .    .    .  /* Simple version since we can't use SSE registers in ld.so.  */
5,443    1    1 5,443  129   76  0    0    0  L(oop):	movb	(%rdi), %al
5,443    0    0 5,443   22    7  0    0    0  	cmpb	(%rsi), %al
5,443    0    0     0    0    0  0    0    0  	jne	L(neq)
4,641    0    0     0    0    0  0    0    0  	incq	%rdi
4,641    0    0     0    0    0  0    0    0  	incq	%rsi
4,641    0    0     0    0    0  0    0    0  	testb	%al, %al
4,641    0    0     0    0    0  0    0    0  	jnz	L(oop)
    .    .    .     .    .    .  .    .    .  
  343    0    0     0    0    0  0    0    0  	xorl	%eax, %eax
  343    0    0   343    0    0  0    0    0  	ret
    .    .    .     .    .    .  .    .    .  
  802    0    0     0    0    0  0    0    0  L(neq):	movl	$1, %eax
  802    0    0     0    0    0  0    0    0  	movl	$-1, %ecx
  802    0    0     0    0    0  0    0    0  	cmovbl	%ecx, %eax
  802    0    0   802    0    0  0    0    0  	ret
    .    .    .     .    .    .  .    .    .  END (STRCMP)
    .    .    .     .    .    .  .    .    .  #else	/* !IS_IN (libc) */
    .    .    .     .    .    .  .    .    .  # ifdef USE_AS_STRCASECMP_L
    .    .    .     .    .    .  .    .    .  	/* We have to fall back on the C implementation for locales
    .    .    .     .    .    .  .    .    .  	   with encodings not matching ASCII for single bytes.  */
    .    .    .     .    .    .  .    .    .  #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
    .    .    .     .    .    .  .    .    .  	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rdx), %RAX_LP
    .    .    .     .    .    .  .    .    .  #  else
-- line 154 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 42 ----------------------------------------
 .    .    .  .    .    .  .    .    .  			DW.ref.__gcc_personality_v0)
 .    .    .  .    .    .  .    .    .  	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
 .    .    .  .    .    .  .    .    .  	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #define FRAME_SIZE (32+8)
 7    1    1  0    0    0  0    0    0  	leaq	-FRAME_SIZE(%rsp), %rsp
 .    .    .  .    .    .  .    .    .  	cfi_adjust_cfa_offset(FRAME_SIZE)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Stack frame:
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	   rsp + 32
 .    .    .  .    .    .  .    .    .  		    +--------------------------+
 .    .    .  .    .    .  .    .    .  	   rsp + 24 | old wake_seq value       |
 .    .    .  .    .    .  .    .    .  		    +--------------------------+
-- line 58 ----------------------------------------
-- line 61 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	   rsp +  8 | condvar pointer          |
 .    .    .  .    .    .  .    .    .  		    +--------------------------+
 .    .    .  .    .    .  .    .    .  	   rsp +  4 | old broadcast_seq value  |
 .    .    .  .    .    .  .    .    .  		    +--------------------------+
 .    .    .  .    .    .  .    .    .  	   rsp +  0 | old cancellation mode    |
 .    .    .  .    .    .  .    .    .  		    +--------------------------+
 .    .    .  .    .    .  .    .    .  	*/
 .    .    .  .    .    .  .    .    .  
 7    0    0  0    0    0  0    0    0  	LIBC_PROBE (cond_wait, 2, %rdi, %rsi)
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	LP_OP(cmp) $-1, dep_mutex(%rdi)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Prepare structure passed to cancellation handler.  */
 7    0    0  0    0    0  7    0    0  	movq	%rdi, 8(%rsp)
 7    1    1  0    0    0  7    0    0  	movq	%rsi, 16(%rsp)
 .    .    .  .    .    .  .    .    .  
 7    0    0  0    0    0  0    0    0  	je	15f
 7    0    0  0    0    0  7    0    0  	mov	%RSI_LP, dep_mutex(%rdi)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Get internal lock.  */
 7    0    0  0    0    0  0    0    0  15:	movl	$1, %esi
 7    0    0  0    0    0  0    0    0  	xorl	%eax, %eax
 7    0    0  7    1    1  0    0    0  	LOCK
 .    .    .  .    .    .  .    .    .  #if cond_lock == 0
 .    .    .  .    .    .  .    .    .  	cmpxchgl %esi, (%rdi)
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	cmpxchgl %esi, cond_lock(%rdi)
 .    .    .  .    .    .  .    .    .  #endif
 7    0    0  0    0    0  0    0    0  	jne	1f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Unlock the mutex.  */
 7    0    0  7    0    0  0    0    0  2:	movq	16(%rsp), %rdi
 7    0    0  0    0    0  0    0    0  	xorl	%esi, %esi
 7    0    0  0    0    0  7    0    0  	callq	__pthread_mutex_unlock_usercnt
 .    .    .  .    .    .  .    .    .  
 7    0    0  0    0    0  0    0    0  	testl	%eax, %eax
 7    0    0  0    0    0  0    0    0  	jne	12f
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	movq	8(%rsp), %rdi
 7    0    0  7    0    0  0    0    0  	incq	total_seq(%rdi)
 7    0    0  7    0    0  0    0    0  	incl	cond_futex(%rdi)
 7    0    0  7    0    0  0    0    0  	addl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Get and store current wakeup_seq value.  */
 7    1    1  7    0    0  0    0    0  	movq	8(%rsp), %rdi
 7    0    0  7    0    0  0    0    0  	movq	wakeup_seq(%rdi), %r9
 7    0    0  7    0    0  0    0    0  	movl	broadcast_seq(%rdi), %edx
 7    0    0  0    0    0  7    0    0  	movq	%r9, 24(%rsp)
 7    0    0  0    0    0  7    0    0  	movl	%edx, 4(%rsp)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Unlock.  */
 7    0    0  7    0    0  0    0    0  8:	movl	cond_futex(%rdi), %edx
 7    0    0 14    0    0  0    0    0  	LOCK
 .    .    .  .    .    .  .    .    .  #if cond_lock == 0
 .    .    .  .    .    .  .    .    .  	decl	(%rdi)
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	decl	cond_lock(%rdi)
 .    .    .  .    .    .  .    .    .  #endif
 7    0    0  0    0    0  0    0    0  	jne	3f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  .LcleanupSTART:
 7    0    0  0    0    0  7    0    0  4:	callq	__pthread_enable_asynccancel
 7    0    0  0    0    0  7    0    0  	movl	%eax, (%rsp)
 .    .    .  .    .    .  .    .    .  
 7    0    0  0    0    0  0    0    0  	xorq	%r10, %r10
 7    0    0  7    0    0  0    0    0  	LP_OP(cmp) $-1, dep_mutex(%rdi)
 7    0    0  0    0    0  0    0    0  	leaq	cond_futex(%rdi), %rdi
 7    0    0  0    0    0  0    0    0  	movl	$FUTEX_WAIT, %esi
 7    0    0  0    0    0  0    0    0  	je	60f
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	mov	dep_mutex-cond_futex(%rdi), %R8_LP
 .    .    .  .    .    .  .    .    .  	/* Requeue to a non-robust PI mutex if the PI bit is set and
 .    .    .  .    .    .  .    .    .  	the robust bit is not set.  */
 7    1    1  7    0    0  0    0    0  	movl	MUTEX_KIND(%r8), %eax
 7    0    0  0    0    0  0    0    0  	andl	$(ROBUST_BIT|PI_BIT), %eax
 7    0    0  0    0    0  0    0    0  	cmpl	$PI_BIT, %eax
 7    0    0  0    0    0  0    0    0  	jne	61f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	movl	$(FUTEX_WAIT_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
 .    .    .  .    .    .  .    .    .  	movl	$SYS_futex, %eax
 .    .    .  .    .    .  .    .    .  	syscall
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	cmpl	$0, %eax
 .    .    .  .    .    .  .    .    .  	sete	%r8b
 .    .    .  .    .    .  .    .    .  
-- line 145 ----------------------------------------
-- line 169 ----------------------------------------
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  # ifndef __ASSUME_PRIVATE_FUTEX
 .    .    .  .    .    .  .    .    .  	movl	$FUTEX_WAIT, %esi
 .    .    .  .    .    .  .    .    .  # endif
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  61:
 .    .    .  .    .    .  .    .    .  #ifdef __ASSUME_PRIVATE_FUTEX
 7    0    0  0    0    0  0    0    0  	movl	$(FUTEX_WAIT|FUTEX_PRIVATE_FLAG), %esi
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	orl	%fs:PRIVATE_FUTEX, %esi
 .    .    .  .    .    .  .    .    .  #endif
 7    0    0  0    0    0  0    0    0  60:	xorb	%r8b, %r8b
 7    0    0  0    0    0  0    0    0  	movl	$SYS_futex, %eax
 7    0    0  0    0    0  0    0    0  	syscall
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    7    0  0    0    0  62:	movl	(%rsp), %edi
 7    0    0  0    0    0  7    0    0  	callq	__pthread_disable_asynccancel
 .    .    .  .    .    .  .    .    .  .LcleanupEND:
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Lock.  */
 7    1    1  7    0    0  0    0    0  	movq	8(%rsp), %rdi
 7    0    0  0    0    0  0    0    0  	movl	$1, %esi
 7    0    0  0    0    0  0    0    0  	xorl	%eax, %eax
 7    0    0  7    0    0  0    0    0  	LOCK
 .    .    .  .    .    .  .    .    .  #if cond_lock == 0
 .    .    .  .    .    .  .    .    .  	cmpxchgl %esi, (%rdi)
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	cmpxchgl %esi, cond_lock(%rdi)
 .    .    .  .    .    .  .    .    .  #endif
 7    0    0  0    0    0  0    0    0  	jnz	5f
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  6:	movl	broadcast_seq(%rdi), %edx
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	movq	woken_seq(%rdi), %rax
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	movq	wakeup_seq(%rdi), %r9
 .    .    .  .    .    .  .    .    .  
 7    0    0  7    0    0  0    0    0  	cmpl	4(%rsp), %edx
 7    0    0  0    0    0  0    0    0  	jne	16f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	cmpq	24(%rsp), %r9
 .    .    .  .    .    .  .    .    .  	jbe	19f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	cmpq	%rax, %r9
 .    .    .  .    .    .  .    .    .  	jna	19f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	incq	woken_seq(%rdi)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Unlock */
 7    0    0  7    0    0  0    0    0  16:	subl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Wake up a thread which wants to destroy the condvar object.  */
 7    0    0  7    0    0  0    0    0  	cmpq	$0xffffffffffffffff, total_seq(%rdi)
 7    0    0  0    0    0  0    0    0  	jne	17f
 .    .    .  .    .    .  .    .    .  	movl	cond_nwaiters(%rdi), %eax
 .    .    .  .    .    .  .    .    .  	andl	$~((1 << nwaiters_shift) - 1), %eax
 .    .    .  .    .    .  .    .    .  	jne	17f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	addq	$cond_nwaiters, %rdi
 .    .    .  .    .    .  .    .    .  	LP_OP(cmp) $-1, dep_mutex-cond_nwaiters(%rdi)
 .    .    .  .    .    .  .    .    .  	movl	$1, %edx
 .    .    .  .    .    .  .    .    .  #ifdef __ASSUME_PRIVATE_FUTEX
-- line 231 ----------------------------------------
-- line 237 ----------------------------------------
 .    .    .  .    .    .  .    .    .  	movl	%fs:PRIVATE_FUTEX, %esi
 .    .    .  .    .    .  .    .    .  	cmove	%eax, %esi
 .    .    .  .    .    .  .    .    .  	orl	$FUTEX_WAKE, %esi
 .    .    .  .    .    .  .    .    .  #endif
 .    .    .  .    .    .  .    .    .  	movl	$SYS_futex, %eax
 .    .    .  .    .    .  .    .    .  	syscall
 .    .    .  .    .    .  .    .    .  	subq	$cond_nwaiters, %rdi
 .    .    .  .    .    .  .    .    .  
 7    1    1 14    0    0  0    0    0  17:	LOCK
 .    .    .  .    .    .  .    .    .  #if cond_lock == 0
 .    .    .  .    .    .  .    .    .  	decl	(%rdi)
 .    .    .  .    .    .  .    .    .  #else
 .    .    .  .    .    .  .    .    .  	decl	cond_lock(%rdi)
 .    .    .  .    .    .  .    .    .  #endif
 7    0    0  0    0    0  0    0    0  	jne	10f
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* If requeue_pi is used the kernel performs the locking of the
 .    .    .  .    .    .  .    .    .  	   mutex. */
 7    0    0  7    6    0  0    0    0  11:	movq	16(%rsp), %rdi
 7    0    0  0    0    0  0    0    0  	testb	%r8b, %r8b
 7    0    0  0    0    0  0    0    0  	jnz	18f
 .    .    .  .    .    .  .    .    .  
 7    1    1  0    0    0  7    0    0  	callq	__pthread_mutex_cond_lock
 .    .    .  .    .    .  .    .    .  
 7    0    0  0    0    0  0    0    0  14:	leaq	FRAME_SIZE(%rsp), %rsp
 .    .    .  .    .    .  .    .    .  	cfi_adjust_cfa_offset(-FRAME_SIZE)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* We return the result of the mutex_lock operation.  */
 7    0    0  7    1    0  0    0    0  	retq
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	cfi_adjust_cfa_offset(FRAME_SIZE)
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  18:	callq	__pthread_mutex_cond_lock_adjust
 .    .    .  .    .    .  .    .    .  	xorl	%eax, %eax
 .    .    .  .    .    .  .    .    .  	jmp	14b
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* We need to go back to futex_wait.  If we're using requeue_pi, then
-- line 273 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../sysdeps/generic/dl-hash.h
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr    D1mr DLmr Dw D1mw DLmw 

-- line 23 ----------------------------------------
    .    .    .     .    .    .  .    .    .  /* This is the hashing function specified by the ELF ABI.  In the
    .    .    .     .    .    .  .    .    .     first five operations no overflow is possible so we optimized it a
    .    .    .     .    .    .  .    .    .     bit.  */
    .    .    .     .    .    .  .    .    .  static unsigned int
    .    .    .     .    .    .  .    .    .  __attribute__ ((unused))
    .    .    .     .    .    .  .    .    .  _dl_elf_hash (const char *name_arg)
    .    .    .     .    .    .  .    .    .  {
    .    .    .     .    .    .  .    .    .    const unsigned char *name = (const unsigned char *) name_arg;
  202    0    0   202    0    0  0    0    0    unsigned long int hash = *name;
1,212    0    0   202    0    0  0    0    0    if (hash != 0 && name[1] != '\0')
    .    .    .     .    .    .  .    .    .      {
  404    0    0     0    0    0  0    0    0        hash = (hash << 4) + name[1];
  606    2    1   202    0    0  0    0    0        if (name[2] != '\0')
    .    .    .     .    .    .  .    .    .  	{
  404    0    0     0    0    0  0    0    0  	  hash = (hash << 4) + name[2];
  606    0    0   202    0    0  0    0    0  	  if (name[3] != '\0')
    .    .    .     .    .    .  .    .    .  	    {
  404    0    0     0    0    0  0    0    0  	      hash = (hash << 4) + name[3];
  606    0    0   202    0    0  0    0    0  	      if (name[4] != '\0')
    .    .    .     .    .    .  .    .    .  		{
  378    0    0     0    0    0  0    0    0  		  hash = (hash << 4) + name[4];
  189    0    0     0    0    0  0    0    0  		  name += 5;
5,385    0    0 1,795    0    0  0    0    0  		  while (*name != '\0')
    .    .    .     .    .    .  .    .    .  		    {
    .    .    .     .    .    .  .    .    .  		      unsigned long int hi;
4,818    0    0     0    0    0  0    0    0  		      hash = (hash << 4) + *name++;
3,212    1    0     0    0    0  0    0    0  		      hi = hash & 0xf0000000;
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  		      /* The algorithm specified in the ELF ABI is as
    .    .    .     .    .    .  .    .    .  			 follows:
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  			 if (hi != 0)
    .    .    .     .    .    .  .    .    .  			   hash ^= hi >> 24;
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  			 hash &= ~hi;
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  			 But the following is equivalent and a lot
    .    .    .     .    .    .  .    .    .  			 faster, especially on modern processors.  */
    .    .    .     .    .    .  .    .    .  
3,212    0    0     0    0    0  0    0    0  		      hash ^= hi >> 24;
    .    .    .     .    .    .  .    .    .  		    }
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  		  /* Second part of the modified formula.  This
    .    .    .     .    .    .  .    .    .  		     operation can be lifted outside the loop.  */
1,199    1    1     0    0    0  0    0    0  		  hash &= 0x0fffffff;
    .    .    .     .    .    .  .    .    .  		}
    .    .    .     .    .    .  .    .    .  	    }
    .    .    .     .    .    .  .    .    .  	}
    .    .    .     .    .    .  .    .    .      }
    .    .    .     .    .    .  .    .    .    return hash;
    .    .    .     .    .    .  .    .    .  }
    .    .    .     .    .    .  .    .    .  
    .    .    .     .    .    .  .    .    .  #endif /* dl-hash.h */
-- line 75 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-sysdep.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 78 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #ifndef DL_STACK_END
  .    .    .  .    .    .  .    .    .  # define DL_STACK_END(cookie) ((void *) (cookie))
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  ElfW(Addr)
  .    .    .  .    .    .  .    .    .  _dl_sysdep_start (void **start_argptr,
  .    .    .  .    .    .  .    .    .  		  void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,
  .    .    .  .    .    .  .    .    .  				   ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))
  8    1    1  0    0    0  7    1    1  {
  2    0    0  0    0    0  0    0    0    const ElfW(Phdr) *phdr = NULL;
  1    0    0  0    0    0  0    0    0    ElfW(Word) phnum = 0;
  .    .    .  .    .    .  .    .    .    ElfW(Addr) user_entry;
  .    .    .  .    .    .  .    .    .    ElfW(auxv_t) *av;
  .    .    .  .    .    .  .    .    .  #ifdef HAVE_AUX_SECURE
  .    .    .  .    .    .  .    .    .  # define set_seen(tag) (tag)	/* Evaluate for the side effects.  */
  .    .    .  .    .    .  .    .    .  # define set_seen_secure() ((void) 0)
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .    uid_t uid = 0;
  .    .    .  .    .    .  .    .    .    gid_t gid = 0;
-- line 96 ----------------------------------------
-- line 102 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #  define M(type) (1 << (type))
  .    .    .  .    .    .  .    .    .  #  define set_seen(tag) seen |= M ((tag)->a_type)
  .    .    .  .    .    .  .    .    .  # endif
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  #ifdef NEED_DL_SYSINFO
  .    .    .  .    .    .  .    .    .    uintptr_t new_sysinfo = 0;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  1    0    0    __libc_stack_end = DL_STACK_END (start_argptr);
147    2    2 47    6    6  4    3    3    DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, INTUSE(_dl_argv), _environ,
  .    .    .  .    .    .  .    .    .  			  GLRO(dl_auxv));
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  1    0    0    user_entry = (ElfW(Addr)) ENTRY_POINT;
  1    0    0  0    0    0  1    1    1    GLRO(dl_platform) = NULL; /* Default to nothing known about the platform.  */
  .    .    .  .    .    .  .    .    .  
 94    2    2 24    3    3 10    0    0    for (av = GLRO(dl_auxv); av->a_type != AT_NULL; set_seen (av++))
114    1    1 21    3    3  0    0    0      switch (av->a_type)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .        case AT_PHDR:
  1    0    0  1    0    0  0    0    0  	phdr = (void *) av->a_un.a_val;
  1    1    1  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_PHNUM:
  1    0    0  1    0    0  0    0    0  	phnum = av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_PAGESZ:
  1    0    0  1    0    0  0    0    0  	GLRO(dl_pagesize) = av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_ENTRY:
  1    0    0  1    1    1  0    0    0  	user_entry = av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .  #ifdef NEED_DL_BASE_ADDR
  .    .    .  .    .    .  .    .    .        case AT_BASE:
  .    .    .  .    .    .  .    .    .  	_dl_base_addr = av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  #ifndef HAVE_AUX_SECURE
  .    .    .  .    .    .  .    .    .        case AT_UID:
  .    .    .  .    .    .  .    .    .        case AT_EUID:
-- line 139 ----------------------------------------
-- line 143 ----------------------------------------
  .    .    .  .    .    .  .    .    .        case AT_EGID:
  .    .    .  .    .    .  .    .    .  	gid ^= av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .        case AT_SECURE:
  .    .    .  .    .    .  .    .    .  #ifndef HAVE_AUX_SECURE
  .    .    .  .    .    .  .    .    .  	seen = -1;
  .    .    .  .    .    .  .    .    .  #endif
  1    0    0  1    0    0  0    0    0  	INTUSE(__libc_enable_secure) = av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_PLATFORM:
  1    0    0  1    0    0  0    0    0  	GLRO(dl_platform) = (void *) av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_HWCAP:
  1    1    1  1    1    1  0    0    0  	GLRO(dl_hwcap) = (unsigned long int) av->a_un.a_val;
  1    1    1  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_HWCAP2:
  .    .    .  .    .    .  .    .    .  	GLRO(dl_hwcap2) = (unsigned long int) av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .        case AT_CLKTCK:
  1    0    0  1    0    0  0    0    0  	GLRO(dl_clktck) = av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .        case AT_FPUCW:
  .    .    .  .    .    .  .    .    .  	GLRO(dl_fpu_control) = av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  #ifdef NEED_DL_SYSINFO
  .    .    .  .    .    .  .    .    .        case AT_SYSINFO:
  .    .    .  .    .    .  .    .    .  	new_sysinfo = av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  #if defined NEED_DL_SYSINFO || defined NEED_DL_SYSINFO_DSO
  .    .    .  .    .    .  .    .    .        case AT_SYSINFO_EHDR:
  .    .    .  .    .    .  .    .    .  	GLRO(dl_sysinfo_dso) = (void *) av->a_un.a_val;
  .    .    .  .    .    .  .    .    .  	break;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .        case AT_RANDOM:
  1    1    1  1    0    0  0    0    0  	_dl_random = (void *) av->a_un.a_val;
  1    0    0  0    0    0  0    0    0  	break;
  .    .    .  .    .    .  .    .    .  #ifdef DL_PLATFORM_AUXV
  .    .    .  .    .    .  .    .    .        DL_PLATFORM_AUXV
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifndef HAVE_AUX_SECURE
  .    .    .  .    .    .  .    .    .    if (seen != -1)
  .    .    .  .    .    .  .    .    .      {
-- line 188 ----------------------------------------
-- line 218 ----------------------------------------
  .    .    .  .    .    .  .    .    .    DL_SYSDEP_INIT;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef DL_PLATFORM_INIT
  .    .    .  .    .    .  .    .    .    DL_PLATFORM_INIT;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Determine the length of the platform name.  */
  3    1    1  1    0    0  0    0    0    if (GLRO(dl_platform) != NULL)
  2    0    0  0    0    0  2    0    0      GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
  .    .    .  .    .    .  .    .    .  
  5    0    0  0    0    0  1    0    0    if (__sbrk (0) == _end)
  .    .    .  .    .    .  .    .    .      /* The dynamic linker was run as a program, and so the initial break
  .    .    .  .    .    .  .    .    .         starts just after our bss, at &_end.  The malloc in dl-minimal.c
  .    .    .  .    .    .  .    .    .         will consume the rest of this page, so tell the kernel to move the
  .    .    .  .    .    .  .    .    .         break up that far.  When the user program examines its break, it
  .    .    .  .    .    .  .    .    .         will see this new value and not clobber our data.  */
  .    .    .  .    .    .  .    .    .      __sbrk (GLRO(dl_pagesize)
  .    .    .  .    .    .  .    .    .  	    - ((_end - (char *) 0) & (GLRO(dl_pagesize) - 1)));
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
  .    .    .  .    .    .  .    .    .       allocated.  If necessary we are doing it ourself.  If it is not
  .    .    .  .    .    .  .    .    .       possible we stop the program.  */
  3    0    0  1    0    0  0    0    0    if (__builtin_expect (INTUSE(__libc_enable_secure), 0))
  .    .    .  .    .    .  .    .    .      __libc_check_standard_fds ();
  .    .    .  .    .    .  .    .    .  
  6    0    0  2    0    0  1    0    0    (*dl_main) (phdr, phnum, &user_entry, GLRO(dl_auxv));
  .    .    .  .    .    .  .    .    .    return user_entry;
  9    0    0  8    2    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  void
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_sysdep_start_cleanup (void)
  1    1    1  1    0    0  0    0    0  {
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  void
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  _dl_show_auxv (void)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    char buf[64];
  .    .    .  .    .    .  .    .    .    ElfW(auxv_t) *av;
-- line 259 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/nptl/pthread_mutex_unlock.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 30 ----------------------------------------
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  __pthread_mutex_unlock_full (pthread_mutex_t *mutex, int decr)
  .    .    .   .    .    .   .    .    .       __attribute_noinline__;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  internal_function attribute_hidden
  .    .    .   .    .    .   .    .    .  __pthread_mutex_unlock_usercnt (pthread_mutex_t *mutex, int decr)
  7    1    1   0    0    0   0    0    0  {
462    1    1 154    1    0   0    0    0    int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);
462    0    0   0    0    0   0    0    0    if (__builtin_expect (type &
  .    .    .   .    .    .   .    .    .  		~(PTHREAD_MUTEX_KIND_MASK_NP|PTHREAD_MUTEX_ELISION_FLAGS_NP), 0))
  .    .    .   .    .    .   .    .    .      return __pthread_mutex_unlock_full (mutex, decr);
  .    .    .   .    .    .   .    .    .  
308    0    0   0    0    0   0    0    0    if (__builtin_expect (type, PTHREAD_MUTEX_TIMED_NP)
  .    .    .   .    .    .   .    .    .        == PTHREAD_MUTEX_TIMED_NP)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Always reset the owner field.  */
  .    .    .   .    .    .   .    .    .      normal:
154    0    0   0    0    0 154    0    0        mutex->__data.__owner = 0;
 14    1    1   0    0    0   0    0    0        if (decr)
  .    .    .   .    .    .   .    .    .  	/* One less user.  */
147    0    0 147    0    0   0    0    0  	--mutex->__data.__nusers;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Unlock.  */
469    0    0 308    0    0   0    0    0        lll_unlock (mutex->__data.__lock, PTHREAD_MUTEX_PSHARED (mutex));
  .    .    .   .    .    .   .    .    .  
154    0    0   0    0    0   0    0    0        LIBC_PROBE (mutex_release, 1, mutex);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        return 0;
  .    .    .   .    .    .   .    .    .      }
  4    1    1   0    0    0   0    0    0    else if (__builtin_expect (type == PTHREAD_MUTEX_TIMED_ELISION_NP, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Don't reset the owner/users fields for elision.  */
  .    .    .   .    .    .   .    .    .        return lll_unlock_elision (mutex->__data.__lock,
  .    .    .   .    .    .   .    .    .  				      PTHREAD_MUTEX_PSHARED (mutex));
  .    .    .   .    .    .   .    .    .      }
  8    0    0   0    0    0   0    0    0    else if (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)
  .    .    .   .    .    .   .    .    .  			      == PTHREAD_MUTEX_RECURSIVE_NP, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Recursive mutex.  */
  6    2    1   4    1    0   0    0    0        if (mutex->__data.__owner != THREAD_GETMEM (THREAD_SELF, tid))
  .    .    .   .    .    .   .    .    .  	return EPERM;
  .    .    .   .    .    .   .    .    .  
 41    1    1   2    0    0   7    6    0        if (--mutex->__data.__count != 0)
  .    .    .   .    .    .   .    .    .  	/* We still hold the mutex.  */
  .    .    .   .    .    .   .    .    .  	return 0;
  .    .    .   .    .    .   .    .    .        goto normal;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    else if (__builtin_expect (PTHREAD_MUTEX_TYPE (mutex)
  .    .    .   .    .    .   .    .    .  			      == PTHREAD_MUTEX_ADAPTIVE_NP, 1))
  .    .    .   .    .    .   .    .    .      goto normal;
  .    .    .   .    .    .   .    .    .    else
-- line 82 ----------------------------------------
-- line 83 ----------------------------------------
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Error checking mutex.  */
  .    .    .   .    .    .   .    .    .        assert (type == PTHREAD_MUTEX_ERRORCHECK_NP);
  .    .    .   .    .    .   .    .    .        if (mutex->__data.__owner != THREAD_GETMEM (THREAD_SELF, tid)
  .    .    .   .    .    .   .    .    .  	  || ! lll_islocked (mutex->__data.__lock))
  .    .    .   .    .    .   .    .    .  	return EPERM;
  .    .    .   .    .    .   .    .    .        goto normal;
  .    .    .   .    .    .   .    .    .      }
 14    0    0   7    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  __pthread_mutex_unlock_full (pthread_mutex_t *mutex, int decr)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    int newowner = 0;
  .    .    .   .    .    .   .    .    .    int private;
-- line 99 ----------------------------------------
-- line 321 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    LIBC_PROBE (mutex_release, 1, mutex);
  .    .    .   .    .    .   .    .    .    return 0;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  __pthread_mutex_unlock (pthread_mutex_t *mutex)
147    0    0   0    0    0   0    0    0  {
  .    .    .   .    .    .   .    .    .    return __pthread_mutex_unlock_usercnt (mutex, 1);
294    0    0 147    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock)
  .    .    .   .    .    .   .    .    .  hidden_def (__pthread_mutex_unlock)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/stdio-common/printf_fp.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 161 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  int
  .    .    .  .    .    .  .    .    .  __printf_fp_l (FILE *fp, locale_t loc,
  .    .    .  .    .    .  .    .    .  	       const struct printf_info *info,
  .    .    .  .    .    .  .    .    .  	       const void *const *args)
 11    1    1  0    0    0  7    0    0  {
  .    .    .  .    .    .  .    .    .    /* The floating-point value to output.  */
  .    .    .  .    .    .  .    .    .    union
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        double dbl;
  .    .    .  .    .    .  .    .    .        __long_double_t ldbl;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    fpnum;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Locale-dependent representation of decimal point.	*/
  .    .    .  .    .    .  .    .    .    const char *decimal;
  .    .    .  .    .    .  .    .    .    wchar_t decimalwc;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Locale-dependent thousands separator and grouping specification.  */
  1    0    0  0    0    0  1    0    0    const char *thousands_sep = NULL;
  1    0    0  0    0    0  1    0    0    wchar_t thousands_sepwc = 0;
  .    .    .  .    .    .  .    .    .    const char *grouping;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* "NaN" or "Inf" for the special cases.  */
  .    .    .  .    .    .  .    .    .    const char *special = NULL;
  .    .    .  .    .    .  .    .    .    const wchar_t *wspecial = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We need just a few limbs for the input before shifting to the right
  .    .    .  .    .    .  .    .    .       position.	*/
-- line 192 ----------------------------------------
-- line 194 ----------------------------------------
  .    .    .  .    .    .  .    .    .    /* We need to shift the contents of fp_input by this amount of bits.	*/
  .    .    .  .    .    .  .    .    .    int to_shift = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* The fraction of the floting-point value in question  */
  .    .    .  .    .    .  .    .    .    MPN_VAR(frac);
  .    .    .  .    .    .  .    .    .    /* and the exponent.	*/
  .    .    .  .    .    .  .    .    .    int exponent;
  .    .    .  .    .    .  .    .    .    /* Sign of the exponent.  */
  1    0    0  0    0    0  1    0    0    int expsign = 0;
  .    .    .  .    .    .  .    .    .    /* Sign of float number.  */
  1    1    1  0    0    0  1    0    0    int is_neg = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Scaling factor.  */
  .    .    .  .    .    .  .    .    .    MPN_VAR(scale);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Temporary bignum value.  */
  .    .    .  .    .    .  .    .    .    MPN_VAR(tmp);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* The type of output format that will be used: 'e'/'E' or 'f'.  */
  .    .    .  .    .    .  .    .    .    int type;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Counter for number of written characters.	*/
  1    1    1  0    0    0  0    0    0    int done = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* General helper (carry limb).  */
  .    .    .  .    .    .  .    .    .    mp_limb_t cy;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Nonzero if this is output on a wide character stream.  */
  6    0    0  1    0    0  1    0    0    int wide = info->wide;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Buffer in which we produce the output.  */
  .    .    .  .    .    .  .    .    .    wchar_t *wbuffer = NULL;
  .    .    .  .    .    .  .    .    .    /* Flag whether wbuffer is malloc'ed or not.  */
  .    .    .  .    .    .  .    .    .    int buffer_malloced = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    auto wchar_t hack_digit (void);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    wchar_t hack_digit (void)
 32    1    1  0    0    0 16    0    0      {
  .    .    .  .    .    .  .    .    .        mp_limb_t hi;
  .    .    .  .    .    .  .    .    .  
 40    0    0 16    0    0  0    0    0        if (expsign != 0 && type == 'f' && exponent-- > 0)
  .    .    .  .    .    .  .    .    .  	hi = 0;
 24    0    0  8    0    0  0    0    0        else if (scalesize == 0)
  .    .    .  .    .    .  .    .    .  	{
 32    1    1 24    0    0  0    0    0  	  hi = frac[fracsize - 1];
 40    0    0  0    0    0 16    0    0  	  frac[fracsize - 1] = __mpn_mul_1 (frac, frac, fracsize - 1, 10);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  if (fracsize < scalesize)
  .    .    .  .    .    .  .    .    .  	    hi = 0;
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      hi = mpn_divmod (tmp, frac, fracsize, scale, scalesize);
-- line 248 ----------------------------------------
-- line 262 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  mp_limb_t _cy = __mpn_mul_1 (frac, frac, fracsize, 10);
  .    .    .  .    .    .  .    .    .  	  if (_cy != 0)
  .    .    .  .    .    .  .    .    .  	    frac[fracsize++] = _cy;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        return L'0' + hi;
 48    0    0 24    0    0  0    0    0      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Figure out the decimal point character.  */
  2    0    0  0    0    0  0    0    0    if (info->extra == 0)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        decimal = _nl_lookup (loc, LC_NUMERIC, DECIMAL_POINT);
  2    1    1  1    0    0  1    0    0        decimalwc = _nl_lookup_word
  .    .    .  .    .    .  .    .    .  	(loc, LC_NUMERIC, _NL_NUMERIC_DECIMAL_POINT_WC);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        decimal = _nl_lookup (loc, LC_MONETARY, MON_DECIMAL_POINT);
  .    .    .  .    .    .  .    .    .        if (*decimal == '\0')
  .    .    .  .    .    .  .    .    .  	decimal = _nl_lookup (loc, LC_NUMERIC, DECIMAL_POINT);
  .    .    .  .    .    .  .    .    .        decimalwc = _nl_lookup_word (loc, LC_MONETARY,
-- line 285 ----------------------------------------
-- line 287 ----------------------------------------
  .    .    .  .    .    .  .    .    .        if (decimalwc == L'\0')
  .    .    .  .    .    .  .    .    .  	decimalwc = _nl_lookup_word (loc, LC_NUMERIC,
  .    .    .  .    .    .  .    .    .  				      _NL_NUMERIC_DECIMAL_POINT_WC);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    /* The decimal point character must not be zero.  */
  .    .    .  .    .    .  .    .    .    assert (*decimal != '\0');
  .    .    .  .    .    .  .    .    .    assert (decimalwc != L'\0');
  .    .    .  .    .    .  .    .    .  
  3    0    0  1    0    0  0    0    0    if (info->group)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        if (info->extra == 0)
  .    .    .  .    .    .  .    .    .  	grouping = _nl_lookup (loc, LC_NUMERIC, GROUPING);
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	grouping = _nl_lookup (loc, LC_MONETARY, MON_GROUPING);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (*grouping <= 0 || *grouping == CHAR_MAX)
  .    .    .  .    .    .  .    .    .  	grouping = NULL;
-- line 303 ----------------------------------------
-- line 330 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	    /* If we are printing multibyte characters and there is a
  .    .    .  .    .    .  .    .    .  	       multibyte representation for the thousands separator,
  .    .    .  .    .    .  .    .    .  	       we must ensure the wide character thousands separator
  .    .    .  .    .    .  .    .    .  	       is available, even if it is fake.  */
  .    .    .  .    .    .  .    .    .  	    thousands_sepwc = 0xfffffffe;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  1    1    1  0    0    0  1    0    0      grouping = NULL;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Fetch the argument value.	*/
  .    .    .  .    .    .  .    .    .  #ifndef __NO_LONG_DOUBLE_MATH
  2    1    1  0    0    0  0    0    0    if (info->is_long_double && sizeof (long double) > sizeof (double))
  .    .    .  .    .    .  .    .    .      {
  1    0    0  1    0    0  0    0    0        fpnum.ldbl = *(const long double *) args[0];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Check for special values: not a number or infinity.  */
  .    .    .  .    .    .  .    .    .        int res;
  .    .    .  .    .    .  .    .    .        if (isnanl_or_pseudo (fpnum.ldbl))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  is_neg = signbit (fpnum.ldbl);
  .    .    .  .    .    .  .    .    .  	  if (isupper (info->spec))
  .    .    .  .    .    .  .    .    .  	    {
-- line 352 ----------------------------------------
-- line 381 ----------------------------------------
  .    .    .  .    .    .  .    .    .  						&exponent, &is_neg,
  .    .    .  .    .    .  .    .    .  						fpnum.ldbl);
  .    .    .  .    .    .  .    .    .  	  to_shift = 1 + fracsize * BITS_PER_MP_LIMB - LDBL_MANT_DIG;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .  #endif	/* no long double */
  .    .    .  .    .    .  .    .    .      {
  3    0    0  1    0    0  1    0    0        fpnum.dbl = *(const double *) args[0];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Check for special values: not a number or infinity.  */
  .    .    .  .    .    .  .    .    .        int res;
  3    0    0  0    0    0  1    1    1        if (__isnan (fpnum.dbl))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  union ieee754_double u = { .d = fpnum.dbl };
  .    .    .  .    .    .  .    .    .  	  is_neg = u.ieee.negative != 0;
  .    .    .  .    .    .  .    .    .  	  if (isupper (info->spec))
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      special = "NAN";
  .    .    .  .    .    .  .    .    .  	      wspecial = L"NAN";
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      special = "nan";
  .    .    .  .    .    .  .    .    .  	      wspecial = L"nan";
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  4    0    0  1    0    0  1    0    0        else if ((res = __isinf (fpnum.dbl)))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  is_neg = res < 0;
  .    .    .  .    .    .  .    .    .  	  if (isupper (info->spec))
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      special = "INF";
  .    .    .  .    .    .  .    .    .  	      wspecial = L"INF";
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      special = "inf";
  .    .    .  .    .    .  .    .    .  	      wspecial = L"inf";
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	{
 10    2    2  1    0    0  3    0    0  	  fracsize = __mpn_extract_double (fp_input,
  .    .    .  .    .    .  .    .    .  					   (sizeof (fp_input)
  .    .    .  .    .    .  .    .    .  					    / sizeof (fp_input[0])),
  .    .    .  .    .    .  .    .    .  					   &exponent, &is_neg, fpnum.dbl);
  3    0    0  0    0    0  0    0    0  	  to_shift = 1 + fracsize * BITS_PER_MP_LIMB - DBL_MANT_DIG;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    if (special)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        int width = info->width;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        if (is_neg || info->showsign || info->space)
-- line 436 ----------------------------------------
-- line 456 ----------------------------------------
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We need three multiprecision variables.  Now that we have the exponent
  .    .    .  .    .    .  .    .    .       of the number we can allocate the needed memory.  It would be more
  .    .    .  .    .    .  .    .    .       efficient to use variables of the fixed maximum size but because this
  .    .    .  .    .    .  .    .    .       would be really big it could lead to memory problems.  */
  .    .    .  .    .    .  .    .    .    {
  7    0    0  1    0    0  0    0    0      mp_size_t bignum_size = ((ABS (exponent) + BITS_PER_MP_LIMB - 1)
  1    1    1  0    0    0  0    0    0  			     / BITS_PER_MP_LIMB
  1    0    0  0    0    0  0    0    0  			     + (LDBL_MANT_DIG / BITS_PER_MP_LIMB > 2 ? 8 : 4))
  1    0    0  0    0    0  0    0    0  			    * sizeof (mp_limb_t);
 19    1    1  1    0    0  1    0    0      frac = (mp_limb_t *) alloca (bignum_size);
 18    2    2  1    1    1  1    0    0      tmp = (mp_limb_t *) alloca (bignum_size);
 17    1    1  1    1    1  1    0    0      scale = (mp_limb_t *) alloca (bignum_size);
  .    .    .  .    .    .  .    .    .    }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* We now have to distinguish between numbers with positive and negative
  .    .    .  .    .    .  .    .    .       exponents because the method used for the one is not applicable/efficient
  .    .    .  .    .    .  .    .    .       for the other.  */
  1    0    0  0    0    0  1    0    0    scalesize = 0;
  2    0    0  0    0    0  0    0    0    if (exponent > 2)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* |FP| >= 8.0.  */
  .    .    .  .    .    .  .    .    .        int scaleexpo = 0;
  .    .    .  .    .    .  .    .    .        int explog = LDBL_MAX_10_EXP_LOG;
  .    .    .  .    .    .  .    .    .        int exp10 = 0;
  .    .    .  .    .    .  .    .    .        const struct mp_power *powers = &_fpioconst_pow10[explog + 1];
  .    .    .  .    .    .  .    .    .        int cnt_h, cnt_l, i;
  .    .    .  .    .    .  .    .    .  
-- line 485 ----------------------------------------
-- line 608 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	      if (i == 0 && BITS_PER_MP_LIMB - cnt_h > cnt_l)
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  /* We cannot save any memory.	 So just roll both numbers
  .    .    .  .    .    .  .    .    .  		     so that the scaling factor has its highest bit set.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		  (void) __mpn_lshift (scale, scale, scalesize, cnt_h);
  .    .    .  .    .    .  .    .    .  		  cy = __mpn_lshift (frac, frac, fracsize, cnt_h);
  .    .    .  .    .    .  .    .    .  		  if (cy != 0)
  1    1    1  0    0    0  0    0    0  		    frac[fracsize++] = cy;
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	      else if (BITS_PER_MP_LIMB - cnt_h <= cnt_l)
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  /* We can save memory by removing the trailing zero limbs
  .    .    .  .    .    .  .    .    .  		     and by packing the non-zero limbs which gain another
  .    .    .  .    .    .  .    .    .  		     free one. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		  (void) __mpn_rshift (scale, scale + i, scalesize - i,
-- line 624 ----------------------------------------
-- line 640 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		  (void) __mpn_rshift (frac, frac + (i - 1),
  .    .    .  .    .    .  .    .    .  				       fracsize - (i - 1),
  .    .    .  .    .    .  .    .    .  				       BITS_PER_MP_LIMB - cnt_h);
  .    .    .  .    .    .  .    .    .  		  fracsize -= frac[fracsize - (i - 1) - 1] == 0 ? i : i - 1;
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  2    1    1  0    0    0  0    0    0    else if (exponent < 0)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* |FP| < 1.0.  */
  1    0    0  0    0    0  1    0    0        int exp10 = 0;
  1    0    0  0    0    0  0    0    0        int explog = LDBL_MAX_10_EXP_LOG;
  1    0    0  0    0    0  0    0    0        const struct mp_power *powers = &_fpioconst_pow10[explog + 1];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Now shift the input value to its right place.	*/
  4    1    1  0    0    0  1    1    1        cy = __mpn_lshift (frac, fp_input, fracsize, to_shift);
  5    0    0  2    0    0  2    0    0        frac[fracsize++] = cy;
  .    .    .  .    .    .  .    .    .        assert (cy == 1 || (frac[fracsize - 2] == 0 && frac[0] == 0));
  .    .    .  .    .    .  .    .    .  
  1    0    0  0    0    0  1    0    0        expsign = 1;
  3    0    0  1    0    0  1    0    0        exponent = -exponent;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        assert (powers != &_fpioconst_pow10[0]);
  .    .    .  .    .    .  .    .    .        do
  .    .    .  .    .    .  .    .    .  	{
 12    0    0  0    0    0  0    0    0  	  --powers;
  .    .    .  .    .    .  .    .    .  
 24    0    0 12    5    5  0    0    0  	  if (exponent >= powers->m_expo)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      int i, incr, cnt_h, cnt_l;
  .    .    .  .    .    .  .    .    .  	      mp_limb_t topval[2];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	      /* The __mpn_mul function expects the first argument to be
  .    .    .  .    .    .  .    .    .  		 bigger than the second.  */
  5    1    1  2    0    0  0    0    0  	      if (fracsize < powers->arraysize - _FPIO_CONST_OFFSET)
  1    0    0  0    0    0  0    0    0  		cy = __mpn_mul (tmp, &__tens[powers->arrayoff
  1    0    0  1    1    1  0    0    0  					    + _FPIO_CONST_OFFSET],
  .    .    .  .    .    .  .    .    .  				powers->arraysize - _FPIO_CONST_OFFSET,
  .    .    .  .    .    .  .    .    .  				frac, fracsize);
  .    .    .  .    .    .  .    .    .  	      else
  8    3    3  2    0    0  2    0    0  		cy = __mpn_mul (tmp, frac, fracsize,
  .    .    .  .    .    .  .    .    .  				&__tens[powers->arrayoff + _FPIO_CONST_OFFSET],
  .    .    .  .    .    .  .    .    .  				powers->arraysize - _FPIO_CONST_OFFSET);
  7    1    1  2    0    0  0    0    0  	      tmpsize = fracsize + powers->arraysize - _FPIO_CONST_OFFSET;
  .    .    .  .    .    .  .    .    .  	      if (cy == 0)
  .    .    .  .    .    .  .    .    .  		--tmpsize;
  .    .    .  .    .    .  .    .    .  
  5    0    0  2    0    0  0    0    0  	      count_leading_zeros (cnt_h, tmp[tmpsize - 1]);
  7    1    1  0    0    0  0    0    0  	      incr = (tmpsize - fracsize) * BITS_PER_MP_LIMB
  1    0    0  0    0    0  0    0    0  		     + BITS_PER_MP_LIMB - 1 - cnt_h;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	      assert (incr <= powers->p_expo);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	      /* If we increased the exponent by exactly 3 we have to test
  .    .    .  .    .    .  .    .    .  		 for overflow.	This is done by comparing with 10 shifted
  .    .    .  .    .    .  .    .    .  		 to the right position.	 */
  4    0    0  1    0    0  0    0    0  	      if (incr == exponent + 3)
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  if (cnt_h <= BITS_PER_MP_LIMB - 4)
  .    .    .  .    .    .  .    .    .  		    {
  .    .    .  .    .    .  .    .    .  		      topval[0] = 0;
  .    .    .  .    .    .  .    .    .  		      topval[1]
  .    .    .  .    .    .  .    .    .  			= ((mp_limb_t) 10) << (BITS_PER_MP_LIMB - 4 - cnt_h);
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  		  else
  .    .    .  .    .    .  .    .    .  		    {
  .    .    .  .    .    .  .    .    .  		      topval[0] = ((mp_limb_t) 10) << (BITS_PER_MP_LIMB - 4);
  .    .    .  .    .    .  .    .    .  		      topval[1] = 0;
  2    0    0  0    0    0  1    0    0  		      (void) __mpn_lshift (topval, topval, 2,
  .    .    .  .    .    .  .    .    .  					   BITS_PER_MP_LIMB - cnt_h);
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	      /* We have to be careful when multiplying the last factor.
  .    .    .  .    .    .  .    .    .  		 If the result is greater than 1.0 be have to test it
  .    .    .  .    .    .  .    .    .  		 against 10.0.  If it is greater or equal to 10.0 the
  .    .    .  .    .    .  .    .    .  		 multiplication was not valid.  This is because we cannot
  .    .    .  .    .    .  .    .    .  		 determine the number of bits in the result in advance.  */
  4    0    0  1    0    0  0    0    0  	      if (incr < exponent + 3
  .    .    .  .    .    .  .    .    .  		  || (incr == exponent + 3 &&
  .    .    .  .    .    .  .    .    .  		      (tmp[tmpsize - 1] < topval[1]
  .    .    .  .    .    .  .    .    .  		       || (tmp[tmpsize - 1] == topval[1]
  .    .    .  .    .    .  .    .    .  			   && tmp[tmpsize - 2] < topval[0]))))
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  /* The factor is right.  Adapt binary and decimal
  .    .    .  .    .    .  .    .    .  		     exponents.	 */
  2    0    0  0    0    0  1    0    0  		  exponent -= incr;
  4    0    0  1    0    0  0    0    0  		  exp10 |= 1 << explog;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		  /* If this factor yields a number greater or equal to
  .    .    .  .    .    .  .    .    .  		     1.0, we must not shift the non-fractional digits down. */
  .    .    .  .    .    .  .    .    .  		  if (exponent < 0)
  4    1    1  0    0    0  0    0    0  		    cnt_h += -exponent;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		  /* Now we optimize the number representation.	 */
  8    1    1  1    0    0  0    0    0  		  for (i = 0; tmp[i] == 0; ++i);
  2    1    1  0    0    0  0    0    0  		  if (cnt_h == BITS_PER_MP_LIMB - 1)
  .    .    .  .    .    .  .    .    .  		    {
  .    .    .  .    .    .  .    .    .  		      MPN_COPY (frac, tmp + i, tmpsize - i);
  .    .    .  .    .    .  .    .    .  		      fracsize = tmpsize - i;
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  		  else
  .    .    .  .    .    .  .    .    .  		    {
  1    0    0  0    0    0  0    0    0  		      count_trailing_zeros (cnt_l, tmp[i]);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  		      /* Now shift the numbers to their optimal position.  */
  6    0    0  0    0    0  0    0    0  		      if (i == 0 && BITS_PER_MP_LIMB - 1 - cnt_h > cnt_l)
  .    .    .  .    .    .  .    .    .  			{
  .    .    .  .    .    .  .    .    .  			  /* We cannot save any memory.	 Just roll the
  .    .    .  .    .    .  .    .    .  			     number so that the leading digit is in a
  .    .    .  .    .    .  .    .    .  			     separate limb.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  			  cy = __mpn_lshift (frac, tmp, tmpsize, cnt_h + 1);
  .    .    .  .    .    .  .    .    .  			  fracsize = tmpsize + 1;
  .    .    .  .    .    .  .    .    .  			  frac[fracsize - 1] = cy;
  .    .    .  .    .    .  .    .    .  			}
  .    .    .  .    .    .  .    .    .  		      else if (BITS_PER_MP_LIMB - 1 - cnt_h <= cnt_l)
  .    .    .  .    .    .  .    .    .  			{
  1    0    0  0    0    0  0    0    0  			  (void) __mpn_rshift (frac, tmp + i, tmpsize - i,
  .    .    .  .    .    .  .    .    .  					       BITS_PER_MP_LIMB - 1 - cnt_h);
  .    .    .  .    .    .  .    .    .  			  fracsize = tmpsize - i;
  .    .    .  .    .    .  .    .    .  			}
  .    .    .  .    .    .  .    .    .  		      else
  .    .    .  .    .    .  .    .    .  			{
  .    .    .  .    .    .  .    .    .  			  /* We can only save the memory of the limbs which
  .    .    .  .    .    .  .    .    .  			     are zero.	The non-zero parts occupy the same
  .    .    .  .    .    .  .    .    .  			     number of limbs.  */
  .    .    .  .    .    .  .    .    .  
  5    0    0  2    0    0  1    0    0  			  (void) __mpn_rshift (frac, tmp + (i - 1),
  .    .    .  .    .    .  .    .    .  					       tmpsize - (i - 1),
  .    .    .  .    .    .  .    .    .  					       BITS_PER_MP_LIMB - 1 - cnt_h);
  2    0    0  0    0    0  1    0    0  			  fracsize = tmpsize - (i - 1);
  .    .    .  .    .    .  .    .    .  			}
  .    .    .  .    .    .  .    .    .  		    }
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	    }
 12    0    0  0    0    0  0    0    0  	  --explog;
  .    .    .  .    .    .  .    .    .  	}
 58    1    1  0    0    0  0    0    0        while (powers != &_fpioconst_pow10[1] && exponent > 0);
  .    .    .  .    .    .  .    .    .        /* All factors but 10^-1 are tested now.	*/
  3    1    1  1    0    0  0    0    0        if (exponent > 0)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  int cnt_l;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  cy = __mpn_mul_1 (tmp, frac, fracsize, 10);
  .    .    .  .    .    .  .    .    .  	  tmpsize = fracsize;
  .    .    .  .    .    .  .    .    .  	  assert (cy == 0 || tmp[tmpsize - 1] < 20);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  count_trailing_zeros (cnt_l, tmp[0]);
-- line 789 ----------------------------------------
-- line 795 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		frac[tmpsize++] = cy;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    (void) __mpn_rshift (frac, tmp, tmpsize, MIN (4, exponent));
  .    .    .  .    .    .  .    .    .  	  fracsize = tmpsize;
  .    .    .  .    .    .  .    .    .  	  exp10 |= 1;
  .    .    .  .    .    .  .    .    .  	  assert (frac[fracsize - 1] < 10);
  .    .    .  .    .    .  .    .    .  	}
  3    0    0  1    0    0  1    0    0        exponent = exp10;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* This is a special case.  We don't need a factor because the
  .    .    .  .    .    .  .    .    .  	 numbers are in the range of 1.0 <= |fp| < 8.0.  We simply
  .    .    .  .    .    .  .    .    .  	 shift it to the right place and divide it by 1.0 to get the
  .    .    .  .    .    .  .    .    .  	 leading digit.	 (Of course this division is not really made.)	*/
  .    .    .  .    .    .  .    .    .        assert (0 <= exponent && exponent < 3 &&
-- line 811 ----------------------------------------
-- line 813 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Now shift the input value to its right place.	*/
  .    .    .  .    .    .  .    .    .        cy = __mpn_lshift (frac, fp_input, fracsize, (exponent + to_shift));
  .    .    .  .    .    .  .    .    .        frac[fracsize++] = cy;
  .    .    .  .    .    .  .    .    .        exponent = 0;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    {
  2    1    1  1    0    0  1    1    1      int width = info->width;
  .    .    .  .    .    .  .    .    .      wchar_t *wstartp, *wcp;
  .    .    .  .    .    .  .    .    .      size_t chars_needed;
  .    .    .  .    .    .  .    .    .      int expscale;
  .    .    .  .    .    .  .    .    .      int intdig_max, intdig_no = 0;
  .    .    .  .    .    .  .    .    .      int fracdig_min;
  .    .    .  .    .    .  .    .    .      int fracdig_max;
  .    .    .  .    .    .  .    .    .      int dig_max;
  .    .    .  .    .    .  .    .    .      int significant;
  1    0    0  0    0    0  1    0    0      int ngroups = 0;
  6    0    0  4    2    1  1    0    0      char spec = _tolower (info->spec);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0      if (spec == 'e')
  .    .    .  .    .    .  .    .    .        {
  1    1    1  0    0    0  1    0    0  	type = info->spec;
  .    .    .  .    .    .  .    .    .  	intdig_max = 1;
  6    0    0  1    0    0  2    0    0  	fracdig_min = fracdig_max = info->prec < 0 ? 6 : info->prec;
  .    .    .  .    .    .  .    .    .  	chars_needed = 1 + 1 + (size_t) fracdig_max + 1 + 1 + 4;
  .    .    .  .    .    .  .    .    .  	/*	       d   .	 ddd	     e	 +-  ddd  */
  .    .    .  .    .    .  .    .    .  	dig_max = INT_MAX;		/* Unlimited.  */
  .    .    .  .    .    .  .    .    .  	significant = 1;		/* Does not matter here.  */
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      else if (spec == 'f')
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	type = 'f';
  3    0    0  1    0    0  1    0    0  	fracdig_min = fracdig_max = info->prec < 0 ? 6 : info->prec;
  1    0    0  0    0    0  1    0    0  	dig_max = INT_MAX;		/* Unlimited.  */
  1    0    0  0    0    0  1    0    0  	significant = 1;		/* Does not matter here.  */
  .    .    .  .    .    .  .    .    .  	if (expsign == 0)
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    intdig_max = exponent + 1;
  .    .    .  .    .    .  .    .    .  	    /* This can be really big!	*/  /* XXX Maybe malloc if too big? */
  .    .    .  .    .    .  .    .    .  	    chars_needed = (size_t) exponent + 1 + 1 + (size_t) fracdig_max;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  	else
  .    .    .  .    .    .  .    .    .  	  {
  1    1    1  0    0    0  1    0    0  	    intdig_max = 1;
  .    .    .  .    .    .  .    .    .  	    chars_needed = 1 + 1 + (size_t) fracdig_max;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      else
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	dig_max = info->prec < 0 ? 6 : (info->prec == 0 ? 1 : info->prec);
  .    .    .  .    .    .  .    .    .  	if ((expsign == 0 && exponent >= dig_max)
  .    .    .  .    .    .  .    .    .  	    || (expsign != 0 && exponent > 4))
-- line 865 ----------------------------------------
-- line 883 ----------------------------------------
  .    .    .  .    .    .  .    .    .  	       exponential notation with a negative two-digit
  .    .    .  .    .    .  .    .    .  	       exponent, which is 4.  */
  .    .    .  .    .    .  .    .    .  	    chars_needed = (size_t) dig_max + 1 + 4;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  	fracdig_min = info->alt ? fracdig_max : 0;
  .    .    .  .    .    .  .    .    .  	significant = 0;		/* We count significant digits.	 */
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  3    1    1  1    0    0  0    0    0      if (grouping)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* Guess the number of groups we will make, and thus how
  .    .    .  .    .    .  .    .    .  	   many spaces we need for separator characters.  */
  .    .    .  .    .    .  .    .    .  	ngroups = __guess_grouping (intdig_max, grouping);
  .    .    .  .    .    .  .    .    .  	/* Allocate one more character in case rounding increases the
  .    .    .  .    .    .  .    .    .  	   number of groups.  */
  .    .    .  .    .    .  .    .    .  	chars_needed += ngroups + 1;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Allocate buffer for output.  We need two more because while rounding
  .    .    .  .    .    .  .    .    .         it is possible that we need two more characters in front of all the
  .    .    .  .    .    .  .    .    .         other output.  If the amount of memory we have to allocate is too
  .    .    .  .    .    .  .    .    .         large use `malloc' instead of `alloca'.  */
  6    1    1  1    0    0  0    0    0      if (__builtin_expect (chars_needed >= (size_t) -1 / sizeof (wchar_t) - 2
  1    0    0  1    0    0  0    0    0  			  || chars_needed < fracdig_max, 0))
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* Some overflow occurred.  */
  .    .    .  .    .    .  .    .    .  	__set_errno (ERANGE);
  .    .    .  .    .    .  .    .    .  	return -1;
  .    .    .  .    .    .  .    .    .        }
  2    0    0  1    0    0  0    0    0      size_t wbuffer_to_alloc = (2 + chars_needed) * sizeof (wchar_t);
  1    0    0  0    0    0  1    0    0      buffer_malloced = ! __libc_use_alloca (wbuffer_to_alloc);
  1    0    0  0    0    0  1    0    0      if (__builtin_expect (buffer_malloced, 0))
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	wbuffer = (wchar_t *) malloc (wbuffer_to_alloc);
  .    .    .  .    .    .  .    .    .  	if (wbuffer == NULL)
  .    .    .  .    .    .  .    .    .  	  /* Signal an error to the caller.  */
  .    .    .  .    .    .  .    .    .  	  return -1;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      else
 18    2    2  2    0    0  1    0    0        wbuffer = (wchar_t *) alloca (wbuffer_to_alloc);
  2    0    0  1    0    0  0    0    0      wcp = wstartp = wbuffer + 2;	/* Let room for rounding.  */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Do the real work: put digits in allocated buffer.  */
  5    1    1  2    0    0  0    0    0      if (expsign == 0 || type != 'f')
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	assert (expsign == 0 || intdig_max == 1);
 20    0    0  7    0    0  3    0    0  	while (intdig_no < intdig_max)
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    ++intdig_no;
  4    1    1  0    0    0  2    0    0  	    *wcp++ = hack_digit ();
  .    .    .  .    .    .  .    .    .  	  }
  1    0    0  0    0    0  1    0    0  	significant = 1;
  2    1    1  1    0    0  0    0    0  	if (info->alt
  3    0    0  1    0    0  0    0    0  	    || fracdig_min > 0
  .    .    .  .    .    .  .    .    .  	    || (fracdig_max > 0 && (fracsize > 1 || frac[0] != 0)))
  6    0    0  2    0    0  1    0    0  	  *wcp++ = decimalwc;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      else
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* |fp| < 1.0 and the selected type is 'f', so put "0."
  .    .    .  .    .    .  .    .    .  	   in the buffer.  */
  .    .    .  .    .    .  .    .    .  	*wcp++ = L'0';
  .    .    .  .    .    .  .    .    .  	--exponent;
  .    .    .  .    .    .  .    .    .  	*wcp++ = decimalwc;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Generate the needed number of fractional digits.	 */
  3    1    1  0    0    0  1    0    0      int fracdig_no = 0;
 19    0    0  7    0    0  7    0    0      int added_zeros = 0;
 21    0    0  0    0    0  0    0    0      while (fracdig_no < fracdig_min + added_zeros
 10    2    2  4    0    0  0    0    0  	   || (fracdig_no < fracdig_max && (fracsize > 1 || frac[0] != 0)))
  .    .    .  .    .    .  .    .    .        {
  6    0    0  0    0    0  0    0    0  	++fracdig_no;
 18    1    1  6    0    0 12    0    0  	*wcp = hack_digit ();
 18    0    0  0    0    0  0    0    0  	if (*wcp++ != L'0')
  .    .    .  .    .    .  .    .    .  	  significant = 1;
  6    0    0  2    0    0  0    0    0  	else if (significant == 0)
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    ++fracdig_max;
  .    .    .  .    .    .  .    .    .  	    if (fracdig_min > 0)
  .    .    .  .    .    .  .    .    .  	      ++added_zeros;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Do rounding.  */
  3    1    1  2    0    0  0    0    0      wchar_t last_digit = wcp[-1] != decimalwc ? wcp[-1] : wcp[-2];
  4    0    0  1    0    0  3    0    0      wchar_t next_digit = hack_digit ();
  .    .    .  .    .    .  .    .    .      bool more_bits;
  6    0    0  2    0    0  0    0    0      if (next_digit != L'0' && next_digit != L'5')
  1    0    0  0    0    0  0    0    0        more_bits = true;
  .    .    .  .    .    .  .    .    .      else if (fracsize == 1 && frac[0] == 0)
  .    .    .  .    .    .  .    .    .        /* Rest of the number is zero.  */
  .    .    .  .    .    .  .    .    .        more_bits = false;
  .    .    .  .    .    .  .    .    .      else if (scalesize == 0)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* Here we have to see whether all limbs are zero since no
  .    .    .  .    .    .  .    .    .  	   normalization happened.  */
  .    .    .  .    .    .  .    .    .  	size_t lcnt = fracsize;
-- line 980 ----------------------------------------
-- line 1079 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		    wcp -= intdig_no + fracdig_no - dig_max;
  .    .    .  .    .    .  .    .    .  		    fracdig_no -= intdig_no + fracdig_no - dig_max;
  .    .    .  .    .    .  .    .    .  		  }
  .    .    .  .    .    .  .    .    .  	      }
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Now remove unnecessary '0' at the end of the string.  */
  3    1    1  0    0    0  0    0    0      while (fracdig_no > fracdig_min + added_zeros && *(wcp - 1) == L'0')
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	--wcp;
  .    .    .  .    .    .  .    .    .  	--fracdig_no;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      /* If we eliminate all fractional digits we perhaps also can remove
  .    .    .  .    .    .  .    .    .         the radix character.  */
  2    0    0  0    0    0  0    0    0      if (fracdig_no == 0 && !info->alt && *(wcp - 1) == decimalwc)
  .    .    .  .    .    .  .    .    .        --wcp;
  .    .    .  .    .    .  .    .    .  
  2    1    1  1    0    0  0    0    0      if (grouping)
  .    .    .  .    .    .  .    .    .        {
  .    .    .  .    .    .  .    .    .  	/* Rounding might have changed the number of groups.  We allocated
  .    .    .  .    .    .  .    .    .  	   enough memory but we need here the correct number of groups.  */
  .    .    .  .    .    .  .    .    .  	if (intdig_no != intdig_max)
  .    .    .  .    .    .  .    .    .  	  ngroups = __guess_grouping (intdig_no, grouping);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	/* Add in separator characters, overwriting the same buffer.  */
  .    .    .  .    .    .  .    .    .  	wcp = group_number (wstartp, wcp, intdig_no, grouping, thousands_sepwc,
  .    .    .  .    .    .  .    .    .  			    ngroups);
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Write the exponent if it is needed.  */
  3    0    0  1    0    0  0    0    0      if (type != 'f')
  .    .    .  .    .    .  .    .    .        {
  5    2    2  2    0    0  0    0    0  	if (__builtin_expect (expsign != 0 && exponent == 4 && spec == 'g', 0))
  .    .    .  .    .    .  .    .    .  	  {
  .    .    .  .    .    .  .    .    .  	    /* This is another special case.  The exponent of the number is
  .    .    .  .    .    .  .    .    .  	       really smaller than -4, which requires the 'e'/'E' format.
  .    .    .  .    .    .  .    .    .  	       But after rounding the number has an exponent of -4.  */
  .    .    .  .    .    .  .    .    .  	    assert (wcp >= wstartp + 1);
  .    .    .  .    .    .  .    .    .  	    assert (wstartp[0] == L'1');
  .    .    .  .    .    .  .    .    .  	    __wmemcpy (wstartp, L"0.0001", 6);
  .    .    .  .    .    .  .    .    .  	    wstartp[1] = decimalwc;
-- line 1120 ----------------------------------------
-- line 1123 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		wmemset (wstartp + 6, L'0', wcp - (wstartp + 2));
  .    .    .  .    .    .  .    .    .  		wcp += 4;
  .    .    .  .    .    .  .    .    .  	      }
  .    .    .  .    .    .  .    .    .  	    else
  .    .    .  .    .    .  .    .    .  	      wcp += 5;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .  	else
  .    .    .  .    .    .  .    .    .  	  {
  1    0    0  0    0    0  1    0    0  	    *wcp++ = (wchar_t) type;
  6    0    0  1    0    0  1    0    0  	    *wcp++ = expsign ? L'-' : L'+';
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	    /* Find the magnitude of the exponent.	*/
  .    .    .  .    .    .  .    .    .  	    expscale = 10;
  3    0    0  1    0    0  0    0    0  	    while (expscale <= exponent)
  .    .    .  .    .    .  .    .    .  	      expscale *= 10;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	    if (exponent < 10)
  .    .    .  .    .    .  .    .    .  	      /* Exponent always has at least two digits.  */
  4    1    1  1    0    0  1    0    0  	      *wcp++ = L'0';
  .    .    .  .    .    .  .    .    .  	    else
  .    .    .  .    .    .  .    .    .  	      do
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  expscale /= 10;
  .    .    .  .    .    .  .    .    .  		  *wcp++ = L'0' + (exponent / expscale);
  .    .    .  .    .    .  .    .    .  		  exponent %= expscale;
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	      while (expscale > 10);
  3    1    1  0    0    0  1    0    0  	    *wcp++ = L'0' + exponent;
  .    .    .  .    .    .  .    .    .  	  }
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      /* Compute number of characters which must be filled with the padding
  .    .    .  .    .    .  .    .    .         character.  */
  6    1    1  2    0    0  0    0    0      if (is_neg || info->showsign || info->space)
  1    0    0  1    0    0  0    0    0        --width;
  8    0    0  1    0    0  2    0    0      width -= wcp - wstartp;
  .    .    .  .    .    .  .    .    .  
  7    1    1  1    0    0  0    0    0      if (!info->left && info->pad != '0' && width > 0)
  .    .    .  .    .    .  .    .    .        PADN (info->pad, width);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0      if (is_neg)
  1    1    1  1    0    0  0    0    0        outchar ('-');
  3    1    1  1    0    0  0    0    0      else if (info->showsign)
  .    .    .  .    .    .  .    .    .        outchar ('+');
  2    1    1  0    0    0  0    0    0      else if (info->space)
 16    5    5  3    0    0  1    0    0        outchar (' ');
  .    .    .  .    .    .  .    .    .  
  4    0    0  1    0    0  0    0    0      if (!info->left && info->pad == '0' && width > 0)
  .    .    .  .    .    .  .    .    .        PADN ('0', width);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        char *buffer = NULL;
  .    .    .  .    .    .  .    .    .        char *buffer_end = NULL;
  .    .    .  .    .    .  .    .    .        char *cp = NULL;
  .    .    .  .    .    .  .    .    .        char *tmpptr;
  .    .    .  .    .    .  .    .    .  
  3    1    1  1    0    0  0    0    0        if (! wide)
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  /* Create the single byte string.  */
  .    .    .  .    .    .  .    .    .  	  size_t decimal_len;
  .    .    .  .    .    .  .    .    .  	  size_t thousands_sep_len;
  .    .    .  .    .    .  .    .    .  	  wchar_t *copywc;
  .    .    .  .    .    .  .    .    .  	  size_t factor;
  2    0    0  1    0    0  0    0    0  	  if (info->i18n)
  .    .    .  .    .    .  .    .    .  	    factor = _nl_lookup_word (loc, LC_CTYPE, _NL_CTYPE_MB_CUR_MAX);
  .    .    .  .    .    .  .    .    .  	  else
  1    0    0  0    0    0  1    0    0  	    factor = 1;
  .    .    .  .    .    .  .    .    .  
  3    1    1  1    0    0  2    0    0  	  decimal_len = strlen (decimal);
  .    .    .  .    .    .  .    .    .  
  3    0    0  1    0    0  0    0    0  	  if (thousands_sep == NULL)
  2    0    0  0    0    0  1    0    0  	    thousands_sep_len = 0;
  .    .    .  .    .    .  .    .    .  	  else
  .    .    .  .    .    .  .    .    .  	    thousands_sep_len = strlen (thousands_sep);
  .    .    .  .    .    .  .    .    .  
  3    0    0  2    0    0  0    0    0  	  size_t nbuffer = (2 + chars_needed * factor + decimal_len
  2    1    1  1    0    0  0    0    0  			    + ngroups * thousands_sep_len);
  2    0    0  1    0    0  0    0    0  	  if (__builtin_expect (buffer_malloced, 0))
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      buffer = (char *) malloc (nbuffer);
  .    .    .  .    .    .  .    .    .  	      if (buffer == NULL)
  .    .    .  .    .    .  .    .    .  		{
  .    .    .  .    .    .  .    .    .  		  /* Signal an error to the caller.  */
  .    .    .  .    .    .  .    .    .  		  free (wbuffer);
  .    .    .  .    .    .  .    .    .  		  return -1;
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	  else
 18    1    1  2    0    0  1    0    0  	    buffer = (char *) alloca (nbuffer);
  3    1    1  1    0    0  1    0    0  	  buffer_end = buffer + nbuffer;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Now copy the wide character string.  Since the character
  .    .    .  .    .    .  .    .    .  	     (except for the decimal point and thousands separator) must
  .    .    .  .    .    .  .    .    .  	     be coming from the ASCII range we can esily convert the
  .    .    .  .    .    .  .    .    .  	     string without mapping tables.  */
 46    0    0  2    0    0  3    0    0  	  for (cp = buffer, copywc = wstartp; copywc < wcp; ++copywc)
 36    1    1 12    0    0  0    0    0  	    if (*copywc == decimalwc)
  5    0    0  2    0    0  1    0    0  	      cp = (char *) __mempcpy (cp, decimal, decimal_len);
 22    0    0  0    0    0  0    0    0  	    else if (*copywc == thousands_sepwc)
  .    .    .  .    .    .  .    .    .  	      cp = (char *) __mempcpy (cp, thousands_sep, thousands_sep_len);
  .    .    .  .    .    .  .    .    .  	    else
 22    0    0  0    0    0 11    0    0  	      *cp++ = (char) *copywc;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
  1    1    1  1    0    0  0    0    0        tmpptr = buffer;
  2    0    0  1    0    0  0    0    0        if (__builtin_expect (info->i18n, 0))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  #ifdef COMPILE_WPRINTF
  .    .    .  .    .    .  .    .    .  	  wstartp = _i18n_number_rewrite (wstartp, wcp,
  .    .    .  .    .    .  .    .    .  					  wbuffer + wbuffer_to_alloc);
  .    .    .  .    .    .  .    .    .  	  wcp = wbuffer + wbuffer_to_alloc;
  .    .    .  .    .    .  .    .    .  	  assert ((uintptr_t) wbuffer <= (uintptr_t) wstartp);
  .    .    .  .    .    .  .    .    .  	  assert ((uintptr_t) wstartp
  .    .    .  .    .    .  .    .    .  		  < (uintptr_t) wbuffer + wbuffer_to_alloc);
-- line 1236 ----------------------------------------
-- line 1237 ----------------------------------------
  .    .    .  .    .    .  .    .    .  #else
  .    .    .  .    .    .  .    .    .  	  tmpptr = _i18n_number_rewrite (tmpptr, cp, buffer_end);
  .    .    .  .    .    .  .    .    .  	  cp = buffer_end;
  .    .    .  .    .    .  .    .    .  	  assert ((uintptr_t) buffer <= (uintptr_t) tmpptr);
  .    .    .  .    .    .  .    .    .  	  assert ((uintptr_t) tmpptr < (uintptr_t) buffer_end);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
206    2    2 49    0    0 24    0    0        PRINT (tmpptr, wstartp, wide ? wcp - wstartp : cp - tmpptr);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        /* Free the memory if necessary.  */
  2    1    1  1    0    0  0    0    0        if (__builtin_expect (buffer_malloced, 0))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  free (buffer);
  .    .    .  .    .    .  .    .    .  	  free (wbuffer);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  3    0    0  1    0    0  0    0    0      if (info->left && width > 0)
  .    .    .  .    .    .  .    .    .        PADN (info->pad, width);
  .    .    .  .    .    .  .    .    .    }
  .    .    .  .    .    .  .    .    .    return done;
  8    1    1  7    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  libc_hidden_def (__printf_fp_l)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  int
  .    .    .  .    .    .  .    .    .  ___printf_fp (FILE *fp, const struct printf_info *info,
  .    .    .  .    .    .  .    .    .  	      const void *const *args)
  1    0    0  0    0    0  0    0    0  {
  5    1    1  2    1    0  0    0    0    return __printf_fp_l (fp, _NL_CURRENT_LOCALE, info, args);
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  ldbl_hidden_def (___printf_fp, __printf_fp)
  .    .    .  .    .    .  .    .    .  ldbl_strong_alias (___printf_fp, __printf_fp)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Return the number of extra grouping characters that will be inserted
  .    .    .  .    .    .  .    .    .     into a number with INTDIG_MAX integer digits.  */
  .    .    .  .    .    .  .    .    .  
-- line 1274 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-version.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 48 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static inline struct link_map *
  .    .    .   .    .    .   .    .    .  __attribute ((always_inline))
  .    .    .   .    .    .   .    .    .  find_needed (const char *name, struct link_map *map)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    struct link_map *tmap;
  .    .    .   .    .    .   .    .    .    unsigned int n;
  .    .    .   .    .    .   .    .    .  
 67    1    1  10    0    0   0    0    0    for (tmap = GL(dl_ns)[map->l_ns]._ns_loaded; tmap != NULL;
 16    0    0  16    0    0   0    0    0         tmap = tmap->l_next)
110    0    0   0    0    0  21    0    0      if (_dl_name_match_p (name, tmap))
  .    .    .   .    .    .   .    .    .        return tmap;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* The required object is not in the global scope, look to see if it is
  .    .    .   .    .    .   .    .    .       a dependency of the current object.  */
  .    .    .   .    .    .   .    .    .    for (n = 0; n < map->l_searchlist.r_nlist; n++)
  .    .    .   .    .    .   .    .    .      if (_dl_name_match_p (name, map->l_searchlist.r_list[n]))
  .    .    .   .    .    .   .    .    .        return map->l_searchlist.r_list[n];
  .    .    .   .    .    .   .    .    .  
-- line 66 ----------------------------------------
-- line 68 ----------------------------------------
  .    .    .   .    .    .   .    .    .    return NULL;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  match_symbol (const char *name, Lmid_t ns, ElfW(Word) hash, const char *string,
  .    .    .   .    .    .   .    .    .  	      struct link_map *map, int verbose, int weak)
169    1    1   0    0    0 104    0    0  {
 26    0    0  26    0    0   0    0    0    const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
  .    .    .   .    .    .   .    .    .    ElfW(Addr) def_offset;
  .    .    .   .    .    .   .    .    .    ElfW(Verdef) *def;
  .    .    .   .    .    .   .    .    .    /* Initialize to make the compiler happy.  */
  .    .    .   .    .    .   .    .    .    const char *errstring = NULL;
  .    .    .   .    .    .   .    .    .    int result = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Display information about what we are doing while debugging.  */
 26    1    1  13    0    0   0    0    0    if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_VERSIONS, 0))
  .    .    .   .    .    .   .    .    .      _dl_debug_printf ("\
  .    .    .   .    .    .   .    .    .  checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
  .    .    .   .    .    .   .    .    .  		      string, map->l_name[0] ? map->l_name : rtld_progname,
  .    .    .   .    .    .   .    .    .  		      map->l_ns, name, ns);
  .    .    .   .    .    .   .    .    .  
 39    0    0  13    0    0   0    0    0    if (__builtin_expect (map->l_info[VERSYMIDX (DT_VERDEF)] == NULL, 0))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* The file has no symbol versioning.  I.e., the dependent
  .    .    .   .    .    .   .    .    .  	 object was linked against another version of this file.  We
  .    .    .   .    .    .   .    .    .  	 only print a message if verbose output is requested.  */
  .    .    .   .    .    .   .    .    .        if (verbose)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* XXX We cannot translate the messages.  */
  .    .    .   .    .    .   .    .    .  	  errstring = make_string ("\
-- line 99 ----------------------------------------
-- line 101 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	  goto call_cerror;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .        return 0;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    def_offset = map->l_info[VERSYMIDX (DT_VERDEF)]->d_un.d_ptr;
  .    .    .   .    .    .   .    .    .    assert (def_offset != 0);
  .    .    .   .    .    .   .    .    .  
 26    0    0  26    1    0   0    0    0    def = (ElfW(Verdef) *) ((char *) map->l_addr + def_offset);
  .    .    .   .    .    .   .    .    .    while (1)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Currently the version number of the definition entry is 1.
  .    .    .   .    .    .   .    .    .  	 Make sure all we see is this version.  */
188    0    0  94    9    9   0    0    0        if (__builtin_expect (def->vd_version, 1) != 1)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  char buf[20];
  .    .    .   .    .    .   .    .    .  	  buf[sizeof (buf) - 1] = '\0';
  .    .    .   .    .    .   .    .    .  	  /* XXX We cannot translate the message.  */
  .    .    .   .    .    .   .    .    .  	  errstring = make_string ("unsupported version ",
  .    .    .   .    .    .   .    .    .  				   _itoa (def->vd_version,
  .    .    .   .    .    .   .    .    .  					  &buf[sizeof (buf) - 1], 10, 0),
  .    .    .   .    .    .   .    .    .  				   " of Verdef record");
  .    .    .   .    .    .   .    .    .  	  result = 1;
  .    .    .   .    .    .   .    .    .  	  goto call_cerror;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Compare the hash values.  */
188    0    0  94    4    4   0    0    0        if (hash == def->vd_hash)
  .    .    .   .    .    .   .    .    .  	{
 13    1    1  13    0    0   0    0    0  	  ElfW(Verdaux) *aux = (ElfW(Verdaux) *) ((char *) def + def->vd_aux);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* To be safe, compare the string as well.  */
 78    1    1  13    0    0  13    0    0  	  if (__builtin_expect (strcmp (string, strtab + aux->vda_name), 0)
  .    .    .   .    .    .   .    .    .  	      == 0)
  .    .    .   .    .    .   .    .    .  	    /* Bingo!  */
  .    .    .   .    .    .   .    .    .  	    return 0;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* If no more definitions we failed to find what we want.  */
243    1    1  81    4    4   0    0    0        if (def->vd_next == 0)
  .    .    .   .    .    .   .    .    .  	break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Next definition.  */
 81    0    0   0    0    0   0    0    0        def = (ElfW(Verdef) *) ((char *) def + def->vd_next);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Symbol not found.  If it was a weak reference it is not fatal.  */
  .    .    .   .    .    .   .    .    .    if (__builtin_expect (weak, 1))
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (verbose)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  /* XXX We cannot translate the message.  */
-- line 152 ----------------------------------------
-- line 160 ----------------------------------------
  .    .    .   .    .    .   .    .    .    /* XXX We cannot translate the message.  */
  .    .    .   .    .    .   .    .    .    errstring = make_string ("version `", string, "' not found (required by ",
  .    .    .   .    .    .   .    .    .  			   name, ")");
  .    .    .   .    .    .   .    .    .    result = 1;
  .    .    .   .    .    .   .    .    .   call_cerror:
  .    .    .   .    .    .   .    .    .    _dl_signal_cerror (0, map->l_name[0] ? map->l_name : rtld_progname,
  .    .    .   .    .    .   .    .    .  		     N_("version lookup error"), errstring);
  .    .    .   .    .    .   .    .    .    return result;
104    0    0  91    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  _dl_check_map_versions (struct link_map *map, int verbose, int trace_mode)
 55    2    2   0    0    0  40    0    0  {
  2    0    0   0    0    0   0    0    0    int result = 0;
  .    .    .   .    .    .   .    .    .    const char *strtab;
  .    .    .   .    .    .   .    .    .    /* Pointer to section with needed versions.  */
  .    .    .   .    .    .   .    .    .    ElfW(Dyn) *dyn;
  .    .    .   .    .    .   .    .    .    /* Pointer to dynamic section with definitions.  */
  .    .    .   .    .    .   .    .    .    ElfW(Dyn) *def;
  .    .    .   .    .    .   .    .    .    /* We need to find out which is the highest version index used
  .    .    .   .    .    .   .    .    .      in a dependecy.  */
  2    0    0   0    0    0   0    0    0    unsigned int ndx_high = 0;
  .    .    .   .    .    .   .    .    .    /* Initialize to make the compiler happy.  */
  .    .    .   .    .    .   .    .    .    const char *errstring = NULL;
  .    .    .   .    .    .   .    .    .    int errval = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* If we don't have a string table, we must be ok.  */
 15    0    0   5    0    0   0    0    0    if (map->l_info[DT_STRTAB] == NULL)
  .    .    .   .    .    .   .    .    .      return 0;
 10    0    0   5    0    0   5    0    0    strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
  .    .    .   .    .    .   .    .    .  
 10    0    0   5    0    0   5    0    0    dyn = map->l_info[VERSYMIDX (DT_VERNEED)];
 10    0    0   5    0    0   5    0    0    def = map->l_info[VERSYMIDX (DT_VERDEF)];
  .    .    .   .    .    .   .    .    .  
 10    1    1   0    0    0   0    0    0    if (dyn != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* This file requires special versions from its dependencies.  */
 12    0    0   9    0    0   3    0    0        ElfW(Verneed) *ent = (ElfW(Verneed) *) (map->l_addr + dyn->d_un.d_ptr);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Currently the version number of the needed entry is 1.
  .    .    .   .    .    .   .    .    .  	 Make sure all we see is this version.  */
 18    0    0   6    2    2   0    0    0        if (__builtin_expect (ent->vn_version, 1) != 1)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  char buf[20];
  .    .    .   .    .    .   .    .    .  	  buf[sizeof (buf) - 1] = '\0';
  .    .    .   .    .    .   .    .    .  	  /* XXX We cannot translate the message.  */
  .    .    .   .    .    .   .    .    .  	  errstring = make_string ("unsupported version ",
  .    .    .   .    .    .   .    .    .  				   _itoa (ent->vn_version,
  .    .    .   .    .    .   .    .    .  					  &buf[sizeof (buf) - 1], 10, 0),
  .    .    .   .    .    .   .    .    .  				   " of Verneed record\n");
-- line 211 ----------------------------------------
-- line 212 ----------------------------------------
  .    .    .   .    .    .   .    .    .  	call_error:
  .    .    .   .    .    .   .    .    .  	  _dl_signal_error (errval, *map->l_name ? map->l_name : rtld_progname,
  .    .    .   .    .    .   .    .    .  			    NULL, errstring);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        while (1)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  ElfW(Vernaux) *aux;
 15    0    0  15    0    0   0    0    0  	  struct link_map *needed = find_needed (strtab + ent->vn_file, map);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* If NEEDED is NULL this means a dependency was not found
  .    .    .   .    .    .   .    .    .  	     and no stub entry was created.  This should never happen.  */
  .    .    .   .    .    .   .    .    .  	  assert (needed != NULL);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Make sure this is no stub we created because of a missing
  .    .    .   .    .    .   .    .    .  	     dependency.  */
 15    1    1   5    0    0   0    0    0  	  if (__builtin_expect (! trace_mode, 1)
  .    .    .   .    .    .   .    .    .  	      || ! __builtin_expect (needed->l_faked, 0))
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      /* NEEDED is the map for the file we need.  Now look for the
  .    .    .   .    .    .   .    .    .  		 dependency symbols.  */
 40    0    0  10    1    1   0    0    0  	      aux = (ElfW(Vernaux) *) ((char *) ent + ent->vn_aux);
  .    .    .   .    .    .   .    .    .  	      while (1)
  .    .    .   .    .    .   .    .    .  		{
  .    .    .   .    .    .   .    .    .  		  /* Match the symbol.  */
203    1    1 125    4    3  26    0    0  		  result |= match_symbol ((*map->l_name
  .    .    .   .    .    .   .    .    .  					   ? map->l_name : rtld_progname),
  .    .    .   .    .    .   .    .    .  					  map->l_ns, aux->vna_hash,
  .    .    .   .    .    .   .    .    .  					  strtab + aux->vna_name,
  .    .    .   .    .    .   .    .    .  					  needed->l_real, verbose,
  .    .    .   .    .    .   .    .    .  					  aux->vna_flags & VER_FLG_WEAK);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  		  /* Compare the version index.  */
 52    0    0  13    0    0   0    0    0  		  if ((unsigned int) (aux->vna_other & 0x7fff) > ndx_high)
  .    .    .   .    .    .   .    .    .  		    ndx_high = aux->vna_other & 0x7fff;
  .    .    .   .    .    .   .    .    .  
 49    1    1  13    0    0   0    0    0  		  if (aux->vna_next == 0)
  .    .    .   .    .    .   .    .    .  		    /* No more symbols.  */
  .    .    .   .    .    .   .    .    .  		    break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  		  /* Next symbol.  */
  8    0    0   0    0    0   0    0    0  		  aux = (ElfW(Vernaux) *) ((char *) aux + aux->vna_next);
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  
 20    0    0  10    0    0   0    0    0  	  if (ent->vn_next == 0)
  .    .    .   .    .    .   .    .    .  	    /* No more dependencies.  */
  .    .    .   .    .    .   .    .    .  	    break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	  /* Next dependency.  */
  2    0    0   2    0    0   0    0    0  	  ent = (ElfW(Verneed) *) ((char *) ent + ent->vn_next);
  2    0    0   0    0    0   0    0    0  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* We also must store the names of the defined versions.  Determine
  .    .    .   .    .    .   .    .    .       the maximum index here as well.
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .       XXX We could avoid the loop by just taking the number of definitions
  .    .    .   .    .    .   .    .    .       as an upper bound of new indeces.  */
 15    1    1   5    0    0   0    0    0    if (def != NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        ElfW(Verdef) *ent;
  9    0    0   6    0    0   0    0    0        ent = (ElfW(Verdef) *) (map->l_addr + def->d_un.d_ptr);
  .    .    .   .    .    .   .    .    .        while (1)
  .    .    .   .    .    .   .    .    .  	{
148    0    0  37    3    3   0    0    0  	  if ((unsigned int) (ent->vd_ndx & 0x7fff) > ndx_high)
  .    .    .   .    .    .   .    .    .  	    ndx_high = ent->vd_ndx & 0x7fff;
  .    .    .   .    .    .   .    .    .  
111    0    0  37    0    0   0    0    0  	  if (ent->vd_next == 0)
  .    .    .   .    .    .   .    .    .  	    /* No more definitions.  */
  .    .    .   .    .    .   .    .    .  	    break;
  .    .    .   .    .    .   .    .    .  
 34    0    0   0    0    0   0    0    0  	  ent = (ElfW(Verdef) *) ((char *) ent + ent->vd_next);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
 10    1    1   0    0    0   0    0    0    if (ndx_high > 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Now we are ready to build the array with the version names
  .    .    .   .    .    .   .    .    .  	 which can be indexed by the version index in the VERSYM
  .    .    .   .    .    .   .    .    .  	 section.  */
  4    0    0   0    0    0   4    0    0        map->l_versions = (struct r_found_version *)
 16    0    0   0    0    0   4    0    0  	calloc (ndx_high + 1, sizeof (*map->l_versions));
  8    0    0   0    0    0   0    0    0        if (__builtin_expect (map->l_versions == NULL, 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  errstring = N_("cannot allocate version reference table");
  .    .    .   .    .    .   .    .    .  	  errval = ENOMEM;
  .    .    .   .    .    .   .    .    .  	  goto call_error;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Store the number of available symbols.  */
  4    0    0   0    0    0   4    0    0        map->l_nversions = ndx_high + 1;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Compute the pointer to the version symbols.  */
 12    1    1   8    1    0   4    0    0        map->l_versyms = (void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);
  .    .    .   .    .    .   .    .    .  
 12    0    0   4    0    0   0    0    0        if (dyn != NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  ElfW(Verneed) *ent;
 12    0    0   9    0    0   0    0    0  	  ent = (ElfW(Verneed) *) (map->l_addr + dyn->d_un.d_ptr);
  .    .    .   .    .    .   .    .    .  	  while (1)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      ElfW(Vernaux) *aux;
 15    0    0   5    0    0   0    0    0  	      aux = (ElfW(Vernaux) *) ((char *) ent + ent->vn_aux);
  .    .    .   .    .    .   .    .    .  	      while (1)
  .    .    .   .    .    .   .    .    .  		{
 39    1    1  13    0    0   0    0    0  		  ElfW(Half) ndx = aux->vna_other & 0x7fff;
  .    .    .   .    .    .   .    .    .  		  /* In trace mode, dependencies may be missing.  */
 39    0    0   0    0    0   0    0    0  		  if (__builtin_expect (ndx < map->l_nversions, 1))
  .    .    .   .    .    .   .    .    .  		    {
 65    0    0  13    0    0  13    0    0  		      map->l_versions[ndx].hash = aux->vna_hash;
 39    0    0   0    0    0  13    4    4  		      map->l_versions[ndx].hidden = aux->vna_other & 0x8000;
 39    0    0  13    0    0  13    2    2  		      map->l_versions[ndx].name = &strtab[aux->vna_name];
 39    1    1  13    0    0  13    1    1  		      map->l_versions[ndx].filename = &strtab[ent->vn_file];
  .    .    .   .    .    .   .    .    .  		    }
  .    .    .   .    .    .   .    .    .  
 39    0    0  13    0    0   0    0    0  		  if (aux->vna_next == 0)
  .    .    .   .    .    .   .    .    .  		    /* No more symbols.  */
  .    .    .   .    .    .   .    .    .  		    break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  		  /* Advance to next symbol.  */
  8    0    0   0    0    0   0    0    0  		  aux = (ElfW(Vernaux) *) ((char *) aux + aux->vna_next);
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  
 15    0    0   5    0    0   0    0    0  	      if (ent->vn_next == 0)
  .    .    .   .    .    .   .    .    .  		/* No more dependencies.  */
  .    .    .   .    .    .   .    .    .  		break;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  	      /* Advance to next dependency.  */
  2    0    0   0    0    0   0    0    0  	      ent = (ElfW(Verneed) *) ((char *) ent + ent->vn_next);
  2    0    0   0    0    0   0    0    0  	    }
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* And insert the defined versions.  */
 12    0    0   4    0    0   0    0    0        if (def != NULL)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  ElfW(Verdef) *ent;
 12    0    0   9    0    0   0    0    0  	  ent = (ElfW(Verdef)  *) (map->l_addr + def->d_un.d_ptr);
  .    .    .   .    .    .   .    .    .  	  while (1)
  .    .    .   .    .    .   .    .    .  	    {
  .    .    .   .    .    .   .    .    .  	      ElfW(Verdaux) *aux;
 37    0    0  37    0    0   0    0    0  	      aux = (ElfW(Verdaux) *) ((char *) ent + ent->vd_aux);
  .    .    .   .    .    .   .    .    .  
 74    0    0  37    0    0   0    0    0  	      if ((ent->vd_flags & VER_FLG_BASE) == 0)
  .    .    .   .    .    .   .    .    .  		{
  .    .    .   .    .    .   .    .    .  		  /* The name of the base version should not be
  .    .    .   .    .    .   .    .    .  		     available for matching a versioned symbol.  */
 34    0    0  34    0    0   0    0    0  		  ElfW(Half) ndx = ent->vd_ndx & 0x7fff;
170    0    0  34    0    0  34   11   11  		  map->l_versions[ndx].hash = ent->vd_hash;
102    0    0  34    0    0  34    0    0  		  map->l_versions[ndx].name = &strtab[aux->vda_name];
 34    0    0   0    0    0  34    3    3  		  map->l_versions[ndx].filename = NULL;
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  
111    0    0  37    0    0   0    0    0  	      if (ent->vd_next == 0)
  .    .    .   .    .    .   .    .    .  		/* No more definitions.  */
  .    .    .   .    .    .   .    .    .  		break;
  .    .    .   .    .    .   .    .    .  
 34    0    0   0    0    0   0    0    0  	      ent = (ElfW(Verdef) *) ((char *) ent + ent->vd_next);
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  9    0    0   0    0    0   0    0    0    return result;
 40    2    2  35    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  internal_function
  .    .    .   .    .    .   .    .    .  _dl_check_all_versions (struct link_map *map, int verbose, int trace_mode)
  6    1    1   0    0    0   4    0    0  {
  .    .    .   .    .    .   .    .    .    struct link_map *l;
  2    0    0   0    0    0   0    0    0    int result = 0;
  .    .    .   .    .    .   .    .    .  
 19    1    1   5    0    0   0    0    0    for (l = map; l != NULL; l = l->l_next)
  5    1    1   0    0    0   0    0    0      result |= (! l->l_faked
 50    0    0   5    0    0   5    0    0  	       && _dl_check_map_versions (l, verbose, trace_mode));
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    return result;
  7    0    0   5    0    0   0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/nptl/../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 29 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	.text
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* int pthread_cond_signal (pthread_cond_t *cond) */
  .    .    .   .    .    .  .    .    .  	.globl	__pthread_cond_signal
  .    .    .   .    .    .  .    .    .  	.type	__pthread_cond_signal, @function
  .    .    .   .    .    .  .    .    .  	.align	16
  .    .    .   .    .    .  .    .    .  __pthread_cond_signal:
  .    .    .   .    .    .  .    .    .  
120    1    1   0    0    0  0    0    0  	LIBC_PROBE (cond_signal, 1, %rdi)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* Get internal lock.  */
120    0    0   0    0    0  0    0    0  	movq	%rdi, %r8
120    0    0   0    0    0  0    0    0  	movl	$1, %esi
120    0    0   0    0    0  0    0    0  	xorl	%eax, %eax
120    0    0 120    1    1  0    0    0  	LOCK
  .    .    .   .    .    .  .    .    .  #if cond_lock == 0
  .    .    .   .    .    .  .    .    .  	cmpxchgl %esi, (%rdi)
  .    .    .   .    .    .  .    .    .  #else
  .    .    .   .    .    .  .    .    .  	cmpxchgl %esi, cond_lock(%rdi)
  .    .    .   .    .    .  .    .    .  #endif
120    0    0   0    0    0  0    0    0  	jnz	1f
  .    .    .   .    .    .  .    .    .  
120    0    0   0    0    0  0    0    0  2:	addq	$cond_futex, %rdi
120    0    0 120    0    0  0    0    0  	movq	total_seq(%r8), %rcx
120    0    0 120    0    0  0    0    0  	cmpq	wakeup_seq(%r8), %rcx
120    0    0   0    0    0  0    0    0  	jbe	4f
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* Bump the wakeup number.  */
  .    .    .   .    .    .  .    .    .  	addq	$1, wakeup_seq(%r8)
  .    .    .   .    .    .  .    .    .  	addl	$1, (%rdi)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* Wake up one thread.  */
  .    .    .   .    .    .  .    .    .  	LP_OP(cmp) $-1, dep_mutex(%r8)
  .    .    .   .    .    .  .    .    .  	movl	$FUTEX_WAKE_OP, %esi
-- line 62 ----------------------------------------
-- line 116 ----------------------------------------
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  	orl	$FUTEX_WAKE, %esi
  .    .    .   .    .    .  .    .    .  	movl	$SYS_futex, %eax
  .    .    .   .    .    .  .    .    .  	/* %rdx should be 1 already from $FUTEX_WAKE_OP syscall.
  .    .    .   .    .    .  .    .    .  	movl	$1, %edx  */
  .    .    .   .    .    .  .    .    .  	syscall
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* Unlock.  */
120    1    1 240    0    0  0    0    0  4:	LOCK
  .    .    .   .    .    .  .    .    .  #if cond_lock == 0
  .    .    .   .    .    .  .    .    .  	decl	(%r8)
  .    .    .   .    .    .  .    .    .  #else
  .    .    .   .    .    .  .    .    .  	decl	cond_lock(%r8)
  .    .    .   .    .    .  .    .    .  #endif
120    0    0   0    0    0  0    0    0  	jne	5f
  .    .    .   .    .    .  .    .    .  
120    0    0   0    0    0  0    0    0  6:	xorl	%eax, %eax
120    0    0 120    0    0  0    0    0  	retq
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	/* Initial locking failed.  */
  .    .    .   .    .    .  .    .    .  1:
  .    .    .   .    .    .  .    .    .  #if cond_lock != 0
  .    .    .   .    .    .  .    .    .  	addq	$cond_lock, %rdi
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
  .    .    .   .    .    .  .    .    .  	movl	$LLL_PRIVATE, %eax
-- line 141 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/string/../sysdeps/x86_64/cacheinfo.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 113 ----------------------------------------
  .    .    .   .    .    .  .    .    .  intel_02_known_compare (const void *p1, const void *p2)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    const struct intel_02_cache_info *i1;
  .    .    .   .    .    .  .    .    .    const struct intel_02_cache_info *i2;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    i1 = (const struct intel_02_cache_info *) p1;
  .    .    .   .    .    .  .    .    .    i2 = (const struct intel_02_cache_info *) p2;
  .    .    .   .    .    .  .    .    .  
162    1    1 108    6    6  0    0    0    if (i1->idx == i2->idx)
  .    .    .   .    .    .  .    .    .      return 0;
  .    .    .   .    .    .  .    .    .  
162    0    0  54    0    0  0    0    0    return i1->idx < i2->idx ? -1 : 1;
  .    .    .   .    .    .  .    .    .  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  static long int
  .    .    .   .    .    .  .    .    .  __attribute__ ((noinline))
  .    .    .   .    .    .  .    .    .  intel_check_word (int name, unsigned int value, bool *has_level_2,
  .    .    .   .    .    .  .    .    .  		  bool *no_level_2_or_3)
 32    1    1   0    0    0 24    0    0  {
 12    0    0   0    0    0  0    0    0    if ((value & 0x80000000) != 0)
  .    .    .   .    .    .  .    .    .      /* The register value is reserved.  */
  2    1    1   0    0    0  0    0    0      return 0;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Fold the name.  The _SC_ constants are always in the order SIZE,
  .    .    .   .    .    .  .    .    .       ASSOC, LINESIZE.  */
 36    1    1   0    0    0  0    0    0    int folded_rel_name = (M(name) / 3) * 3;
  .    .    .   .    .    .  .    .    .  
 24    0    0   0    0    0  0    0    0    while (value != 0)
  .    .    .   .    .    .  .    .    .      {
 10    1    1   0    0    0  0    0    0        unsigned int byte = value & 0xff;
  .    .    .   .    .    .  .    .    .  
 20    0    0   0    0    0  0    0    0        if (byte == 0x40)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  *no_level_2_or_3 = true;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  if (folded_rel_name == M(_SC_LEVEL3_CACHE_SIZE))
  .    .    .   .    .    .  .    .    .  	    /* No need to look further.  */
  .    .    .   .    .    .  .    .    .  	    break;
  .    .    .   .    .    .  .    .    .  	}
 20    0    0   0    0    0  0    0    0        else if (byte == 0xff)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  /* CPUID leaf 0x4 contains all the information.  We need to
  .    .    .   .    .    .  .    .    .  	     iterate over it.  */
  .    .    .   .    .    .  .    .    .  	  unsigned int eax;
  .    .    .   .    .    .  .    .    .  	  unsigned int ebx;
  .    .    .   .    .    .  .    .    .  	  unsigned int ecx;
  .    .    .   .    .    .  .    .    .  	  unsigned int edx;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  unsigned int round = 0;
  .    .    .   .    .    .  .    .    .  	  while (1)
  .    .    .   .    .    .  .    .    .  	    {
 39    2    2   0    0    0  0    0    0  	      asm volatile ("xchgl %%ebx, %1; cpuid; xchgl %%ebx, %1"
  .    .    .   .    .    .  .    .    .  			    : "=a" (eax), "=r" (ebx), "=c" (ecx), "=d" (edx)
  .    .    .   .    .    .  .    .    .  			    : "0" (4), "2" (round));
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	      enum { null = 0, data = 1, inst = 2, uni = 3 } type = eax & 0x1f;
 16    0    0   0    0    0  0    0    0  	      if (type == null)
  .    .    .   .    .    .  .    .    .  		/* That was the end.  */
  .    .    .   .    .    .  .    .    .  		break;
  .    .    .   .    .    .  .    .    .  
 10    2    2   0    0    0  0    0    0  	      unsigned int level = (eax >> 5) & 0x7;
  .    .    .   .    .    .  .    .    .  
  4    1    1   0    0    0  0    0    0  	      if ((level == 1 && type == data
  .    .    .   .    .    .  .    .    .  		   && folded_rel_name == M(_SC_LEVEL1_DCACHE_SIZE))
  .    .    .   .    .    .  .    .    .  		  || (level == 1 && type == inst
  .    .    .   .    .    .  .    .    .  		      && folded_rel_name == M(_SC_LEVEL1_ICACHE_SIZE))
  .    .    .   .    .    .  .    .    .  		  || (level == 2 && folded_rel_name == M(_SC_LEVEL2_CACHE_SIZE))
  9    0    0   0    0    0  0    0    0  		  || (level == 3 && folded_rel_name == M(_SC_LEVEL3_CACHE_SIZE))
  .    .    .   .    .    .  .    .    .  		  || (level == 4 && folded_rel_name == M(_SC_LEVEL4_CACHE_SIZE)))
  .    .    .   .    .    .  .    .    .  		{
  2    0    0   0    0    0  0    0    0  		  unsigned int offset = M(name) - folded_rel_name;
  .    .    .   .    .    .  .    .    .  
  4    0    0   0    0    0  0    0    0  		  if (offset == 0)
  .    .    .   .    .    .  .    .    .  		    /* Cache size.  */
 10    0    0   0    0    0  0    0    0  		    return (((ebx >> 22) + 1)
  8    0    0   0    0    0  0    0    0  			    * (((ebx >> 12) & 0x3ff) + 1)
  8    1    1   0    0    0  0    0    0  			    * ((ebx & 0xfff) + 1)
  2    0    0   0    0    0  0    0    0  			    * (ecx + 1));
  .    .    .   .    .    .  .    .    .  		  if (offset == 1)
  .    .    .   .    .    .  .    .    .  		    return (ebx >> 22) + 1;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  		  assert (offset == 2);
  .    .    .   .    .    .  .    .    .  		  return (ebx & 0xfff) + 1;
  .    .    .   .    .    .  .    .    .  		}
  .    .    .   .    .    .  .    .    .  
  3    0    0   0    0    0  0    0    0  	      ++round;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	  /* There is no other cache information anywhere else.  */
  .    .    .   .    .    .  .    .    .  	  break;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .        else
  .    .    .   .    .    .  .    .    .  	{
 16    0    0   0    0    0  0    0    0  	  if (byte == 0x49 && folded_rel_name == M(_SC_LEVEL3_CACHE_SIZE))
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      /* Intel reused this value.  For family 15, model 6 it
  .    .    .   .    .    .  .    .    .  		 specifies the 3rd level cache.  Otherwise the 2nd
  .    .    .   .    .    .  .    .    .  		 level cache.  */
  .    .    .   .    .    .  .    .    .  	      unsigned int family = GLRO(dl_x86_cpu_features).family;
  .    .    .   .    .    .  .    .    .  	      unsigned int model = GLRO(dl_x86_cpu_features).model;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	      if (family == 15 && model == 6)
-- line 214 ----------------------------------------
-- line 220 ----------------------------------------
  .    .    .   .    .    .  .    .    .  			  + (name - _SC_LEVEL3_CACHE_SIZE));
  .    .    .   .    .    .  .    .    .  		  folded_rel_name = M(_SC_LEVEL2_CACHE_SIZE);
  .    .    .   .    .    .  .    .    .  		}
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  struct intel_02_cache_info *found;
  .    .    .   .    .    .  .    .    .  	  struct intel_02_cache_info search;
  .    .    .   .    .    .  .    .    .  
  8    0    0   0    0    0  8    0    0  	  search.idx = byte;
 56    1    1   0    0    0  8    0    0  	  found = bsearch (&search, intel_02_known, nintel_02_known,
  .    .    .   .    .    .  .    .    .  			   sizeof (intel_02_known[0]), intel_02_known_compare);
 16    0    0   0    0    0  0    0    0  	  if (found != NULL)
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      if (found->rel_name == folded_rel_name)
  .    .    .   .    .    .  .    .    .  		{
  .    .    .   .    .    .  .    .    .  		  unsigned int offset = M(name) - folded_rel_name;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  		  if (offset == 0)
  .    .    .   .    .    .  .    .    .  		    /* Cache size.  */
  .    .    .   .    .    .  .    .    .  		    return found->size;
-- line 239 ----------------------------------------
-- line 245 ----------------------------------------
  .    .    .   .    .    .  .    .    .  		}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	      if (found->rel_name == M(_SC_LEVEL2_CACHE_SIZE))
  .    .    .   .    .    .  .    .    .  		*has_level_2 = true;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Next byte for the next round.  */
  8    0    0   0    0    0  0    0    0        value >>= 8;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Nothing found.  */
  .    .    .   .    .    .  .    .    .    return 0;
 32    0    0  28    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  static long int __attribute__ ((noinline))
 16    2    2   0    0    0 12    0    0  handle_intel (int name, unsigned int maxidx)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    assert (maxidx >= 2);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* OK, we can use the CPUID instruction to get all info about the
  .    .    .   .    .    .  .    .    .       caches.  */
  .    .    .   .    .    .  .    .    .    unsigned int cnt = 0;
  6    0    0   0    0    0  2    0    0    unsigned int max = 1;
  .    .    .   .    .    .  .    .    .    long int result = 0;
  2    0    0   0    0    0  2    0    0    bool no_level_2_or_3 = false;
  4    0    0   0    0    0  2    0    0    bool has_level_2 = false;
  .    .    .   .    .    .  .    .    .  
  2    0    0   0    0    0  0    0    0    while (cnt++ < max)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        unsigned int eax;
  .    .    .   .    .    .  .    .    .        unsigned int ebx;
  .    .    .   .    .    .  .    .    .        unsigned int ecx;
  .    .    .   .    .    .  .    .    .        unsigned int edx;
  8    1    1   0    0    0  2    0    0        __cpuid (2, eax, ebx, ecx, edx);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* The low byte of EAX in the first round contain the number of
  .    .    .   .    .    .  .    .    .  	 rounds we have to make.  At least one, the one we are already
  .    .    .   .    .    .  .    .    .  	 doing.  */
  4    0    0   0    0    0  0    0    0        if (cnt == 1)
  .    .    .   .    .    .  .    .    .  	{
  6    0    0   0    0    0  2    0    0  	  max = eax & 0xff;
  2    0    0   0    0    0  0    0    0  	  eax &= 0xffffff00;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Process the individual registers' value.  */
 10    0    0   0    0    0  2    0    0        result = intel_check_word (name, eax, &has_level_2, &no_level_2_or_3);
  4    0    0   0    0    0  0    0    0        if (result != 0)
  .    .    .   .    .    .  .    .    .  	return result;
  .    .    .   .    .    .  .    .    .  
 10    1    1   0    0    0  2    0    0        result = intel_check_word (name, ebx, &has_level_2, &no_level_2_or_3);
  4    0    0   0    0    0  0    0    0        if (result != 0)
  .    .    .   .    .    .  .    .    .  	return result;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        result = intel_check_word (name, ecx, &has_level_2, &no_level_2_or_3);
  .    .    .   .    .    .  .    .    .        if (result != 0)
  .    .    .   .    .    .  .    .    .  	return result;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        result = intel_check_word (name, edx, &has_level_2, &no_level_2_or_3);
  .    .    .   .    .    .  .    .    .        if (result != 0)
-- line 305 ----------------------------------------
-- line 306 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	return result;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    if (name >= _SC_LEVEL2_CACHE_SIZE && name <= _SC_LEVEL3_CACHE_LINESIZE
  .    .    .   .    .    .  .    .    .        && no_level_2_or_3)
  .    .    .   .    .    .  .    .    .      return -1;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    return 0;
 16    1    1  14    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  static long int __attribute__ ((noinline))
  .    .    .   .    .    .  .    .    .  handle_amd (int name)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    unsigned int eax;
  .    .    .   .    .    .  .    .    .    unsigned int ebx;
  .    .    .   .    .    .  .    .    .    unsigned int ecx;
-- line 322 ----------------------------------------
-- line 470 ----------------------------------------
  .    .    .   .    .    .  .    .    .  /* PREFETCHW support flag for use in memory and string routines.  */
  .    .    .   .    .    .  .    .    .  int __x86_64_prefetchw attribute_hidden;
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  static void
  .    .    .   .    .    .  .    .    .  __attribute__((constructor))
  .    .    .   .    .    .  .    .    .  init_cacheinfo (void)
  5    0    0   0    0    0  5    0    0  {
  .    .    .   .    .    .  .    .    .    /* Find out what brand of processor.  */
  .    .    .   .    .    .  .    .    .    unsigned int eax;
  .    .    .   .    .    .  .    .    .    unsigned int ebx;
  .    .    .   .    .    .  .    .    .    unsigned int ecx;
  .    .    .   .    .    .  .    .    .    unsigned int edx;
  .    .    .   .    .    .  .    .    .    int max_cpuid_ex;
  .    .    .   .    .    .  .    .    .    long int data = -1;
  .    .    .   .    .    .  .    .    .    long int shared = -1;
  .    .    .   .    .    .  .    .    .    unsigned int level;
  .    .    .   .    .    .  .    .    .    unsigned int threads = 0;
  .    .    .   .    .    .  .    .    .  
  4    0    0   2    0    0  0    0    0    if (is_intel)
  .    .    .   .    .    .  .    .    .      {
  3    1    1   0    0    0  1    0    0        data = handle_intel (_SC_LEVEL1_DCACHE_SIZE, max_cpuid);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Try L3 first.  */
  1    0    0   0    0    0  0    0    0        level  = 3;
  3    0    0   0    0    0  1    0    0        shared = handle_intel (_SC_LEVEL3_CACHE_SIZE, max_cpuid);
  .    .    .   .    .    .  .    .    .  
  2    0    0   0    0    0  0    0    0        if (shared <= 0)
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  /* Try L2 otherwise.  */
  .    .    .   .    .    .  .    .    .  	  level  = 2;
  .    .    .   .    .    .  .    .    .  	  shared = handle_intel (_SC_LEVEL2_CACHE_SIZE, max_cpuid);
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Figure out the number of logical threads that share the
  .    .    .   .    .    .  .    .    .  	 highest cache level.  */
  3    0    0   1    0    0  0    0    0        if (max_cpuid >= 4)
  .    .    .   .    .    .  .    .    .  	{
  1    1    1   1    0    0  0    0    0  	  unsigned int family = GLRO(dl_x86_cpu_features).family;
  1    0    0   1    0    0  0    0    0  	  unsigned int model = GLRO(dl_x86_cpu_features).model;
  .    .    .   .    .    .  .    .    .  
  1    0    0   0    0    0  0    0    0  	  int i = 0;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  /* Query until desired cache level is enumerated.  */
  .    .    .   .    .    .  .    .    .  	  do
  .    .    .   .    .    .  .    .    .  	    {
 21    0    0   0    0    0  0    0    0  	      __cpuid_count (4, i++, eax, ebx, ecx, edx);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	      /* There seems to be a bug in at least some Pentium Ds
  .    .    .   .    .    .  .    .    .  		 which sometimes fail to iterate all cache parameters.
  .    .    .   .    .    .  .    .    .  		 Do not loop indefinitely here, stop in this case and
  .    .    .   .    .    .  .    .    .  		 assume there is no such information.  */
  8    0    0   0    0    0  0    0    0  	      if ((eax & 0x1f) == 0)
  .    .    .   .    .    .  .    .    .  		goto intel_bug_no_cache_info;
  .    .    .   .    .    .  .    .    .  	    }
 16    0    0   0    0    0  0    0    0  	  while (((eax >> 5) & 0x7) != level);
  .    .    .   .    .    .  .    .    .  
  1    1    1   0    0    0  0    0    0  	  threads = (eax >> 14) & 0x3ff;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  /* If max_cpuid >= 11, THREADS is the maximum number of
  .    .    .   .    .    .  .    .    .  	      addressable IDs for logical processors sharing the
  .    .    .   .    .    .  .    .    .  	      cache, instead of the maximum number of threads
  .    .    .   .    .    .  .    .    .  	      sharing the cache.  */
  5    0    0   0    0    0  0    0    0  	  if (threads && max_cpuid >= 11)
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      /* Find the number of logical processors shipped in
  .    .    .   .    .    .  .    .    .  		 one core and apply count mask.  */
  .    .    .   .    .    .  .    .    .  	      i = 0;
  .    .    .   .    .    .  .    .    .  	      while (1)
  .    .    .   .    .    .  .    .    .  		{
  9    0    0   0    0    0  0    0    0  		  __cpuid_count (11, i++, eax, ebx, ecx, edx);
  .    .    .   .    .    .  .    .    .  
  2    0    0   0    0    0  0    0    0  		  int shipped = ebx & 0xff;
  .    .    .   .    .    .  .    .    .  		  int type = ecx & 0xff0;
  8    1    1   0    0    0  0    0    0  		  if (shipped == 0 || type == 0)
  .    .    .   .    .    .  .    .    .  		    break;
  4    0    0   0    0    0  0    0    0  		  else if (type == 0x200)
  .    .    .   .    .    .  .    .    .  		    {
  .    .    .   .    .    .  .    .    .  		      int count_mask;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  		      /* Compute count mask.  */
  1    1    1   0    0    0  0    0    0  		      asm ("bsr %1, %0"
  .    .    .   .    .    .  .    .    .  			   : "=r" (count_mask) : "g" (threads));
  4    0    0   0    0    0  0    0    0  		      count_mask = ~(-1 << (count_mask + 1));
  2    0    0   0    0    0  0    0    0  		      threads = (shipped - 1) & count_mask;
  1    0    0   0    0    0  0    0    0  		      break;
  .    .    .   .    .    .  .    .    .  		    }
  .    .    .   .    .    .  .    .    .  		}
  .    .    .   .    .    .  .    .    .  	    }
  2    0    0   0    0    0  0    0    0  	  threads += 1;
  4    0    0   0    0    0  0    0    0  	  if (threads > 2 && level == 2 && family == 6)
  .    .    .   .    .    .  .    .    .  	    {
  .    .    .   .    .    .  .    .    .  	      switch (model)
  .    .    .   .    .    .  .    .    .  		{
  .    .    .   .    .    .  .    .    .  		case 0x57:
  .    .    .   .    .    .  .    .    .  		  /* Knights Landing has L2 cache shared by 2 cores.  */
  .    .    .   .    .    .  .    .    .  		case 0x37:
  .    .    .   .    .    .  .    .    .  		case 0x4a:
  .    .    .   .    .    .  .    .    .  		case 0x4d:
-- line 569 ----------------------------------------
-- line 584 ----------------------------------------
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  threads
  .    .    .   .    .    .  .    .    .  	    = ((GLRO(dl_x86_cpu_features).cpuid[COMMON_CPUID_INDEX_1].ebx
  .    .    .   .    .    .  .    .    .  		>> 16) & 0xff);
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .        /* Cap usage of highest cache level to the number of supported
  .    .    .   .    .    .  .    .    .  	 threads.  */
  4    1    1   0    0    0  0    0    0        if (shared > 0 && threads > 0)
  6    0    0   0    0    0  0    0    0  	shared /= threads;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .    /* This spells out "AuthenticAMD".  */
  .    .    .   .    .    .  .    .    .    else if (is_amd)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        data   = handle_amd (_SC_LEVEL1_DCACHE_SIZE);
  .    .    .   .    .    .  .    .    .        long int core = handle_amd (_SC_LEVEL2_CACHE_SIZE);
  .    .    .   .    .    .  .    .    .        shared = handle_amd (_SC_LEVEL3_CACHE_SIZE);
  .    .    .   .    .    .  .    .    .  
-- line 601 ----------------------------------------
-- line 640 ----------------------------------------
  .    .    .   .    .    .  .    .    .  	  __cpuid (0x80000001, eax, ebx, ecx, edx);
  .    .    .   .    .    .  .    .    .  	  /*  PREFETCHW     || 3DNow!  */
  .    .    .   .    .    .  .    .    .  	  if ((ecx & 0x100) || (edx & 0x80000000))
  .    .    .   .    .    .  .    .    .  	    __x86_64_prefetchw = -1;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  #endif
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  2    1    1   0    0    0  0    0    0    if (data > 0)
  .    .    .   .    .    .  .    .    .      {
  3    1    1   0    0    0  1    0    0        __x86_64_raw_data_cache_size_half = data / 2;
  1    0    0   0    0    0  1    1    1        __x86_64_raw_data_cache_size = data;
  .    .    .   .    .    .  .    .    .        /* Round data cache size to multiple of 256 bytes.  */
  1    0    0   0    0    0  0    0    0        data = data & ~255L;
  3    0    0   0    0    0  1    0    0        __x86_64_data_cache_size_half = data / 2;
  1    0    0   0    0    0  1    0    0        __x86_64_data_cache_size = data;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  2    0    0   0    0    0  0    0    0    if (shared > 0)
  .    .    .   .    .    .  .    .    .      {
  3    0    0   0    0    0  1    0    0        __x86_64_raw_shared_cache_size_half = shared / 2;
  1    0    0   0    0    0  1    1    1        __x86_64_raw_shared_cache_size = shared;
  .    .    .   .    .    .  .    .    .        /* Round shared cache size to multiple of 256 bytes.  */
  1    1    1   0    0    0  0    0    0        shared = shared & ~255L;
  3    0    0   0    0    0  1    0    0        __x86_64_shared_cache_size_half = shared / 2;
  1    0    0   0    0    0  1    0    0        __x86_64_shared_cache_size = shared;
  .    .    .   .    .    .  .    .    .      }
  6    0    0   6    0    0  0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/../elf/dl-tls.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw  D1mw DLmw 

-- line 44 ----------------------------------------
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  size_t
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_next_tls_modid (void)
  .    .    .  .    .    .   .    .    .  {
  .    .    .  .    .    .   .    .    .    size_t result;
  .    .    .  .    .    .   .    .    .  
  3    1    1  2    0    0   0    0    0    if (__builtin_expect (GL(dl_tls_dtv_gaps), false))
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        size_t disp = 0;
  .    .    .  .    .    .   .    .    .        struct dtv_slotinfo_list *runp = GL(dl_tls_dtv_slotinfo_list);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* Note that this branch will never be executed during program
  .    .    .  .    .    .   .    .    .  	 start since there are no gaps at that time.  Therefore it
  .    .    .  .    .    .   .    .    .  	 does not matter that the dl_tls_dtv_slotinfo is not allocated
  .    .    .  .    .    .   .    .    .  	 yet when the function is called for the first times.
-- line 60 ----------------------------------------
-- line 92 ----------------------------------------
  .    .    .  .    .    .   .    .    .  	  goto nogaps;
  .    .    .  .    .    .   .    .    .  	}
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .    else
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        /* No gaps, allocate a new entry.  */
  .    .    .  .    .    .   .    .    .      nogaps:
  .    .    .  .    .    .   .    .    .  
  2    1    1  0    0    0   1    0    0        result = ++GL(dl_tls_max_dtv_idx);
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    return result;
  1    0    0  1    0    0   0    0    0  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  size_t
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_count_modids (void)
  .    .    .  .    .    .   .    .    .  {
  2    1    1  1    0    0   0    0    0    if (! __builtin_expect (GL(dl_tls_dtv_gaps), true))
  2    1    1  2    0    0   0    0    0      return GL(dl_tls_max_dtv_idx);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    size_t n = 0;
  .    .    .  .    .    .   .    .    .    struct dtv_slotinfo_list *runp = GL(dl_tls_dtv_slotinfo_list);
  .    .    .  .    .    .   .    .    .    while (runp != NULL)
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        for (size_t i = 0; i < runp->len; ++i)
  .    .    .  .    .    .   .    .    .  	if (runp->slotinfo[i].map != NULL)
  .    .    .  .    .    .   .    .    .  	  ++n;
-- line 120 ----------------------------------------
-- line 125 ----------------------------------------
  .    .    .  .    .    .   .    .    .    return n;
  .    .    .  .    .    .   .    .    .  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  #ifdef SHARED
  .    .    .  .    .    .   .    .    .  void
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_determine_tlsoffset (void)
  5    0    0  0    0    0   4    0    0  {
  1    0    0  0    0    0   0    0    0    size_t max_align = TLS_TCB_ALIGN;
  1    0    0  0    0    0   0    0    0    size_t freetop = 0;
  1    1    1  0    0    0   0    0    0    size_t freebottom = 0;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* The first element of the dtv slot info list is allocated.  */
  .    .    .  .    .    .   .    .    .    assert (GL(dl_tls_dtv_slotinfo_list) != NULL);
  .    .    .  .    .    .   .    .    .    /* There is at this point only one element in the
  .    .    .  .    .    .   .    .    .       dl_tls_dtv_slotinfo_list list.  */
  .    .    .  .    .    .   .    .    .    assert (GL(dl_tls_dtv_slotinfo_list)->next == NULL);
  .    .    .  .    .    .   .    .    .  
  2    0    0  1    0    0   0    0    0    struct dtv_slotinfo *slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* Determining the offset of the various parts of the static TLS
  .    .    .  .    .    .   .    .    .       block has several dependencies.  In addition we have to work
  .    .    .  .    .    .   .    .    .       around bugs in some toolchains.
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .       Each TLS block from the objects available at link time has a size
  .    .    .  .    .    .   .    .    .       and an alignment requirement.  The GNU ld computes the alignment
  .    .    .  .    .    .   .    .    .       requirements for the data at the positions *in the file*, though.
-- line 152 ----------------------------------------
-- line 168 ----------------------------------------
  .    .    .  .    .    .   .    .    .       The extra space which might be allocated before the first byte of
  .    .    .  .    .    .   .    .    .       the TLS block need not go unused.  The code below tries to use
  .    .    .  .    .    .   .    .    .       that memory for the next TLS block.  This can work if the total
  .    .    .  .    .    .   .    .    .       memory requirement for the next TLS block is smaller than the
  .    .    .  .    .    .   .    .    .       gap.  */
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  #if TLS_TCB_AT_TP
  .    .    .  .    .    .   .    .    .    /* We simply start with zero.  */
  1    0    0  0    0    0   0    0    0    size_t offset = 0;
  .    .    .  .    .    .   .    .    .  
  8    0    0  2    1    1   0    0    0    for (size_t cnt = 0; slotinfo[cnt].map != NULL; ++cnt)
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        assert (cnt < GL(dl_tls_dtv_slotinfo_list)->len);
  .    .    .  .    .    .   .    .    .  
  3    0    0  1    0    0   0    0    0        size_t firstbyte = (-slotinfo[cnt].map->l_tls_firstbyte_offset
  2    1    1  1    0    0   0    0    0  			  & (slotinfo[cnt].map->l_tls_align - 1));
  .    .    .  .    .    .   .    .    .        size_t off;
  2    0    0  0    0    0   0    0    0        max_align = MAX (max_align, slotinfo[cnt].map->l_tls_align);
  .    .    .  .    .    .   .    .    .  
  5    0    0  1    0    0   0    0    0        if (freebottom - freetop >= slotinfo[cnt].map->l_tls_blocksize)
  .    .    .  .    .    .   .    .    .  	{
  2    0    0  0    0    0   0    0    0  	  off = roundup (freetop + slotinfo[cnt].map->l_tls_blocksize
  .    .    .  .    .    .   .    .    .  			 - firstbyte, slotinfo[cnt].map->l_tls_align)
  .    .    .  .    .    .   .    .    .  		+ firstbyte;
  .    .    .  .    .    .   .    .    .  	  if (off <= freebottom)
  .    .    .  .    .    .   .    .    .  	    {
  .    .    .  .    .    .   .    .    .  	      freetop = off;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  	      /* XXX For some architectures we perhaps should store the
  .    .    .  .    .    .   .    .    .  		 negative offset.  */
  .    .    .  .    .    .   .    .    .  	      slotinfo[cnt].map->l_tls_offset = off;
  .    .    .  .    .    .   .    .    .  	      continue;
  .    .    .  .    .    .   .    .    .  	    }
  .    .    .  .    .    .   .    .    .  	}
  .    .    .  .    .    .   .    .    .  
  6    1    1  0    0    0   0    0    0        off = roundup (offset + slotinfo[cnt].map->l_tls_blocksize - firstbyte,
  .    .    .  .    .    .   .    .    .  		     slotinfo[cnt].map->l_tls_align) + firstbyte;
  3    0    0  0    0    0   0    0    0        if (off > offset + slotinfo[cnt].map->l_tls_blocksize
  1    0    0  0    0    0   0    0    0  		+ (freebottom - freetop))
  .    .    .  .    .    .   .    .    .  	{
  .    .    .  .    .    .   .    .    .  	  freetop = offset;
  1    0    0  0    0    0   0    0    0  	  freebottom = off - slotinfo[cnt].map->l_tls_blocksize;
  .    .    .  .    .    .   .    .    .  	}
  .    .    .  .    .    .   .    .    .        offset = off;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* XXX For some architectures we perhaps should store the
  .    .    .  .    .    .   .    .    .  	 negative offset.  */
  1    0    0  0    0    0   1    0    0        slotinfo[cnt].map->l_tls_offset = off;
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  1    1    1  0    0    0   1    0    0    GL(dl_tls_static_used) = offset;
  1    0    0  0    0    0   1    0    0    GL(dl_tls_static_size) = (roundup (offset + TLS_STATIC_SURPLUS, max_align)
  .    .    .  .    .    .   .    .    .  			    + TLS_TCB_SIZE);
  .    .    .  .    .    .   .    .    .  #elif TLS_DTV_AT_TP
  .    .    .  .    .    .   .    .    .    /* The TLS blocks start right after the TCB.  */
  .    .    .  .    .    .   .    .    .    size_t offset = TLS_TCB_SIZE;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    for (size_t cnt = 0; slotinfo[cnt].map != NULL; ++cnt)
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        assert (cnt < GL(dl_tls_dtv_slotinfo_list)->len);
-- line 227 ----------------------------------------
-- line 262 ----------------------------------------
  .    .    .  .    .    .   .    .    .    GL(dl_tls_static_used) = offset;
  .    .    .  .    .    .   .    .    .    GL(dl_tls_static_size) = roundup (offset + TLS_STATIC_SURPLUS,
  .    .    .  .    .    .   .    .    .  				    TLS_TCB_ALIGN);
  .    .    .  .    .    .   .    .    .  #else
  .    .    .  .    .    .   .    .    .  # error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
  .    .    .  .    .    .   .    .    .  #endif
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* The alignment requirement for the static TLS block.  */
  1    0    0  0    0    0   1    0    0    GL(dl_tls_static_align) = max_align;
  8    0    0  5    0    0   0    0    0  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  /* This is called only when the data structure setup was skipped at startup,
  .    .    .  .    .    .   .    .    .     when there was no need for it then.  Now we have dynamically loaded
  .    .    .  .    .    .   .    .    .     something needing TLS, or libpthread needs it.  */
  .    .    .  .    .    .   .    .    .  int
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_tls_setup (void)
-- line 279 ----------------------------------------
-- line 308 ----------------------------------------
  .    .    .  .    .    .   .    .    .  allocate_dtv (void *result)
  .    .    .  .    .    .   .    .    .  {
  .    .    .  .    .    .   .    .    .    dtv_t *dtv;
  .    .    .  .    .    .   .    .    .    size_t dtv_length;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* We allocate a few more elements in the dtv than are needed for the
  .    .    .  .    .    .   .    .    .       initial set of modules.  This should avoid in most cases expansions
  .    .    .  .    .    .   .    .    .       of the dtv.  */
 18    1    1  9    0    0   0    0    0    dtv_length = GL(dl_tls_max_dtv_idx) + DTV_SURPLUS;
 27    1    1  0    0    0   9    0    0    dtv = calloc (dtv_length + 2, sizeof (dtv_t));
 18    0    0  0    0    0   0    0    0    if (dtv != NULL)
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        /* This is the initial length of the dtv.  */
  9    0    0  0    0    0   9    1    1        dtv[0].counter = dtv_length;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* The rest of the dtv (including the generation counter) is
  .    .    .  .    .    .   .    .    .  	 Initialize with zero to indicate nothing there.  */
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* Add the dtv to the thread data structures.  */
 18    0    0  0    0    0   9    0    0        INSTALL_DTV (result, dtv);
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .    else
  .    .    .  .    .    .   .    .    .      result = NULL;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    return result;
  .    .    .  .    .    .   .    .    .  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  /* Get size and alignment requirements of the static TLS block.  */
  .    .    .  .    .    .   .    .    .  void
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_get_tls_static_info (size_t *sizep, size_t *alignp)
  .    .    .  .    .    .   .    .    .  {
  2    1    1  1    0    0   1    1    1    *sizep = GL(dl_tls_static_size);
  3    0    0  2    0    0   1    0    0    *alignp = GL(dl_tls_static_align);
  .    .    .  .    .    .   .    .    .  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  void *
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_allocate_tls_storage (void)
  3    1    1  0    0    0   3    0    0  {
  .    .    .  .    .    .   .    .    .    void *result;
  1    0    0  1    0    0   0    0    0    size_t size = GL(dl_tls_static_size);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  #if TLS_DTV_AT_TP
  .    .    .  .    .    .   .    .    .    /* Memory layout is:
  .    .    .  .    .    .   .    .    .       [ TLS_PRE_TCB_SIZE ] [ TLS_TCB_SIZE ] [ TLS blocks ]
  .    .    .  .    .    .   .    .    .  			  ^ This should be returned.  */
  .    .    .  .    .    .   .    .    .    size += (TLS_PRE_TCB_SIZE + GL(dl_tls_static_align) - 1)
  .    .    .  .    .    .   .    .    .  	  & ~(GL(dl_tls_static_align) - 1);
  .    .    .  .    .    .   .    .    .  #endif
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* Allocate a correctly aligned chunk of memory.  */
  4    0    0  1    0    0   1    0    0    result = __libc_memalign (GL(dl_tls_static_align), size);
  2    0    0  0    0    0   0    0    0    if (__builtin_expect (result != NULL, 1))
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        /* Allocate the DTV.  */
  .    .    .  .    .    .   .    .    .        void *allocated = result;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  #if TLS_TCB_AT_TP
  .    .    .  .    .    .   .    .    .        /* The TCB follows the TLS blocks.  */
  1    0    0  0    0    0   0    0    0        result = (char *) result + size - TLS_TCB_SIZE;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* Clear the TCB data structure.  We can't ask the caller (i.e.
  .    .    .  .    .    .   .    .    .  	 libpthread) to do it, because we will initialize the DTV et al.  */
306    1    1  0    0    0 288   36   36        memset (result, '\0', TLS_TCB_SIZE);
  .    .    .  .    .    .   .    .    .  #elif TLS_DTV_AT_TP
  .    .    .  .    .    .   .    .    .        result = (char *) result + size - GL(dl_tls_static_size);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* Clear the TCB data structure and TLS_PRE_TCB_SIZE bytes before it.
  .    .    .  .    .    .   .    .    .  	 We can't ask the caller (i.e. libpthread) to do it, because we will
  .    .    .  .    .    .   .    .    .  	 initialize the DTV et al.  */
  .    .    .  .    .    .   .    .    .        memset ((char *) result - TLS_PRE_TCB_SIZE, '\0',
  .    .    .  .    .    .   .    .    .  	      TLS_PRE_TCB_SIZE + TLS_TCB_SIZE);
-- line 382 ----------------------------------------
-- line 383 ----------------------------------------
  .    .    .  .    .    .   .    .    .  #endif
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        result = allocate_dtv (result);
  .    .    .  .    .    .   .    .    .        if (result == NULL)
  .    .    .  .    .    .   .    .    .  	free (allocated);
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    return result;
  5    0    0  4    0    0   0    0    0  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  static dtv_t *
  .    .    .  .    .    .   .    .    .  _dl_resize_dtv (dtv_t *dtv)
  .    .    .  .    .    .   .    .    .  {
  .    .    .  .    .    .   .    .    .    /* Resize the dtv.  */
  .    .    .  .    .    .   .    .    .    dtv_t *newp;
  .    .    .  .    .    .   .    .    .    /* Load GL(dl_tls_max_dtv_idx) atomically since it may be written to by
  .    .    .  .    .    .   .    .    .       other threads concurrently. -- We don't have the required atomic
-- line 399 ----------------------------------------
-- line 435 ----------------------------------------
  .    .    .  .    .    .   .    .    .    /* Return the generation counter.  */
  .    .    .  .    .    .   .    .    .    return &newp[1];
  .    .    .  .    .    .   .    .    .  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  void *
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_allocate_tls_init (void *result)
 72    1    1  0    0    0  63    0    0  {
 18    0    0  0    0    0   0    0    0    if (result == NULL)
  .    .    .  .    .    .   .    .    .      /* The memory allocation failed.  */
  .    .    .  .    .    .   .    .    .      return NULL;
  .    .    .  .    .    .   .    .    .  
 27    1    1  9    1    0   9    0    0    dtv_t *dtv = GET_DTV (result);
  .    .    .  .    .    .   .    .    .    struct dtv_slotinfo_list *listp;
 18    0    0  0    0    0   0    0    0    size_t total = 0;
  9    0    0  0    0    0   0    0    0    size_t maxgen = 0;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* Check if the current dtv is big enough.   */
 36    0    0 18    1    0   0    0    0    if (dtv[-1].counter < GL(dl_tls_max_dtv_idx))
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        /* Resize the dtv.  */
  .    .    .  .    .    .   .    .    .        dtv = _dl_resize_dtv (dtv);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        /* Install this new dtv in the thread data structures.  */
  .    .    .  .    .    .   .    .    .        INSTALL_DTV (result, &dtv[-1]);
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* We have to prepare the dtv for all currently loaded modules using
  .    .    .  .    .    .   .    .    .       TLS.  For those which are dynamically loaded we add the values
  .    .    .  .    .    .   .    .    .       indicating deferred allocation.  */
  9    0    0  9    0    0   0    0    0    listp = GL(dl_tls_dtv_slotinfo_list);
  .    .    .  .    .    .   .    .    .    while (1)
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        size_t cnt;
  .    .    .  .    .    .   .    .    .  
 81    0    0  9    1    0   0    0    0        for (cnt = total == 0 ? 1 : 0; cnt < listp->len; ++cnt)
  .    .    .  .    .    .   .    .    .  	{
  .    .    .  .    .    .   .    .    .  	  struct link_map *map;
  .    .    .  .    .    .   .    .    .  	  void *dest;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  	  /* Check for the total number of used slots.  */
108    1    1  0    0    0   0    0    0  	  if (total + cnt > GL(dl_tls_max_dtv_idx))
  .    .    .  .    .    .   .    .    .  	    break;
  .    .    .  .    .    .   .    .    .  
  9    0    0  9    2    0   0    0    0  	  map = listp->slotinfo[cnt].map;
 18    0    0  0    0    0   0    0    0  	  if (map == NULL)
  .    .    .  .    .    .   .    .    .  	    /* Unused entry.  */
  .    .    .  .    .    .   .    .    .  	    continue;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  	  /* Keep track of the maximum generation number.  This might
  .    .    .  .    .    .   .    .    .  	     not be the generation counter.  */
  .    .    .  .    .    .   .    .    .  	  assert (listp->slotinfo[cnt].gen <= GL(dl_tls_generation));
 27    0    0  9    0    0   0    0    0  	  maxgen = MAX (maxgen, listp->slotinfo[cnt].gen);
  .    .    .  .    .    .   .    .    .  
 36    1    1 18    1    0   9    0    0  	  dtv[map->l_tls_modid].pointer.val = TLS_DTV_UNALLOCATED;
  9    0    0  0    0    0   9    0    0  	  dtv[map->l_tls_modid].pointer.is_static = false;
  .    .    .  .    .    .   .    .    .  
 18    0    0  0    0    0   0    0    0  	  if (map->l_tls_offset == NO_TLS_OFFSET
 18    0    0  9    0    0   0    0    0  	      || map->l_tls_offset == FORCED_DYNAMIC_TLS_OFFSET)
  .    .    .  .    .    .   .    .    .  	    continue;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  	  assert (map->l_tls_modid == total + cnt);
  .    .    .  .    .    .   .    .    .  	  assert (map->l_tls_blocksize >= map->l_tls_initimage_size);
  .    .    .  .    .    .   .    .    .  #if TLS_TCB_AT_TP
  .    .    .  .    .    .   .    .    .  	  assert ((size_t) map->l_tls_offset >= map->l_tls_blocksize);
 18    0    0  9    0    0   0    0    0  	  dest = (char *) result - map->l_tls_offset;
  .    .    .  .    .    .   .    .    .  #elif TLS_DTV_AT_TP
  .    .    .  .    .    .   .    .    .  	  dest = (char *) result + map->l_tls_offset;
  .    .    .  .    .    .   .    .    .  #else
  .    .    .  .    .    .   .    .    .  # error "Either TLS_TCB_AT_TP or TLS_DTV_AT_TP must be defined"
  .    .    .  .    .    .   .    .    .  #endif
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  	  /* Copy the initialization image and clear the BSS part.  */
 90    1    1 36    0    0  18    0    0  	  memset (__mempcpy (dest, map->l_tls_initimage,
  .    .    .  .    .    .   .    .    .  			     map->l_tls_initimage_size), '\0',
  9    0    0  9    1    0   0    0    0  		  map->l_tls_blocksize - map->l_tls_initimage_size);
  .    .    .  .    .    .   .    .    .  	}
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        total += cnt;
  .    .    .  .    .    .   .    .    .        if (total >= GL(dl_tls_max_dtv_idx))
  .    .    .  .    .    .   .    .    .  	break;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        listp = listp->next;
  .    .    .  .    .    .   .    .    .        assert (listp != NULL);
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* The DTV version is up-to-date now.  */
 18    1    1  9    0    0   9    0    0    dtv[0].counter = maxgen;
  .    .    .  .    .    .   .    .    .  
  9    0    0  9    0    0   0    0    0    return result;
 72    0    0 63    0    0   0    0    0  }
  .    .    .  .    .    .   .    .    .  rtld_hidden_def (_dl_allocate_tls_init)
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  void *
  .    .    .  .    .    .   .    .    .  internal_function
  .    .    .  .    .    .   .    .    .  _dl_allocate_tls (void *mem)
 32    1    1  0    0    0  24    0    0  {
 32    0    0  0    0    0   0    0    0    return _dl_allocate_tls_init (mem == NULL
  .    .    .  .    .    .   .    .    .  				? _dl_allocate_tls_storage ()
  .    .    .  .    .    .   .    .    .  				: allocate_dtv (mem));
 24    0    0 24    0    0   0    0    0  }
  .    .    .  .    .    .   .    .    .  rtld_hidden_def (_dl_allocate_tls)
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  #ifndef SHARED
  .    .    .  .    .    .   .    .    .  extern dtv_t _dl_static_dtv[];
  .    .    .  .    .    .   .    .    .  # define _dl_initial_dtv (&_dl_static_dtv[1])
  .    .    .  .    .    .   .    .    .  #endif
  .    .    .  .    .    .   .    .    .  
-- line 544 ----------------------------------------
-- line 871 ----------------------------------------
  .    .    .  .    .    .   .    .    .      data = NULL;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    return data;
  .    .    .  .    .    .   .    .    .  }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .  void
  .    .    .  .    .    .   .    .    .  _dl_add_to_slotinfo (struct link_map *l)
  6    1    1  0    0    0   4    0    0  {
  .    .    .  .    .    .   .    .    .    /* Now that we know the object is loaded successfully add
  .    .    .  .    .    .   .    .    .       modules containing TLS data to the dtv info table.  We
  .    .    .  .    .    .   .    .    .       might have to increase its size.  */
  .    .    .  .    .    .   .    .    .    struct dtv_slotinfo_list *listp;
  .    .    .  .    .    .   .    .    .    struct dtv_slotinfo_list *prevp;
  1    1    1  1    0    0   0    0    0    size_t idx = l->l_tls_modid;
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* Find the place in the dtv slotinfo list.  */
  2    0    0  1    1    0   0    0    0    listp = GL(dl_tls_dtv_slotinfo_list);
  .    .    .  .    .    .   .    .    .    prevp = NULL;		/* Needed to shut up gcc.  */
  .    .    .  .    .    .   .    .    .    do
  .    .    .  .    .    .   .    .    .      {
  .    .    .  .    .    .   .    .    .        /* Does it fit in the array of this list element?  */
  5    0    0  1    0    0   0    0    0        if (idx < listp->len)
  .    .    .  .    .    .   .    .    .  	break;
  .    .    .  .    .    .   .    .    .        idx -= listp->len;
  .    .    .  .    .    .   .    .    .        prevp = listp;
  .    .    .  .    .    .   .    .    .        listp = listp->next;
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .    while (listp != NULL);
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    if (listp == NULL)
-- line 901 ----------------------------------------
-- line 926 ----------------------------------------
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .        listp->len = TLS_SLOTINFO_SURPLUS;
  .    .    .  .    .    .   .    .    .        listp->next = NULL;
  .    .    .  .    .    .   .    .    .        memset (listp->slotinfo, '\0',
  .    .    .  .    .    .   .    .    .  	      TLS_SLOTINFO_SURPLUS * sizeof (struct dtv_slotinfo));
  .    .    .  .    .    .   .    .    .      }
  .    .    .  .    .    .   .    .    .  
  .    .    .  .    .    .   .    .    .    /* Add the information into the slotinfo data structure.  */
  1    0    0  0    0    0   1    1    0    listp->slotinfo[idx].map = l;
  3    1    1  1    1    0   1    0    0    listp->slotinfo[idx].gen = GL(dl_tls_generation) + 1;
  6    0    0  5    0    0   0    0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/malloc/arena.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 323 ----------------------------------------
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static char *
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  next_env_entry (char ***position)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    char **current = *position;
  .    .    .  .    .    .  .    .    .    char *result = NULL;
  .    .    .  .    .    .  .    .    .  
138    0    0 46    7    0  0    0    0    while (*current != NULL)
  .    .    .  .    .    .  .    .    .      {
 90    0    0 45   27    0  0    0    0        if (__builtin_expect ((*current)[0] == 'M', 0)
 12    0    0  6    1    0  0    0    0  	  && (*current)[1] == 'A'
  4    0    0  2    0    0  0    0    0  	  && (*current)[2] == 'L'
  .    .    .  .    .    .  .    .    .  	  && (*current)[3] == 'L'
  .    .    .  .    .    .  .    .    .  	  && (*current)[4] == 'O'
  .    .    .  .    .    .  .    .    .  	  && (*current)[5] == 'C'
  .    .    .  .    .    .  .    .    .  	  && (*current)[6] == '_')
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  result = &(*current)[7];
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* Save current position for next visit.  */
  .    .    .  .    .    .  .    .    .  	  *position = ++current;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  break;
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .  
 45    0    0  0    0    0  0    0    0        ++current;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return result;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .  static void *
-- line 357 ----------------------------------------
-- line 360 ----------------------------------------
  .    .    .  .    .    .  .    .    .    return (void *) MORECORE_FAILURE;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  extern struct dl_open_hook *_dl_open_hook;
  .    .    .  .    .    .  .    .    .  libc_hidden_proto (_dl_open_hook);
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static void
  6    1    1  0    0    0  5    0    0  ptmalloc_init (void)
  .    .    .  .    .    .  .    .    .  {
  3    1    1  1    1    1  0    0    0    if(__malloc_initialized >= 0) return;
  1    0    0  0    0    0  1    0    0    __malloc_initialized = 0;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #ifdef SHARED
  .    .    .  .    .    .  .    .    .    /* In case this libc copy is in a non-default namespace, never use brk.
  .    .    .  .    .    .  .    .    .       Likewise if dlopened from statically linked program.  */
  .    .    .  .    .    .  .    .    .    Dl_info di;
  .    .    .  .    .    .  .    .    .    struct link_map *l;
  .    .    .  .    .    .  .    .    .  
  2    1    1  1    0    0  0    0    0    if (_dl_open_hook != NULL
  7    2    2  0    0    0  1    0    0        || (_dl_addr (ptmalloc_init, &di, &l, NULL) != 0
  4    0    0  2    1    0  0    0    0  	  && l->l_ns != LM_ID_BASE))
  .    .    .  .    .    .  .    .    .      __morecore = __failing_morecore;
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    tsd_key_create(&arena_key, NULL);
  3    0    0  1    1    0  1    1    0    tsd_setspecific(arena_key, (void *)&main_arena);
  .    .    .  .    .    .  .    .    .    const char *s = NULL;
  5    0    0  2    1    0  0    0    0    if (__builtin_expect (_environ != NULL, 1))
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        char **runp = _environ;
  .    .    .  .    .    .  .    .    .        char *envline;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .        while (__builtin_expect ((envline = next_env_entry (&runp)) != NULL,
  .    .    .  .    .    .  .    .    .  			       0))
  .    .    .  .    .    .  .    .    .  	{
  .    .    .  .    .    .  .    .    .  	  size_t len = strcspn (envline, "=");
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  if (envline[len] != '=')
  .    .    .  .    .    .  .    .    .  	    /* This is a "MALLOC_" variable at the end of the string
  .    .    .  .    .    .  .    .    .  	       without a '=' character.  Ignore it since otherwise we
  .    .    .  .    .    .  .    .    .  	       will access invalid memory below.  */
  .    .    .  .    .    .  .    .    .  	    continue;
  .    .    .  .    .    .  .    .    .  
  2    1    1  0    0    0  0    0    0  	  switch (len)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	    case 6:
  .    .    .  .    .    .  .    .    .  	      if (memcmp (envline, "CHECK_", 6) == 0)
  .    .    .  .    .    .  .    .    .  		s = &envline[7];
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    case 8:
  .    .    .  .    .    .  .    .    .  	      if (! __builtin_expect (__libc_enable_secure, 0))
  .    .    .  .    .    .  .    .    .  		{
-- line 412 ----------------------------------------
-- line 441 ----------------------------------------
  .    .    .  .    .    .  .    .    .  		    __libc_mallopt(M_MMAP_THRESHOLD, atoi(&envline[16]));
  .    .    .  .    .    .  .    .    .  		}
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    default:
  .    .    .  .    .    .  .    .    .  	      break;
  .    .    .  .    .    .  .    .    .  	    }
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  2    0    0  0    0    0  0    0    0    if(s && s[0]) {
  .    .    .  .    .    .  .    .    .      __libc_mallopt(M_CHECK_ACTION, (int)(s[0] - '0'));
  .    .    .  .    .    .  .    .    .      if (check_action != 0)
  .    .    .  .    .    .  .    .    .        __malloc_check_init();
  .    .    .  .    .    .  .    .    .    }
  2    0    0  2    2    1  0    0    0    void (*hook) (void) = force_reg (__malloc_initialize_hook);
  2    0    0  0    0    0  0    0    0    if (hook != NULL)
  .    .    .  .    .    .  .    .    .      (*hook)();
  1    0    0  0    0    0  1    1    0    __malloc_initialized = 1;
  7    0    0  6    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Managing heaps and arenas (for concurrent threads) */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  #if MALLOC_DEBUG > 1
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Print the complete contents of a single heap to stderr. */
-- line 466 ----------------------------------------
-- line 503 ----------------------------------------
  .    .    .  .    .    .  .    .    .  static char *aligned_heap_area;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Create a new heap.  size is automatically rounded up to a multiple
  .    .    .  .    .    .  .    .    .     of the page size. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static heap_info *
  .    .    .  .    .    .  .    .    .  internal_function
  .    .    .  .    .    .  .    .    .  new_heap(size_t size, size_t top_pad)
 18    0    0  0    0    0 18    0    0  {
 18    1    1 12    0    0  0    0    0    size_t page_mask = GLRO(dl_pagesize) - 1;
  .    .    .  .    .    .  .    .    .    char *p1, *p2;
  .    .    .  .    .    .  .    .    .    unsigned long ul;
  .    .    .  .    .    .  .    .    .    heap_info *h;
  .    .    .  .    .    .  .    .    .  
 18    0    0  0    0    0  0    0    0    if(size+top_pad < HEAP_MIN_SIZE)
  .    .    .  .    .    .  .    .    .      size = HEAP_MIN_SIZE;
 12    0    0  0    0    0  0    0    0    else if(size+top_pad <= HEAP_MAX_SIZE)
  .    .    .  .    .    .  .    .    .      size += top_pad;
  .    .    .  .    .    .  .    .    .    else if(size > HEAP_MAX_SIZE)
  .    .    .  .    .    .  .    .    .      return 0;
  .    .    .  .    .    .  .    .    .    else
  .    .    .  .    .    .  .    .    .      size = HEAP_MAX_SIZE;
 18    1    1  0    0    0  0    0    0    size = (size + page_mask) & ~page_mask;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* A memory region aligned to a multiple of HEAP_MAX_SIZE is needed.
  .    .    .  .    .    .  .    .    .       No swap space needs to be reserved for the following large
  .    .    .  .    .    .  .    .    .       mapping (on Linux, this is the case for all non-writable mappings
  .    .    .  .    .    .  .    .    .       anyway). */
  .    .    .  .    .    .  .    .    .    p2 = MAP_FAILED;
 18    0    0  6    1    1  0    0    0    if(aligned_heap_area) {
 14    0    0  0    0    0  2    2    2      p2 = (char *)MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,
  .    .    .  .    .    .  .    .    .  		      MAP_NORESERVE);
  2    0    0  0    0    0  2    0    0      aligned_heap_area = NULL;
  8    0    0  0    0    0  0    0    0      if (p2 != MAP_FAILED && ((unsigned long)p2 & (HEAP_MAX_SIZE-1))) {
  .    .    .  .    .    .  .    .    .        __munmap(p2, HEAP_MAX_SIZE);
  .    .    .  .    .    .  .    .    .        p2 = MAP_FAILED;
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    }
  .    .    .  .    .    .  .    .    .    if(p2 == MAP_FAILED) {
 28    2    2  0    0    0  4    3    3      p1 = (char *)MMAP(0, HEAP_MAX_SIZE<<1, PROT_NONE, MAP_NORESERVE);
  8    0    0  0    0    0  0    0    0      if(p1 != MAP_FAILED) {
  8    0    0  0    0    0  0    0    0        p2 = (char *)(((unsigned long)p1 + (HEAP_MAX_SIZE-1))
  .    .    .  .    .    .  .    .    .  		    & ~(HEAP_MAX_SIZE-1));
  .    .    .  .    .    .  .    .    .        ul = p2 - p1;
 12    0    0  0    0    0  0    0    0        if (ul)
  5    1    1  0    0    0  1    0    0  	__munmap(p1, ul);
  .    .    .  .    .    .  .    .    .        else
  6    0    0  0    0    0  3    0    0  	aligned_heap_area = p2 + HEAP_MAX_SIZE;
 16    1    1  0    0    0  4    0    0        __munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);
  .    .    .  .    .    .  .    .    .      } else {
  .    .    .  .    .    .  .    .    .        /* Try to take the chance that an allocation of only HEAP_MAX_SIZE
  .    .    .  .    .    .  .    .    .  	 is already aligned. */
  .    .    .  .    .    .  .    .    .        p2 = (char *)MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);
  .    .    .  .    .    .  .    .    .        if(p2 == MAP_FAILED)
  .    .    .  .    .    .  .    .    .  	return 0;
  .    .    .  .    .    .  .    .    .        if((unsigned long)p2 & (HEAP_MAX_SIZE-1)) {
  .    .    .  .    .    .  .    .    .  	__munmap(p2, HEAP_MAX_SIZE);
  .    .    .  .    .    .  .    .    .  	return 0;
  .    .    .  .    .    .  .    .    .        }
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    }
 36    0    0  0    0    0  6    0    0    if(__mprotect(p2, size, PROT_READ|PROT_WRITE) != 0) {
  .    .    .  .    .    .  .    .    .      __munmap(p2, HEAP_MAX_SIZE);
  .    .    .  .    .    .  .    .    .      return 0;
  .    .    .  .    .    .  .    .    .    }
  .    .    .  .    .    .  .    .    .    h = (heap_info *)p2;
  6    0    0  0    0    0  6    6    6    h->size = size;
  6    0    0  0    0    0  6    0    0    h->mprotect_size = size;
  6    0    0  0    0    0  0    0    0    LIBC_PROBE (memory_heap_new, 2, h, h->size);
  6    0    0  0    0    0  0    0    0    return h;
 24    0    0 24    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Grow a heap.  size is automatically rounded up to a
  .    .    .  .    .    .  .    .    .     multiple of the page size. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static int
  .    .    .  .    .    .  .    .    .  grow_heap(heap_info *h, long diff)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    size_t page_mask = GLRO(dl_pagesize) - 1;
-- line 581 ----------------------------------------
-- line 707 ----------------------------------------
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* If REPLACED_ARENA is not NULL, detach it from this thread.  Must be
  .    .    .  .    .    .  .    .    .     called while free_list_lock is held.  */
  .    .    .  .    .    .  .    .    .  static void
  .    .    .  .    .    .  .    .    .  detach_arena (mstate replaced_arena)
  .    .    .  .    .    .  .    .    .  {
 14    0    0  0    0    0  0    0    0    if (replaced_arena != NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        assert (replaced_arena->attached_threads > 0);
  .    .    .  .    .    .  .    .    .        /* The current implementation only detaches from main_arena in
  .    .    .  .    .    .  .    .    .  	 case of allocation failure.  This means that it is likely not
  .    .    .  .    .    .  .    .    .  	 beneficial to put the arena on free_list even if the
  .    .    .  .    .    .  .    .    .  	 reference count reaches zero.  */
  .    .    .  .    .    .  .    .    .        --replaced_arena->attached_threads;
  .    .    .  .    .    .  .    .    .      }
-- line 723 ----------------------------------------
-- line 728 ----------------------------------------
  .    .    .  .    .    .  .    .    .  static mstate
  .    .    .  .    .    .  .    .    .  _int_new_arena(size_t size)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    mstate a;
  .    .    .  .    .    .  .    .    .    heap_info *h;
  .    .    .  .    .    .  .    .    .    char *ptr;
  .    .    .  .    .    .  .    .    .    unsigned long misalign;
  .    .    .  .    .    .  .    .    .  
 24    1    1  6    0    0  6    0    0    h = new_heap(size + (sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT),
  .    .    .  .    .    .  .    .    .  	       mp_.top_pad);
 12    0    0  0    0    0  0    0    0    if(!h) {
  .    .    .  .    .    .  .    .    .      /* Maybe size is too large to fit in a single heap.  So, just try
  .    .    .  .    .    .  .    .    .         to create a minimally-sized arena and let _int_malloc() attempt
  .    .    .  .    .    .  .    .    .         to deal with the large request via mmap_chunk().  */
  .    .    .  .    .    .  .    .    .      h = new_heap(sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT, mp_.top_pad);
  .    .    .  .    .    .  .    .    .      if(!h)
  .    .    .  .    .    .  .    .    .        return 0;
  .    .    .  .    .    .  .    .    .    }
 24    0    0  0    0    0  6    0    0    a = h->ar_ptr = (mstate)(h+1);
  .    .    .  .    .    .  .    .    .    malloc_init_state(a);
  6    0    0  0    0    0  6    6    6    a->attached_threads = 1;
  .    .    .  .    .    .  .    .    .    /*a->next = NULL;*/
 18    1    1  6    0    0 12    0    0    a->system_mem = a->max_system_mem = h->size;
  6    0    0  6    1    1  0    0    0    arena_mem += h->size;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Set up the top chunk, with proper alignment. */
  6    0    0  0    0    0  0    0    0    ptr = (char *)(a + 1);
  .    .    .  .    .    .  .    .    .    misalign = (unsigned long)chunk2mem(ptr) & MALLOC_ALIGN_MASK;
 18    0    0  0    0    0  0    0    0    if (misalign > 0)
  .    .    .  .    .    .  .    .    .      ptr += MALLOC_ALIGNMENT - misalign;
  6    0    0  0    0    0  6    6    6    top(a) = (mchunkptr)ptr;
 24    0    0  0    0    0  6    0    0    set_head(top(a), (((char*)h + h->size) - ptr) | PREV_INUSE);
  .    .    .  .    .    .  .    .    .  
  6    0    0  0    0    0  0    0    0    LIBC_PROBE (memory_arena_new, 2, a, size);
  .    .    .  .    .    .  .    .    .    mstate replaced_arena;
  .    .    .  .    .    .  .    .    .    {
  .    .    .  .    .    .  .    .    .      void *vptr = NULL;
  6    0    0  6    0    0  0    0    0      replaced_arena = tsd_getspecific (arena_key, vptr);
  .    .    .  .    .    .  .    .    .    }
  6    0    0  0    0    0  6    0    0    tsd_setspecific(arena_key, (void *)a);
  6    0    0  0    0    0  6    0    0    mutex_init(&a->mutex);
  .    .    .  .    .    .  .    .    .  
 54    1    1 12    0    0  0    0    0    (void)mutex_lock(&list_lock);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Add the new arena to the global list.  */
 12    0    0  6    0    0  6    0    0    a->next = main_arena.next;
  .    .    .  .    .    .  .    .    .    /* FIXME: The barrier is an attempt to synchronize with read access
  .    .    .  .    .    .  .    .    .       in reused_arena, which does not acquire list_lock while
  .    .    .  .    .    .  .    .    .       traversing the list.  */
  .    .    .  .    .    .  .    .    .    atomic_write_barrier ();
  6    0    0  0    0    0  6    0    0    main_arena.next = a;
  .    .    .  .    .    .  .    .    .  
 30    1    1 18    0    0  0    0    0    (void)mutex_unlock(&list_lock);
  .    .    .  .    .    .  .    .    .  
 42    1    1 12    0    0  0    0    0    (void) mutex_lock (&free_list_lock);
  .    .    .  .    .    .  .    .    .    detach_arena (replaced_arena);
 30    0    0 18    0    0  0    0    0    (void) mutex_unlock (&free_list_lock);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    /* Lock this arena.  NB: Another thread may have been attached to
  .    .    .  .    .    .  .    .    .       this arena because the arena is now accessible from the
  .    .    .  .    .    .  .    .    .       main_arena.next list and could have been picked by reused_arena.
  .    .    .  .    .    .  .    .    .       This can only happen for the last arena created (before the arena
  .    .    .  .    .    .  .    .    .       limit is reached).  At this point, some arena has to be attached
  .    .    .  .    .    .  .    .    .       to two threads.  We could acquire the arena lock before list_lock
  .    .    .  .    .    .  .    .    .       to make it less likely that reused_arena picks this new arena,
  .    .    .  .    .    .  .    .    .       but this could result in a deadlock with
  .    .    .  .    .    .  .    .    .       __malloc_fork_lock_parent.  */
  .    .    .  .    .    .  .    .    .  
 42    1    1 12    0    0  0    0    0    (void) mutex_lock (&a->mutex);
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return a;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Remove an arena from free_list.  */
  .    .    .  .    .    .  .    .    .  static mstate
  .    .    .  .    .    .  .    .    .  get_free_list (void)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    void *vptr = NULL;
 14    0    0 14    0    0  0    0    0    mstate replaced_arena = tsd_getspecific (arena_key, vptr);
  .    .    .  .    .    .  .    .    .    mstate result = free_list;
 14    0    0  7    0    0  0    0    0    if (result != NULL)
  .    .    .  .    .    .  .    .    .      {
  7    0    0  2    0    0  0    0    0        (void)mutex_lock(&free_list_lock);
  1    1    1  1    0    0  0    0    0        result = free_list;
  2    0    0  0    0    0  0    0    0        if (result != NULL)
  .    .    .  .    .    .  .    .    .  	{
  2    0    0  1    0    0  1    0    0  	  free_list = result->next_free;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  /* The arena will be attached to this thread.  */
  .    .    .  .    .    .  .    .    .  	  assert (result->attached_threads == 0);
  1    0    0  0    0    0  1    0    0  	  result->attached_threads = 1;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	  detach_arena (replaced_arena);
  .    .    .  .    .    .  .    .    .  	}
  5    1    1  3    0    0  0    0    0        (void)mutex_unlock(&free_list_lock);
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0        if (result != NULL)
  .    .    .  .    .    .  .    .    .  	{
  1    0    0  0    0    0  0    0    0  	  LIBC_PROBE (memory_arena_reuse_free_list, 1, result);
  7    0    0  2    0    0  0    0    0  	  (void)mutex_lock(&result->mutex);
  1    0    0  0    0    0  1    0    0  	  tsd_setspecific(arena_key, (void *)result);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return result;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Remove the arena from the free list (if it is present).
  .    .    .  .    .    .  .    .    .     free_list_lock must have been acquired by the caller.  */
-- line 836 ----------------------------------------
-- line 924 ----------------------------------------
  .    .    .  .    .    .  .    .    .    tsd_setspecific(arena_key, (void *)result);
  .    .    .  .    .    .  .    .    .    next_to_use = result->next;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    return result;
  .    .    .  .    .    .  .    .    .  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  static mstate
  .    .    .  .    .    .  .    .    .  internal_function
 35    2    2  0    0    0 21    0    0  arena_get2(mstate a_tsd, size_t size, mstate avoid_arena)
  .    .    .  .    .    .  .    .    .  {
  .    .    .  .    .    .  .    .    .    mstate a;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    static size_t narenas_limit;
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .    a = get_free_list ();
  .    .    .  .    .    .  .    .    .    if (a == NULL)
  .    .    .  .    .    .  .    .    .      {
  .    .    .  .    .    .  .    .    .        /* Nothing immediately available, so generate a new arena.  */
 18    1    1  6    0    0  0    0    0        if (narenas_limit == 0)
  .    .    .  .    .    .  .    .    .  	{
 18    0    0  6    0    0  0    0    0  	  if (mp_.arena_max != 0)
  .    .    .  .    .    .  .    .    .  	    narenas_limit = mp_.arena_max;
 30    1    1 12    0    0  0    0    0  	  else if (narenas > mp_.arena_test)
  .    .    .  .    .    .  .    .    .  	    {
  .    .    .  .    .    .  .    .    .  	      int n  = __get_nprocs ();
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	      if (n >= 1)
  .    .    .  .    .    .  .    .    .  		narenas_limit = NARENAS_FROM_NCORES (n);
  .    .    .  .    .    .  .    .    .  	      else
  .    .    .  .    .    .  .    .    .  		/* We have no information about the system.  Assume two
  .    .    .  .    .    .  .    .    .  		   cores.  */
-- line 954 ----------------------------------------
-- line 959 ----------------------------------------
  .    .    .  .    .    .  .    .    .        size_t n = narenas;
  .    .    .  .    .    .  .    .    .        /* NB: the following depends on the fact that (size_t)0 - 1 is a
  .    .    .  .    .    .  .    .    .  	 very large number and that the underflow is OK.  If arena_max
  .    .    .  .    .    .  .    .    .  	 is set the value of arena_test is irrelevant.  If arena_test
  .    .    .  .    .    .  .    .    .  	 is set but narenas is not yet larger or equal to arena_test
  .    .    .  .    .    .  .    .    .  	 narenas_limit is 0.  There is no possibility for narenas to
  .    .    .  .    .    .  .    .    .  	 be too big for the test to always fail since there is not
  .    .    .  .    .    .  .    .    .  	 enough address space to create that many arenas.  */
 18    0    0  0    0    0  0    0    0        if (__builtin_expect (n <= narenas_limit - 1, 0))
  .    .    .  .    .    .  .    .    .  	{
 42    1    1 12    0    0  0    0    0  	  if (catomic_compare_and_exchange_bool_acq (&narenas, n + 1, n))
  .    .    .  .    .    .  .    .    .  	    goto repeat;
  .    .    .  .    .    .  .    .    .  	  a = _int_new_arena (size);
 12    0    0  0    0    0  0    0    0  	  if (__builtin_expect (a == NULL, 0))
  .    .    .  .    .    .  .    .    .  	    catomic_decrement (&narenas);
  .    .    .  .    .    .  .    .    .  	}
  .    .    .  .    .    .  .    .    .        else
  .    .    .  .    .    .  .    .    .  	a = reused_arena (avoid_arena);
  .    .    .  .    .    .  .    .    .      }
  .    .    .  .    .    .  .    .    .    return a;
 35    0    0 28    0    0  0    0    0  }
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* If we don't have the main arena, then maybe the failure is due to running
  .    .    .  .    .    .  .    .    .     out of mmapped areas, so we can try allocating on the main arena.
  .    .    .  .    .    .  .    .    .     Otherwise, it is likely that sbrk() has failed and there is still a chance
  .    .    .  .    .    .  .    .    .     to mmap(), so try one of the other arenas.  */
  .    .    .  .    .    .  .    .    .  static mstate
  .    .    .  .    .    .  .    .    .  arena_get_retry (mstate ar_ptr, size_t bytes)
  .    .    .  .    .    .  .    .    .  {
-- line 987 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/string/../string/memcmp.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 100 ----------------------------------------
  .    .    .   .    .    .   .    .    .  memcmp_bytes (op_t a, op_t b)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    long int srcp1 = (long int) &a;
  .    .    .   .    .    .   .    .    .    long int srcp2 = (long int) &b;
  .    .    .   .    .    .   .    .    .    op_t a0, b0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    do
  .    .    .   .    .    .   .    .    .      {
 15    1    1  15    0    0   0    0    0        a0 = ((byte *) srcp1)[0];
 30    0    0  15    0    0   0    0    0        b0 = ((byte *) srcp2)[0];
  .    .    .   .    .    .   .    .    .        srcp1 += 1;
  .    .    .   .    .    .   .    .    .        srcp2 += 1;
  .    .    .   .    .    .   .    .    .      }
 33    0    0   0    0    0   0    0    0    while (a0 == b0);
  9    1    1   0    0    0   0    0    0    return a0 - b0;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int memcmp_common_alignment (long, long, size_t) __THROW;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* memcmp_common_alignment -- Compare blocks at SRCP1 and SRCP2 with LEN `op_t'
  .    .    .   .    .    .   .    .    .     objects (not LEN bytes!).  Both SRCP1 and SRCP2 should be aligned for
  .    .    .   .    .    .   .    .    .     memory operations on `op_t's.  */
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  memcmp_common_alignment (long int srcp1, long int srcp2, size_t len)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    op_t a0, a1;
  .    .    .   .    .    .   .    .    .    op_t b0, b1;
  .    .    .   .    .    .   .    .    .  
 21    1    1   0    0    0   0    0    0    switch (len % 4)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .      default: /* Avoid warning about uninitialized local variables.  */
  .    .    .   .    .    .   .    .    .      case 2:
  3    1    1   3    2    2   0    0    0        a0 = ((op_t *) srcp1)[0];
  3    0    0   3    0    0   0    0    0        b0 = ((op_t *) srcp2)[0];
  3    0    0   0    0    0   0    0    0        srcp1 -= 2 * OPSIZ;
  3    0    0   0    0    0   0    0    0        srcp2 -= 2 * OPSIZ;
  3    0    0   0    0    0   0    0    0        len += 2;
  .    .    .   .    .    .   .    .    .        goto do1;
  .    .    .   .    .    .   .    .    .      case 3:
  .    .    .   .    .    .   .    .    .        a1 = ((op_t *) srcp1)[0];
  .    .    .   .    .    .   .    .    .        b1 = ((op_t *) srcp2)[0];
  .    .    .   .    .    .   .    .    .        srcp1 -= OPSIZ;
  .    .    .   .    .    .   .    .    .        srcp2 -= OPSIZ;
  .    .    .   .    .    .   .    .    .        len += 1;
  .    .    .   .    .    .   .    .    .        goto do2;
-- line 145 ----------------------------------------
-- line 175 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      do2:
  .    .    .   .    .    .   .    .    .        a0 = ((op_t *) srcp1)[2];
  .    .    .   .    .    .   .    .    .        b0 = ((op_t *) srcp2)[2];
  .    .    .   .    .    .   .    .    .        if (a1 != b1)
  .    .    .   .    .    .   .    .    .  	return CMP_LT_OR_GT (a1, b1);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      do1:
  3    0    0   3    0    0   0    0    0        a1 = ((op_t *) srcp1)[3];
  3    0    0   3    0    0   0    0    0        b1 = ((op_t *) srcp2)[3];
 24    0    0   0    0    0   6    2    2        if (a0 != b0)
  .    .    .   .    .    .   .    .    .  	return CMP_LT_OR_GT (a0, b0);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        srcp1 += 4 * OPSIZ;
  .    .    .   .    .    .   .    .    .        srcp2 += 4 * OPSIZ;
  .    .    .   .    .    .   .    .    .        len -= 4;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    while (len != 0);
  .    .    .   .    .    .   .    .    .  
-- line 193 ----------------------------------------
-- line 210 ----------------------------------------
  .    .    .   .    .    .   .    .    .    op_t a0, a1, a2, a3;
  .    .    .   .    .    .   .    .    .    op_t b0, b1, b2, b3;
  .    .    .   .    .    .   .    .    .    op_t x;
  .    .    .   .    .    .   .    .    .    int shl, shr;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Calculate how to shift a word read at the memory operation
  .    .    .   .    .    .   .    .    .       aligned srcp1 to make it aligned for comparison.  */
  .    .    .   .    .    .   .    .    .  
  3    0    0   0    0    0   0    0    0    shl = 8 * (srcp1 % OPSIZ);
  6    0    0   0    0    0   0    0    0    shr = 8 * OPSIZ - shl;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Make SRCP1 aligned by rounding it down to the beginning of the `op_t'
  .    .    .   .    .    .   .    .    .       it points in the middle of.  */
  6    0    0   0    0    0   0    0    0    srcp1 &= -OPSIZ;
  .    .    .   .    .    .   .    .    .  
 18    1    1   0    0    0   0    0    0    switch (len % 4)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .      default: /* Avoid warning about uninitialized local variables.  */
  .    .    .   .    .    .   .    .    .      case 2:
  2    0    0   2    0    0   0    0    0        a1 = ((op_t *) srcp1)[0];
  2    0    0   2    1    1   0    0    0        a2 = ((op_t *) srcp1)[1];
  2    0    0   2    0    0   0    0    0        b2 = ((op_t *) srcp2)[0];
  2    0    0   0    0    0   0    0    0        srcp1 -= 1 * OPSIZ;
  2    0    0   0    0    0   0    0    0        srcp2 -= 2 * OPSIZ;
  2    0    0   0    0    0   0    0    0        len += 2;
  .    .    .   .    .    .   .    .    .        goto do1;
  .    .    .   .    .    .   .    .    .      case 3:
  .    .    .   .    .    .   .    .    .        a0 = ((op_t *) srcp1)[0];
  .    .    .   .    .    .   .    .    .        a1 = ((op_t *) srcp1)[1];
  .    .    .   .    .    .   .    .    .        b1 = ((op_t *) srcp2)[0];
  .    .    .   .    .    .   .    .    .        srcp2 -= 1 * OPSIZ;
  .    .    .   .    .    .   .    .    .        len += 1;
  .    .    .   .    .    .   .    .    .        goto do2;
-- line 242 ----------------------------------------
-- line 244 ----------------------------------------
  .    .    .   .    .    .   .    .    .        if (OP_T_THRES <= 3 * OPSIZ && len == 0)
  .    .    .   .    .    .   .    .    .  	return 0;
  .    .    .   .    .    .   .    .    .        a3 = ((op_t *) srcp1)[0];
  .    .    .   .    .    .   .    .    .        a0 = ((op_t *) srcp1)[1];
  .    .    .   .    .    .   .    .    .        b0 = ((op_t *) srcp2)[0];
  .    .    .   .    .    .   .    .    .        srcp1 += 1 * OPSIZ;
  .    .    .   .    .    .   .    .    .        goto do3;
  .    .    .   .    .    .   .    .    .      case 1:
  1    0    0   1    0    0   0    0    0        a2 = ((op_t *) srcp1)[0];
  1    1    1   1    0    0   0    0    0        a3 = ((op_t *) srcp1)[1];
  1    0    0   1    0    0   0    0    0        b3 = ((op_t *) srcp2)[0];
  .    .    .   .    .    .   .    .    .        srcp1 += 2 * OPSIZ;
  .    .    .   .    .    .   .    .    .        srcp2 += 1 * OPSIZ;
  .    .    .   .    .    .   .    .    .        len -= 1;
  2    1    1   0    0    0   0    0    0        if (OP_T_THRES <= 3 * OPSIZ && len == 0)
  .    .    .   .    .    .   .    .    .  	goto do0;
  .    .    .   .    .    .   .    .    .        /* Fall through.  */
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    do
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        a0 = ((op_t *) srcp1)[0];
  .    .    .   .    .    .   .    .    .        b0 = ((op_t *) srcp2)[0];
-- line 266 ----------------------------------------
-- line 278 ----------------------------------------
  .    .    .   .    .    .   .    .    .      do2:
  .    .    .   .    .    .   .    .    .        a2 = ((op_t *) srcp1)[2];
  .    .    .   .    .    .   .    .    .        b2 = ((op_t *) srcp2)[2];
  .    .    .   .    .    .   .    .    .        x = MERGE(a0, shl, a1, shr);
  .    .    .   .    .    .   .    .    .        if (x != b1)
  .    .    .   .    .    .   .    .    .  	return CMP_LT_OR_GT (x, b1);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .      do1:
  2    0    0   2    0    0   0    0    0        a3 = ((op_t *) srcp1)[3];
  2    0    0   2    0    0   0    0    0        b3 = ((op_t *) srcp2)[3];
 12    1    1   0    0    0   0    0    0        x = MERGE(a1, shl, a2, shr);
  4    0    0   0    0    0   0    0    0        if (x != b2)
  .    .    .   .    .    .   .    .    .  	return CMP_LT_OR_GT (x, b2);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        srcp1 += 4 * OPSIZ;
  .    .    .   .    .    .   .    .    .        srcp2 += 4 * OPSIZ;
  .    .    .   .    .    .   .    .    .        len -= 4;
  .    .    .   .    .    .   .    .    .      }
  4    1    1   0    0    0   0    0    0    while (len != 0);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* This is the right position for do0.  Please don't move
  .    .    .   .    .    .   .    .    .       it into the loop.  */
  .    .    .   .    .    .   .    .    .   do0:
 18    1    1   0    0    0   0    0    0    x = MERGE(a2, shl, a3, shr);
  6    0    0   0    0    0   0    0    0    if (x != b3)
  .    .    .   .    .    .   .    .    .      return CMP_LT_OR_GT (x, b3);
  .    .    .   .    .    .   .    .    .    return 0;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  MEMCMP (const __ptr_t s1, const __ptr_t s2, size_t len)
119    1    1   0    0    0 102    2    2  {
  .    .    .   .    .    .   .    .    .    op_t a0;
  .    .    .   .    .    .   .    .    .    op_t b0;
 17    0    0   0    0    0   0    0    0    long int srcp1 = (long int) s1;
 17    0    0   0    0    0   0    0    0    long int srcp2 = (long int) s2;
  .    .    .   .    .    .   .    .    .    op_t res;
  .    .    .   .    .    .   .    .    .  
 34    0    0   0    0    0   0    0    0    if (len >= OP_T_THRES)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* There are at least some bytes to compare.  No need to test
  .    .    .   .    .    .   .    .    .  	 for LEN == 0 in this alignment loop.  */
 33    0    0   0    0    0   0    0    0        while (srcp2 % OPSIZ != 0)
  .    .    .   .    .    .   .    .    .  	{
  5    0    0   5    1    1   0    0    0  	  a0 = ((byte *) srcp1)[0];
  5    0    0   5    0    0   0    0    0  	  b0 = ((byte *) srcp2)[0];
  5    0    0   0    0    0   0    0    0  	  srcp1 += 1;
  5    0    0   0    0    0   0    0    0  	  srcp2 += 1;
  .    .    .   .    .    .   .    .    .  	  res = a0 - b0;
 10    0    0   0    0    0   0    0    0  	  if (res != 0)
  .    .    .   .    .    .   .    .    .  	    return res;
  5    0    0   0    0    0   0    0    0  	  len -= 1;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* SRCP2 is now aligned for memory operations on `op_t'.
  .    .    .   .    .    .   .    .    .  	 SRCP1 alignment determines if we can do a simple,
  .    .    .   .    .    .   .    .    .  	 aligned compare or need to shuffle bits.  */
  .    .    .   .    .    .   .    .    .  
 18    1    1   0    0    0   0    0    0        if (srcp1 % OPSIZ == 0)
 12    0    0   0    0    0   0    0    0  	res = memcmp_common_alignment (srcp1, srcp2, len / OPSIZ);
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	res = memcmp_not_common_alignment (srcp1, srcp2, len / OPSIZ);
  6    0    0   0    0    0   0    0    0        if (res != 0)
  .    .    .   .    .    .   .    .    .  	return res;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Number of bytes remaining in the interval [0..OPSIZ-1].  */
  9    0    0   0    0    0   0    0    0        srcp1 += len & -OPSIZ;
  3    0    0   0    0    0   0    0    0        srcp2 += len & -OPSIZ;
  3    0    0   0    0    0   0    0    0        len %= OPSIZ;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* There are just a few bytes to compare.  Use byte memory operations.  */
206    2    2   0    0    0   0    0    0    while (len != 0)
  .    .    .   .    .    .   .    .    .      {
 91    0    0  91    1    1   0    0    0        a0 = ((byte *) srcp1)[0];
 91    0    0  91    6    6   0    0    0        b0 = ((byte *) srcp2)[0];
 91    0    0   0    0    0   0    0    0        srcp1 += 1;
  .    .    .   .    .    .   .    .    .        srcp2 += 1;
  .    .    .   .    .    .   .    .    .        res = a0 - b0;
294    0    0   0    0    0   0    0    0        if (res != 0)
  .    .    .   .    .    .   .    .    .  	return res;
  .    .    .   .    .    .   .    .    .        len -= 1;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .  
 12    0    0   0    0    0   0    0    0    return 0;
136    0    0 119    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_builtin_def(memcmp)
  .    .    .   .    .    .   .    .    .  #ifdef weak_alias
  .    .    .   .    .    .   .    .    .  # undef bcmp
  .    .    .   .    .    .   .    .    .  weak_alias (memcmp, bcmp)
  .    .    .   .    .    .   .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/memcpy.S
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 53 ----------------------------------------
  .    .    .  .    .    .  .    .    .  END_CHK (__memcpy_chk)
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  ENTRY(memcpy)				/* (void *, const void*, size_t) */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Handle tiny blocks. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1try):				/* up to 32B */
105    2    2  0    0    0  0    0    0  	cmpq	$32, %rdx
  .    .    .  .    .    .  .    .    .  #ifndef USE_AS_MEMPCPY
 25    0    0  0    0    0  0    0    0  	movq	%rdi, %rax		/* save return value */
  .    .    .  .    .    .  .    .    .  #endif
105    0    0  0    0    0  0    0    0  	jae	L(1after)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1):					/* 1-byte once */
105    0    0  0    0    0  0    0    0  	testb	$1, %dl
105    0    0  0    0    0  0    0    0  	jz	L(1a)
  .    .    .  .    .    .  .    .    .  
 38    1    1 38    1    1  0    0    0  	movzbl	(%rsi),	%ecx
 38    0    0  0    0    0 38    4    3  	movb	%cl, (%rdi)
  .    .    .  .    .    .  .    .    .  
 38    1    1  0    0    0  0    0    0  	incq	%rsi
 38    0    0  0    0    0  0    0    0  	incq	%rdi
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4,, 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1a):					/* 2-byte once */
105    0    0  0    0    0  0    0    0  	testb	$2, %dl
105    0    0  0    0    0  0    0    0  	jz	L(1b)
  .    .    .  .    .    .  .    .    .  
 31    0    0 31    0    0  0    0    0  	movzwl	(%rsi),	%ecx
 31    0    0  0    0    0 31    1    1  	movw	%cx, (%rdi)
  .    .    .  .    .    .  .    .    .  
 31    0    0  0    0    0  0    0    0  	addq	$2, %rsi
 38    0    0  0    0    0  0    0    0  	addq	$2, %rdi
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4,, 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1b):					/* 4-byte once */
105    0    0  0    0    0  0    0    0  	testb	$4, %dl
105    0    0  0    0    0  0    0    0  	jz	L(1c)
  .    .    .  .    .    .  .    .    .  
 29    0    0 29    1    1  0    0    0  	movl	(%rsi),	%ecx
 29    0    0  0    0    0 29    0    0  	movl	%ecx, (%rdi)
  .    .    .  .    .    .  .    .    .  
 29    0    0  0    0    0  0    0    0  	addq	$4, %rsi
 29    0    0  0    0    0  0    0    0  	addq	$4, %rdi
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4,, 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1c):					/* 8-byte once */
105    0    0  0    0    0  0    0    0  	testb	$8, %dl
105    0    0  0    0    0  0    0    0  	jz	L(1d)
  .    .    .  .    .    .  .    .    .  
 36    0    0 36    2    1  0    0    0  	movq	(%rsi), %rcx
 36    0    0  0    0    0 36    3    3  	movq	%rcx, (%rdi)
  .    .    .  .    .    .  .    .    .  
 36    0    0  0    0    0  0    0    0  	addq	$8, %rsi
 60    0    0  0    0    0  0    0    0  	addq	$8, %rdi
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4,, 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1d):					/* 16-byte loop */
105    3    3  0    0    0  0    0    0  	andl	$0xf0, %edx
154    0    0  0    0    0  0    0    0  	jz	L(exit)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1loop):
 49    0    0 49    2    0  0    0    0  	movq	 (%rsi), %rcx
 49    0    0 49    0    0  0    0    0  	movq	8(%rsi), %r8
 49    0    0  0    0    0 49   11   11  	movq	%rcx,  (%rdi)
 49    0    0  0    0    0 49    2    2  	movq	 %r8, 8(%rdi)
  .    .    .  .    .    .  .    .    .  
 49    0    0  0    0    0  0    0    0  	subl	$16, %edx
  .    .    .  .    .    .  .    .    .  
 49    0    0  0    0    0  0    0    0  	leaq	16(%rsi), %rsi
 49    0    0  0    0    0  0    0    0  	leaq	16(%rdi), %rdi
  .    .    .  .    .    .  .    .    .  
 49    0    0  0    0    0  0    0    0  	jnz	L(1loop)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4,, 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(exit):				/* exit */
  .    .    .  .    .    .  .    .    .  #ifdef USE_AS_MEMPCPY
 80    0    0  0    0    0  0    0    0  	movq	%rdi, %rax		/* return value */
  .    .    .  .    .    .  .    .    .  #else
 25    0    0 25    0    0  0    0    0  	rep
  .    .    .  .    .    .  .    .    .  #endif
 80    0    0 80    0    0  0    0    0  	retq
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(1after):
  .    .    .  .    .    .  .    .    .  #ifndef USE_AS_MEMPCPY
  7    0    0  0    0    0  7    0    0  	movq	%rax, RETVAL(%rsp)	/* save return value */
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Align to the natural word size. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(aligntry):
 14    1    1  0    0    0  0    0    0  	movl	%esi, %ecx      	/* align by source */
  .    .    .  .    .    .  .    .    .  
 14    0    0  0    0    0  0    0    0  	andl	$7, %ecx
 14    0    0  0    0    0  0    0    0  	jz	L(alignafter)  		/* already aligned */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(align):		      		/* align */
  3    1    1  0    0    0  0    0    0  	leaq	-8(%rcx, %rdx), %rdx	/* calculate remaining bytes */
  9    0    0  0    0    0  0    0    0  	subl	$8, %ecx
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(alignloop):				/* 1-byte alignment loop */
 15    0    0 15    0    0  0    0    0  	movzbl	(%rsi), %eax
 15    0    0  0    0    0 15    0    0  	movb	%al, (%rdi)
  .    .    .  .    .    .  .    .    .  
 15    0    0  0    0    0  0    0    0  	incl	%ecx
  .    .    .  .    .    .  .    .    .  
 15    0    0  0    0    0  0    0    0  	leaq	1(%rsi), %rsi
 15    0    0  0    0    0  0    0    0  	leaq	1(%rdi), %rdi
  .    .    .  .    .    .  .    .    .  
 21    0    0  0    0    0  0    0    0  	jnz	L(alignloop)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(alignafter):
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  /* Handle mid-sized blocks. */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(32try):				/* up to 1KB */
 14    0    0  0    0    0  0    0    0  	cmpq	$1024, %rdx
 14    0    0  0    0    0  0    0    0  	ja	L(32after)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(32):					/* 32-byte loop */
 14    0    0  0    0    0  0    0    0  	movl	%edx, %ecx
 14    0    0  0    0    0  0    0    0  	shrl	$5, %ecx
 14    0    0  0    0    0  0    0    0  	jz	L(32skip)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(32loop):
 14    2    2  0    0    0  0    0    0  	decl	%ecx
  .    .    .  .    .    .  .    .    .  
 14    0    0 14    0    0  0    0    0  	movq	  (%rsi), %rax
 14    0    0 14    0    0  0    0    0  	movq	 8(%rsi), %r8
 14    0    0 14    0    0  0    0    0  	movq	16(%rsi), %r9
 14    0    0 14    0    0  0    0    0  	movq	24(%rsi), %r10
  .    .    .  .    .    .  .    .    .  
 14    0    0  0    0    0 14    5    5  	movq	%rax,   (%rdi)
 14    0    0  0    0    0 14    1    1  	movq	 %r8,  8(%rdi)
 14    0    0  0    0    0 14    1    1  	movq	 %r9, 16(%rdi)
 14    0    0  0    0    0 14    1    1  	movq	%r10, 24(%rdi)
  .    .    .  .    .    .  .    .    .  
 14    0    0  0    0    0  0    0    0  	leaq	32(%rsi), %rsi
 14    0    0  0    0    0  0    0    0  	leaq	32(%rdi), %rdi
  .    .    .  .    .    .  .    .    .  
 14    0    0  0    0    0  0    0    0  	jz	L(32skip)		/* help out smaller blocks */
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0  	decl	%ecx
  .    .    .  .    .    .  .    .    .  
  2    0    0  2    0    0  0    0    0  	movq	  (%rsi), %rax
  2    0    0  2    0    0  0    0    0  	movq	 8(%rsi), %r8
  2    0    0  2    0    0  0    0    0  	movq	16(%rsi), %r9
  2    0    0  2    0    0  0    0    0  	movq	24(%rsi), %r10
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  2    0    0  	movq	%rax,   (%rdi)
  2    1    1  0    0    0  2    0    0  	movq	 %r8,  8(%rdi)
  2    0    0  0    0    0  2    0    0  	movq	 %r9, 16(%rdi)
  2    0    0  0    0    0  2    0    0  	movq	%r10, 24(%rdi)
  .    .    .  .    .    .  .    .    .  
  2    0    0  0    0    0  0    0    0  	leaq	32(%rsi), %rsi
  2    0    0  0    0    0  0    0    0  	leaq	32(%rdi), %rdi
  .    .    .  .    .    .  .    .    .  
  4    0    0  0    0    0  0    0    0  	jnz	L(32loop)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(32skip):
 14    1    1  0    0    0  0    0    0  	andl	$31, %edx		/* check for left overs */
  .    .    .  .    .    .  .    .    .  #ifdef USE_AS_MEMPCPY
  7    0    0  0    0    0  0    0    0  	jnz	L(1)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	movq	%rdi, %rax
  .    .    .  .    .    .  .    .    .  #else
  7    0    0  7    0    0  0    0    0  	movq	RETVAL(%rsp), %rax
  7    0    0  0    0    0  0    0    0  	jnz	L(1)
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	rep
  .    .    .  .    .    .  .    .    .  #endif
  .    .    .  .    .    .  .    .    .  	retq				/* exit */
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  	.p2align 4
  .    .    .  .    .    .  .    .    .  
  .    .    .  .    .    .  .    .    .  L(32after):
-- line 246 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-misc.c
--------------------------------------------------------------------------------
Ir    I1mr ILmr Dr    D1mr DLmr Dw  D1mw DLmw 

-- line 35 ----------------------------------------
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  /* Read the whole contents of FILE into new mmap'd space with given
    .    .    .     .    .    .   .    .    .     protections.  *SIZEP gets the size of the file.  On error MAP_FAILED
    .    .    .     .    .    .   .    .    .     is returned.  */
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  void *
    .    .    .     .    .    .   .    .    .  internal_function
    .    .    .     .    .    .   .    .    .  _dl_sysdep_read_whole_file (const char *file, size_t *sizep, int prot)
    7    2    2     0    0    0   4    0    0  {
    1    0    0     0    0    0   0    0    0    void *result = MAP_FAILED;
    .    .    .     .    .    .   .    .    .    struct stat64 st;
    .    .    .     .    .    .   .    .    .    int flags = O_RDONLY;
    .    .    .     .    .    .   .    .    .  #ifdef O_CLOEXEC
    .    .    .     .    .    .   .    .    .    flags |= O_CLOEXEC;
    .    .    .     .    .    .   .    .    .  #endif
    4    0    0     0    0    0   1    0    0    int fd = __open (file, flags);
    2    0    0     0    0    0   0    0    0    if (fd >= 0)
    .    .    .     .    .    .   .    .    .      {
    6    0    0     0    0    0   1    0    0        if (__fxstat64 (_STAT_VER, fd, &st) >= 0)
    .    .    .     .    .    .   .    .    .  	{
    2    0    0     1    0    0   1    1    1  	  *sizep = st.st_size;
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  	  /* No need to map the file if it is empty.  */
    2    0    0     0    0    0   0    0    0  	  if (*sizep != 0)
    .    .    .     .    .    .   .    .    .  	    /* Map a copy of the file contents.  */
    8    1    1     0    0    0   1    0    0  	    result = __mmap (NULL, *sizep, prot,
    .    .    .     .    .    .   .    .    .  #ifdef MAP_COPY
    .    .    .     .    .    .   .    .    .  			     MAP_COPY
    .    .    .     .    .    .   .    .    .  #else
    .    .    .     .    .    .   .    .    .  			     MAP_PRIVATE
    .    .    .     .    .    .   .    .    .  #endif
    .    .    .     .    .    .   .    .    .  #ifdef MAP_FILE
    .    .    .     .    .    .   .    .    .  			     | MAP_FILE
    .    .    .     .    .    .   .    .    .  #endif
    .    .    .     .    .    .   .    .    .  			     , fd, 0);
    .    .    .     .    .    .   .    .    .  	}
    2    0    0     0    0    0   1    0    0        __close (fd);
    .    .    .     .    .    .   .    .    .      }
    .    .    .     .    .    .   .    .    .    return result;
    7    0    0     5    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  /* Bare-bones printf implementation.  This function only knows about
    .    .    .     .    .    .   .    .    .     the formats and flags needed and can handle only up to 64 stripes in
    .    .    .     .    .    .   .    .    .     the output.  */
    .    .    .     .    .    .   .    .    .  static void
    .    .    .     .    .    .   .    .    .  _dl_debug_vdprintf (int fd, int tag_p, const char *fmt, va_list arg)
    .    .    .     .    .    .   .    .    .  {
-- line 82 ----------------------------------------
-- line 296 ----------------------------------------
    .    .    .     .    .    .   .    .    .    va_end (arg);
    .    .    .     .    .    .   .    .    .  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  /* Test whether given NAME matches any of the names of the given object.  */
    .    .    .     .    .    .   .    .    .  int
    .    .    .     .    .    .   .    .    .  internal_function
    .    .    .     .    .    .   .    .    .  _dl_name_match_p (const char *name, const struct link_map *map)
1,910    1    1     0    0    0 764    1    1  {
1,528    0    0   382    0    0 382    0    0    if (strcmp (name, map->l_name) == 0)
  390    0    0     0    0    0   0    0    0      return 1;
    .    .    .     .    .    .   .    .    .  
  382    0    0   382    0    0   0    0    0    struct libname_list *runp = map->l_libname;
    .    .    .     .    .    .   .    .    .  
1,528    0    0     0    0    0   0    0    0    while (runp != NULL)
1,950    1    1   390   11    0 390    0    0      if (strcmp (name, runp->name) == 0)
    .    .    .     .    .    .   .    .    .        return 1;
    .    .    .     .    .    .   .    .    .      else
  382    0    0   382    0    0   0    0    0        runp = runp->next;
    .    .    .     .    .    .   .    .    .  
  374    0    0     0    0    0   0    0    0    return 0;
1,910    0    0 1,146    0    0   0    0    0  }
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  
    .    .    .     .    .    .   .    .    .  unsigned long int
    .    .    .     .    .    .   .    .    .  internal_function
    .    .    .     .    .    .   .    .    .  _dl_higher_prime_number (unsigned long int n)
    .    .    .     .    .    .   .    .    .  {
    .    .    .     .    .    .   .    .    .    /* These are primes that are near, but slightly smaller than, a
    .    .    .     .    .    .   .    .    .       power of two.  */
-- line 325 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/elf/dl-minimal.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw D1mw DLmw 

-- line 43 ----------------------------------------
  .    .    .   .    .    .  .    .    .  							   int group);
  .    .    .   .    .    .  .    .    .  extern unsigned long int weak_function strtoul (const char *nptr,
  .    .    .   .    .    .  .    .    .  						char **endptr, int base);
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* Allocate an aligned memory block.  */
  .    .    .   .    .    .  .    .    .  void * weak_function
  .    .    .   .    .    .  .    .    .  __libc_memalign (size_t align, size_t n)
132    1    1   0    0    0 66    1    1  {
163    1    1  65    0    0  0    0    0    if (alloc_end == 0)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Consume any unused space in the last page of our data segment.  */
  .    .    .   .    .    .  .    .    .        extern int _end attribute_hidden;
  .    .    .   .    .    .  .    .    .        alloc_ptr = &_end;
  3    0    0   0    0    0  1    0    0        alloc_end = (void *) 0 + (((alloc_ptr - (void *) 0)
  3    1    1   1    0    0  0    0    0  				 + GLRO(dl_pagesize) - 1)
  1    0    0   0    0    0  0    0    0  				& ~(GLRO(dl_pagesize) - 1));
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    /* Make sure the allocation pointer is ideally aligned.  */
 99    0    0   0    0    0 33    0    0    alloc_ptr = (void *) 0 + (((alloc_ptr - (void *) 0) + align - 1)
 33    0    0   0    0    0  0    0    0  			    & ~(align - 1));
  .    .    .   .    .    .  .    .    .  
219    0    0   0    0    0  0    0    0    if (alloc_ptr + n >= alloc_end || n >= -(uintptr_t) alloc_ptr)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Insufficient space left; allocate another page.  */
  .    .    .   .    .    .  .    .    .        caddr_t page;
 12    1    1   3    0    0  0    0    0        size_t nup = (n + GLRO(dl_pagesize) - 1) & ~(GLRO(dl_pagesize) - 1);
  9    0    0   0    0    0  0    0    0        if (__builtin_expect (nup == 0, 0))
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  if (n)
  .    .    .   .    .    .  .    .    .  	    return NULL;
  .    .    .   .    .    .  .    .    .  	  nup = GLRO(dl_pagesize);
  .    .    .   .    .    .  .    .    .  	}
 21    0    0   0    0    0  3    0    0        page = __mmap (0, nup, PROT_READ|PROT_WRITE,
  .    .    .   .    .    .  .    .    .  		     MAP_ANON|MAP_PRIVATE, -1, 0);
 15    0    0   6    0    0  0    0    0        if (page == MAP_FAILED)
  .    .    .   .    .    .  .    .    .  	return NULL;
  .    .    .   .    .    .  .    .    .        if (page != alloc_end)
  .    .    .   .    .    .  .    .    .  	alloc_ptr = page;
  9    0    0   0    0    0  3    0    0        alloc_end = page + nup;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
 33    0    0   0    0    0 33    0    0    alloc_last_block = (void *) alloc_ptr;
 33    0    0   0    0    0 33    0    0    alloc_ptr += n;
  .    .    .   .    .    .  .    .    .    return alloc_last_block;
255    1    1  99    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  void * weak_function
  .    .    .   .    .    .  .    .    .  malloc (size_t n)
 32    0    0   0    0    0  0    0    0  {
 64    0    0   0    0    0  0    0    0    return __libc_memalign (sizeof (double), n);
  .    .    .   .    .    .  .    .    .  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* We use this function occasionally since the real implementation may
  .    .    .   .    .    .  .    .    .     be optimized when it can assume the memory it returns already is
  .    .    .   .    .    .  .    .    .     set to NUL.  */
  .    .    .   .    .    .  .    .    .  void * weak_function
  .    .    .   .    .    .  .    .    .  calloc (size_t nmemb, size_t size)
 10    1    1   0    0    0  0    0    0  {
  .    .    .   .    .    .  .    .    .    /* New memory from the trivial malloc above is always already cleared.
  .    .    .   .    .    .  .    .    .       (We make sure that's true in the rare occasion it might not be,
  .    .    .   .    .    .  .    .    .       by clearing memory in free, below.)  */
 10    0    0   0    0    0  0    0    0    size_t bytes = nmemb * size;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  #define HALF_SIZE_T (((size_t) 1) << (8 * sizeof (size_t) / 2))
 50    0    0   0    0    0  0    0    0    if (__builtin_expect ((nmemb | size) >= HALF_SIZE_T, 0)
  .    .    .   .    .    .  .    .    .        && size != 0 && bytes / size != nmemb)
  .    .    .   .    .    .  .    .    .      return NULL;
  .    .    .   .    .    .  .    .    .  
 10    0    0   0    0    0  0    0    0    return malloc (bytes);
  .    .    .   .    .    .  .    .    .  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* This will rarely be called.  */
  .    .    .   .    .    .  .    .    .  void weak_function
  .    .    .   .    .    .  .    .    .  free (void *ptr)
 14    0    0   0    0    0  7    0    0  {
  .    .    .   .    .    .  .    .    .    /* We can free only the last block allocated.  */
 14    1    1   7    0    0  0    0    0    if (ptr == alloc_last_block)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        /* Since this is rare, we clear the freed block here
  .    .    .   .    .    .  .    .    .  	 so that calloc can presume malloc returns cleared memory.  */
  .    .    .   .    .    .  .    .    .        memset (alloc_last_block, '\0', alloc_ptr - alloc_last_block);
  .    .    .   .    .    .  .    .    .        alloc_ptr = alloc_last_block;
  .    .    .   .    .    .  .    .    .      }
 14    0    0  14    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  /* This is only called with the most recent block returned by malloc.  */
  .    .    .   .    .    .  .    .    .  void * weak_function
  .    .    .   .    .    .  .    .    .  realloc (void *ptr, size_t n)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    if (ptr == NULL)
  .    .    .   .    .    .  .    .    .      return malloc (n);
  .    .    .   .    .    .  .    .    .    assert (ptr == alloc_last_block);
-- line 136 ----------------------------------------
-- line 329 ----------------------------------------
  .    .    .   .    .    .  .    .    .  #undef __strsep
  .    .    .   .    .    .  .    .    .  char *
  .    .    .   .    .    .  .    .    .  __strsep (char **stringp, const char *delim)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    char *begin;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    assert (delim[0] != '\0');
  .    .    .   .    .    .  .    .    .  
  5    1    1   5    0    0  0    0    0    begin = *stringp;
 10    0    0   0    0    0  0    0    0    if (begin != NULL)
  .    .    .   .    .    .  .    .    .      {
  .    .    .   .    .    .  .    .    .        char *end = begin;
  .    .    .   .    .    .  .    .    .  
697    0    0 138    0    0  0    0    0        while (*end != '\0' || (end = NULL))
  .    .    .   .    .    .  .    .    .  	{
  .    .    .   .    .    .  .    .    .  	  const char *dp = delim;
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  	  do
542    0    0 271    0    0  0    0    0  	    if (*dp == *end)
  .    .    .   .    .    .  .    .    .  	      break;
804    0    0 268    0    0  0    0    0  	  while (*++dp != '\0');
  .    .    .   .    .    .  .    .    .  
  6    0    0   0    0    0  0    0    0  	  if (*dp != '\0')
  .    .    .   .    .    .  .    .    .  	    {
  6    0    0   0    0    0  3    0    0  	      *end++ = '\0';
  3    0    0   0    0    0  0    0    0  	      break;
  .    .    .   .    .    .  .    .    .  	    }
  .    .    .   .    .    .  .    .    .  
134    0    0   0    0    0  0    0    0  	  ++end;
  .    .    .   .    .    .  .    .    .  	}
  .    .    .   .    .    .  .    .    .  
  4    0    0   0    0    0  4    0    0        *stringp = end;
  .    .    .   .    .    .  .    .    .      }
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .    return begin;
  5    0    0   5    0    0  0    0    0  }
  .    .    .   .    .    .  .    .    .  weak_alias (__strsep, strsep)
  .    .    .   .    .    .  .    .    .  strong_alias (__strsep, __strsep_g)
  .    .    .   .    .    .  .    .    .  
  .    .    .   .    .    .  .    .    .  void
  .    .    .   .    .    .  .    .    .  __attribute__ ((noreturn))
  .    .    .   .    .    .  .    .    .  __chk_fail (void)
  .    .    .   .    .    .  .    .    .  {
  .    .    .   .    .    .  .    .    .    _exit (127);
-- line 372 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug////////glibc-2.17-c758a686/string/../sysdeps/x86_64/rtld-strlen.S
--------------------------------------------------------------------------------
Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw 

-- line 18 ----------------------------------------
 .    .    .  .    .    .  .    .    .     <http://www.gnu.org/licenses/>.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  #include <sysdep.h>
 .    .    .  .    .    .  .    .    .  #include "asm-syntax.h"
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	.text
 .    .    .  .    .    .  .    .    .  ENTRY (strlen)
24    1    1  0    0    0  0    0    0  	movq %rdi, %rcx		/* Duplicate source pointer. */
24    0    0  0    0    0  0    0    0  	andl $7, %ecx		/* mask alignment bits */
24    0    0  0    0    0  0    0    0  	movq %rdi, %rax		/* duplicate destination.  */
24    0    0  0    0    0  0    0    0  	jz 1f			/* aligned => start loop */
 .    .    .  .    .    .  .    .    .  
12    0    0  0    0    0  0    0    0  	neg %ecx		/* We need to align to 8 bytes.  */
12    0    0  0    0    0  0    0    0  	addl $8,%ecx
 .    .    .  .    .    .  .    .    .  	/* Search the first bytes directly.  */
48    0    0 48    1    1  0    0    0  0:	cmpb $0x0,(%rax)	/* is byte NUL? */
48    0    0  0    0    0  0    0    0  	je 2f			/* yes => return */
47    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
47    0    0  0    0    0  0    0    0  	decl %ecx
47    0    0  0    0    0  0    0    0  	jnz 0b
 .    .    .  .    .    .  .    .    .  
46    0    0  0    0    0  0    0    0  1:	movq $0xfefefefefefefeff,%r8 /* Save magic.  */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	.p2align 4		/* Align loop.  */
 .    .    .  .    .    .  .    .    .  4:	/* Main Loop is unrolled 4 times.  */
 .    .    .  .    .    .  .    .    .  	/* First unroll.  */
33    0    0 33    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
33    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
33    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
33    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
33    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
31    1    1  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
31    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
31    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
31    0    0  0    0    0  0    0    0  	jnz 3f			/* found NUL => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Second unroll.  */
30    0    0 30    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
30    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
30    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
30    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
30    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
29    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
29    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
29    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
29    0    0  0    0    0  0    0    0  	jnz 3f			/* found NUL => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Third unroll.  */
23    0    0 23    0    0  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
23    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
23    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
23    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
23    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
16    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
16    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
16    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
16    0    0  0    0    0  0    0    0  	jnz 3f			/* found NUL => return pointer */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	/* Fourth unroll.  */
15    0    0 15    1    1  0    0    0  	movq (%rax), %rcx	/* get double word (= 8 bytes) in question */
15    0    0  0    0    0  0    0    0  	addq $8,%rax		/* adjust pointer for next word */
15    0    0  0    0    0  0    0    0  	movq %r8, %rdx		/* magic value */
15    0    0  0    0    0  0    0    0  	addq %rcx, %rdx		/* add the magic value to the word.  We get
 .    .    .  .    .    .  .    .    .  				   carry bits reported for each byte which
 .    .    .  .    .    .  .    .    .  				   is *not* 0 */
15    0    0  0    0    0  0    0    0  	jnc 3f			/* highest byte is NUL => return pointer */
12    0    0  0    0    0  0    0    0  	xorq %rcx, %rdx		/* (word+magic)^word */
12    0    0  0    0    0  0    0    0  	orq %r8, %rdx		/* set all non-carry bits */
12    0    0  0    0    0  0    0    0  	incq %rdx		/* add 1: if one carry bit was *not* set
 .    .    .  .    .    .  .    .    .  				   the addition will not result in 0.  */
14    0    0  0    0    0  0    0    0  	jz 4b			/* no NUL found => continue loop */
 .    .    .  .    .    .  .    .    .  
 .    .    .  .    .    .  .    .    .  	.p2align 4		/* Align, it's a jump target.  */
23    1    1  0    0    0  0    0    0  3:	subq $8,%rax		/* correct pointer increment.  */
 .    .    .  .    .    .  .    .    .  
23    0    0  0    0    0  0    0    0  	testb %cl, %cl		/* is first byte NUL? */
23    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return */
17    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
17    0    0  0    0    0  0    0    0  	testb %ch, %ch		/* is second byte NUL? */
17    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return */
14    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
14    0    0  0    0    0  0    0    0  	testl $0x00ff0000, %ecx /* is third byte NUL? */
14    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return pointer */
12    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
12    1    1  0    0    0  0    0    0  	testl $0xff000000, %ecx /* is fourth byte NUL? */
12    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return pointer */
 5    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
 5    0    0  0    0    0  0    0    0  	shrq $32, %rcx		/* look at other half.  */
 .    .    .  .    .    .  .    .    .  
 5    0    0  0    0    0  0    0    0  	testb %cl, %cl		/* is first byte NUL? */
 5    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return */
 4    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
 4    0    0  0    0    0  0    0    0  	testb %ch, %ch		/* is second byte NUL? */
 4    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return */
 3    0    0  0    0    0  0    0    0  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  
 3    0    0  0    0    0  0    0    0  	testl $0xff0000, %ecx	/* is third byte NUL? */
 3    0    0  0    0    0  0    0    0  	jz 2f			/* yes => return pointer */
 .    .    .  .    .    .  .    .    .  	incq %rax		/* increment pointer */
 .    .    .  .    .    .  .    .    .  2:
24    0    0  0    0    0  0    0    0  	subq %rdi, %rax		/* compute difference to string start */
24    0    0 24    0    0  0    0    0  	ret
 .    .    .  .    .    .  .    .    .  END (strlen)
 .    .    .  .    .    .  .    .    .  libc_hidden_builtin_def (strlen)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/src/debug/glibc-2.17-c758a686/libio/fileops.c
--------------------------------------------------------------------------------
Ir  I1mr ILmr Dr  D1mr DLmr Dw  D1mw DLmw 

-- line 443 ----------------------------------------
  .    .    .   .    .    .   .    .    .      return NULL;
  .    .    .   .    .    .   .    .    .    __set_errno (save_errno);
  .    .    .   .    .    .   .    .    .    return fp;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_file_attach, _IO_file_attach)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  _IO_FILE *
  .    .    .   .    .    .   .    .    .  _IO_new_file_setbuf (_IO_FILE *fp, char *p, _IO_ssize_t len)
  2    1    1   0    0    0   1    0    0  {
  3    0    0   0    0    0   1    0    0    if (_IO_default_setbuf (fp, p, len) == NULL)
  .    .    .   .    .    .   .    .    .      return NULL;
  .    .    .   .    .    .   .    .    .  
  2    0    0   0    0    0   2    0    0    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end
  2    0    0   1    0    0   1    0    0      = fp->_IO_buf_base;
  3    0    0   0    0    0   3    0    0    _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
  .    .    .   .    .    .   .    .    .  
  1    0    0   0    0    0   0    0    0    return fp;
  2    0    0   2    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  _IO_FILE *
  .    .    .   .    .    .   .    .    .  _IO_file_setbuf_mmap (_IO_FILE *fp, char *p, _IO_ssize_t len)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    _IO_FILE *result;
  .    .    .   .    .    .   .    .    .  
-- line 468 ----------------------------------------
-- line 485 ----------------------------------------
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static _IO_size_t new_do_write (_IO_FILE *, const char *, _IO_size_t);
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  /* Write TO_DO bytes from DATA to FP.
  .    .    .   .    .    .   .    .    .     Then mark FP as having empty buffers. */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
 18    1    1   0    0    0  15    0    0  {
  .    .    .   .    .    .   .    .    .    return (to_do == 0
 17    0    0   0    0    0   0    0    0  	  || (_IO_size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;
 18    0    0  18    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_do_write, _IO_do_write)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static
  .    .    .   .    .    .   .    .    .  _IO_size_t
  .    .    .   .    .    .   .    .    .  new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    _IO_size_t count;
  8    1    1   2    0    0   0    0    0    if (fp->_flags & _IO_IS_APPENDING)
  .    .    .   .    .    .   .    .    .      /* On a system without a proper O_APPEND implementation,
  .    .    .   .    .    .   .    .    .         you would need to sys_seek(0, SEEK_END) here, but is
  .    .    .   .    .    .   .    .    .         not needed nor desirable for Unix- or Posix-like systems.
  .    .    .   .    .    .   .    .    .         Instead, just indicate that offset (before and after) is
  .    .    .   .    .    .   .    .    .         unpredictable. */
  .    .    .   .    .    .   .    .    .      fp->_offset = _IO_pos_BAD;
  8    0    0   4    0    0   0    0    0    else if (fp->_IO_read_end != fp->_IO_write_base)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        _IO_off64_t new_pos
  .    .    .   .    .    .   .    .    .  	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
  .    .    .   .    .    .   .    .    .        if (new_pos == _IO_pos_BAD)
  .    .    .   .    .    .   .    .    .  	return 0;
  .    .    .   .    .    .   .    .    .        fp->_offset = new_pos;
  .    .    .   .    .    .   .    .    .      }
 12    1    1   4    0    0   2    0    0    count = _IO_SYSWRITE (fp, data, to_do);
  6    0    0   2    0    0   0    0    0    if (fp->_cur_column && count)
  8    2    2   0    0    0   0    0    0      fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;
  8    0    0   2    0    0   6    0    0    _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);
  4    1    1   0    0    0   4    0    0    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;
  2    0    0   0    0    0   2    0    0    fp->_IO_write_end = (fp->_mode <= 0
  4    0    0   2    0    0   0    0    0  		       && (fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))
  6    0    0   2    0    0   0    0    0  		       ? fp->_IO_buf_base : fp->_IO_buf_end);
  .    .    .   .    .    .   .    .    .    return count;
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_new_file_underflow (_IO_FILE *fp)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    _IO_ssize_t count;
  .    .    .   .    .    .   .    .    .  #if 0
-- line 534 ----------------------------------------
-- line 794 ----------------------------------------
  .    .    .   .    .    .   .    .    .       and then punt to the chosen underflow routine.  */
  .    .    .   .    .    .   .    .    .    decide_maybe_mmap (fp);
  .    .    .   .    .    .   .    .    .    return _IO_UNDERFLOW (fp);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_new_file_overflow (_IO_FILE *f, int ch)
 96    1    1   0    0    0  72    1    1  {
 72    0    0  24    0    0   0    0    0    if (f->_flags & _IO_NO_WRITES) /* SET ERROR */
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        f->_flags |= _IO_ERR_SEEN;
  .    .    .   .    .    .   .    .    .        __set_errno (EBADF);
  .    .    .   .    .    .   .    .    .        return EOF;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    /* If currently reading or no buffer allocated. */
164    0    0  46    0    0   0    0    0    if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        /* Allocate a buffer if needed. */
  2    1    1   1    0    0   0    0    0        if (f->_IO_write_base == NULL)
  .    .    .   .    .    .   .    .    .  	{
  2    1    1   0    0    0   1    0    0  	  _IO_doallocbuf (f);
  6    0    0   2    0    0   3    0    0  	  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .        /* Otherwise must be currently reading.
  .    .    .   .    .    .   .    .    .  	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,
  .    .    .   .    .    .   .    .    .  	 logically slide the buffer forwards one block (by setting the
  .    .    .   .    .    .   .    .    .  	 read pointers to all point at the beginning of the block).  This
  .    .    .   .    .    .   .    .    .  	 makes room for subsequent output.
  .    .    .   .    .    .   .    .    .  	 Otherwise, set the read pointers to _IO_read_end (leaving that
  .    .    .   .    .    .   .    .    .  	 alone, so it can continue to correspond to the external position). */
  2    0    0   0    0    0   0    0    0        if (__builtin_expect (_IO_in_backup (f), 0))
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;
  .    .    .   .    .    .   .    .    .  	  _IO_free_backup_area (f);
  .    .    .   .    .    .   .    .    .  	  f->_IO_read_base -= MIN (nbackup,
  .    .    .   .    .    .   .    .    .  				   f->_IO_read_base - f->_IO_buf_base);
  .    .    .   .    .    .   .    .    .  	  f->_IO_read_ptr = f->_IO_read_base;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  4    0    0   2    0    0   0    0    0        if (f->_IO_read_ptr == f->_IO_buf_end)
  .    .    .   .    .    .   .    .    .  	f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;
  1    0    0   0    0    0   1    0    0        f->_IO_write_ptr = f->_IO_read_ptr;
  2    0    0   0    0    0   1    0    0        f->_IO_write_base = f->_IO_write_ptr;
  1    0    0   0    0    0   1    0    0        f->_IO_write_end = f->_IO_buf_end;
  2    1    1   0    0    0   2    0    0        f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;
  .    .    .   .    .    .   .    .    .  
  3    0    0   0    0    0   1    0    0        f->_flags |= _IO_CURRENTLY_PUTTING;
  5    0    0   1    0    0   0    0    0        if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))
  2    0    0   0    0    0   1    0    0  	f->_IO_write_end = f->_IO_write_ptr;
  .    .    .   .    .    .   .    .    .      }
 48    2    1   0    0    0   0    0    0    if (ch == EOF)
  4    2    1   0    0    0   0    0    0      return _IO_do_write (f, f->_IO_write_base,
  2    0    0   0    0    0   0    0    0  			 f->_IO_write_ptr - f->_IO_write_base);
 44    0    0  22    0    0   0    0    0    if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */
  .    .    .   .    .    .   .    .    .      if (_IO_do_flush (f) == EOF)
  .    .    .   .    .    .   .    .    .        return EOF;
 66    0    0   0    0    0  44    1    0    *f->_IO_write_ptr++ = ch;
 66    0    0  22    0    0   0    0    0    if ((f->_flags & _IO_UNBUFFERED)
 88    0    0   0    0    0   0    0    0        || ((f->_flags & _IO_LINE_BUF) && ch == '\n'))
  4    1    1   0    0    0   1    0    0      if (_IO_do_write (f, f->_IO_write_base,
  3    0    0   2    0    0   0    0    0  		      f->_IO_write_ptr - f->_IO_write_base) == EOF)
  .    .    .   .    .    .   .    .    .        return EOF;
 22    0    0   0    0    0   0    0    0    return (unsigned char) ch;
 94    0    0  94    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_new_file_sync (_IO_FILE *fp)
  4    1    1   0    0    0   2    0    0  {
  .    .    .   .    .    .   .    .    .    _IO_ssize_t delta;
  .    .    .   .    .    .   .    .    .    int retval = 0;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /*    char* ptr = cur_ptr(); */
  4    0    0   2    0    0   0    0    0    if (fp->_IO_write_ptr > fp->_IO_write_base)
  .    .    .   .    .    .   .    .    .      if (_IO_do_flush(fp)) return EOF;
  1    1    1   1    0    0   0    0    0    delta = fp->_IO_read_ptr - fp->_IO_read_end;
  2    0    0   1    0    0   0    0    0    if (delta != 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #ifdef TODO
  .    .    .   .    .    .   .    .    .        if (_IO_in_backup (fp))
  .    .    .   .    .    .   .    .    .  	delta -= eGptr () - Gbase ();
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .        _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);
  .    .    .   .    .    .   .    .    .        if (new_pos != (_IO_off64_t) EOF)
  .    .    .   .    .    .   .    .    .  	fp->_IO_read_end = fp->_IO_read_ptr;
-- line 879 ----------------------------------------
-- line 880 ----------------------------------------
  .    .    .   .    .    .   .    .    .  #ifdef ESPIPE
  .    .    .   .    .    .   .    .    .        else if (errno == ESPIPE)
  .    .    .   .    .    .   .    .    .  	; /* Ignore error from unseekable devices. */
  .    .    .   .    .    .   .    .    .  #endif
  .    .    .   .    .    .   .    .    .        else
  .    .    .   .    .    .   .    .    .  	retval = EOF;
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    if (retval != EOF)
  2    1    1   0    0    0   1    0    0      fp->_offset = _IO_pos_BAD;
  .    .    .   .    .    .   .    .    .    /* FIXME: Cleanup - can this be shared? */
  .    .    .   .    .    .   .    .    .    /*    setg(base(), ptr, ptr); */
  .    .    .   .    .    .   .    .    .    return retval;
  4    0    0   3    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  static int
  .    .    .   .    .    .   .    .    .  _IO_file_sync_mmap (_IO_FILE *fp)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    if (fp->_IO_read_ptr != fp->_IO_read_end)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .  #ifdef TODO
-- line 900 ----------------------------------------
-- line 1216 ----------------------------------------
  .    .    .   .    .    .   .    .    .  _IO_file_seek (_IO_FILE *fp, _IO_off64_t offset, int dir)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    return __lseek64 (fp->_fileno, offset, dir);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  libc_hidden_def (_IO_file_seek)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_file_stat (_IO_FILE *fp, void *st)
  1    1    1   0    0    0   0    0    0  {
  3    0    0   1    0    0   0    0    0    return __fxstat64 (_STAT_VER, fp->_fileno, (struct stat64 *) st);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  libc_hidden_def (_IO_file_stat)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  int
  .    .    .   .    .    .   .    .    .  _IO_file_close_mmap (_IO_FILE *fp)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    /* In addition to closing the file descriptor we have to unmap the file.  */
  .    .    .   .    .    .   .    .    .    (void) __munmap (fp->_IO_buf_base, fp->_IO_buf_end - fp->_IO_buf_base);
-- line 1233 ----------------------------------------
-- line 1243 ----------------------------------------
  .    .    .   .    .    .   .    .    .    /* Cancelling close should be avoided if possible since it leaves an
  .    .    .   .    .    .   .    .    .       unrecoverable state behind.  */
  .    .    .   .    .    .   .    .    .    return close_not_cancel (fp->_fileno);
  .    .    .   .    .    .   .    .    .  }
  .    .    .   .    .    .   .    .    .  libc_hidden_def (_IO_file_close)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  _IO_ssize_t
  .    .    .   .    .    .   .    .    .  _IO_new_file_write (_IO_FILE *f, const void *data, _IO_ssize_t n)
 14    0    0   0    0    0   8    0    0  {
  .    .    .   .    .    .   .    .    .    _IO_ssize_t to_do = n;
 14    1    1   0    0    0   0    0    0    while (to_do > 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        _IO_ssize_t count = (__builtin_expect (f->_flags2
  .    .    .   .    .    .   .    .    .  					     & _IO_FLAGS2_NOTCANCEL, 0)
  6    0    0   2    0    0   0    0    0  			   ? write_not_cancel (f->_fileno, data, to_do)
  6    0    0   2    0    0   2    0    0  			   : write (f->_fileno, data, to_do));
  4    0    0   0    0    0   0    0    0        if (count < 0)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  f->_flags |= _IO_ERR_SEEN;
  .    .    .   .    .    .   .    .    .  	  break;
  .    .    .   .    .    .   .    .    .  	}
  2    0    0   0    0    0   0    0    0        to_do -= count;
  2    0    0   0    0    0   0    0    0        data = (void *) ((char *) data + count);
  .    .    .   .    .    .   .    .    .      }
  .    .    .   .    .    .   .    .    .    n -= to_do;
  6    0    0   2    0    0   0    0    0    if (f->_offset >= 0)
  .    .    .   .    .    .   .    .    .      f->_offset += n;
  .    .    .   .    .    .   .    .    .    return n;
 18    1    1  10    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  _IO_size_t
  .    .    .   .    .    .   .    .    .  _IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)
160    1    1   0    0    0 120    1    0  {
  .    .    .   .    .    .   .    .    .    const char *s = (const char *) data;
  .    .    .   .    .    .   .    .    .    _IO_size_t to_do = n;
  .    .    .   .    .    .   .    .    .    int must_flush = 0;
  .    .    .   .    .    .   .    .    .    _IO_size_t count = 0;
  .    .    .   .    .    .   .    .    .  
 40    0    0   0    0    0   0    0    0    if (n <= 0)
 20    0    0   0    0    0   0    0    0      return 0;
  .    .    .   .    .    .   .    .    .    /* This is an optimized implementation.
  .    .    .   .    .    .   .    .    .       If the amount to be written straddles a block boundary
  .    .    .   .    .    .   .    .    .       (or the filebuf is unbuffered), use sys_write directly. */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* First figure out how much space is available in the buffer. */
 84    1    1  14    0    0   0    0    0    if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
  .    .    .   .    .    .   .    .    .      {
 39    1    1  26    0    0   0    0    0        count = f->_IO_buf_end - f->_IO_write_ptr;
 26    0    0   0    0    0   0    0    0        if (count >= n)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  const char *p;
197    1    1   0    0    0   0    0    0  	  for (p = s + n; p > s; )
  .    .    .   .    .    .   .    .    .  	    {
205    0    0  68    0    0   0    0    0  	      if (*--p == '\n')
  .    .    .   .    .    .   .    .    .  		{
  4    2    2   0    0    0   0    0    0  		  count = p - s + 1;
  .    .    .   .    .    .   .    .    .  		  must_flush = 1;
  .    .    .   .    .    .   .    .    .  		  break;
  .    .    .   .    .    .   .    .    .  		}
  .    .    .   .    .    .   .    .    .  	    }
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .      }
  7    0    0   2    0    0   0    0    0    else if (f->_IO_write_end > f->_IO_write_ptr)
  .    .    .   .    .    .   .    .    .      count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .    /* Then fill the buffer. */
 16    0    0   0    0    0   0    0    0    if (count > 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        if (count > to_do)
  .    .    .   .    .    .   .    .    .  	count = to_do;
  .    .    .   .    .    .   .    .    .  #ifdef _LIBC
 65    0    0   0    0    0  26    1    1        f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);
  .    .    .   .    .    .   .    .    .  #else
  .    .    .   .    .    .   .    .    .        memcpy (f->_IO_write_ptr, s, count);
  .    .    .   .    .    .   .    .    .        f->_IO_write_ptr += count;
  .    .    .   .    .    .   .    .    .  #endif
 13    0    0   0    0    0   0    0    0        s += count;
 39    0    0   0    0    0   0    0    0        to_do -= count;
  .    .    .   .    .    .   .    .    .      }
 42    1    1   0    0    0   0    0    0    if (to_do + must_flush > 0)
  .    .    .   .    .    .   .    .    .      {
  .    .    .   .    .    .   .    .    .        _IO_size_t block_size, do_write;
  .    .    .   .    .    .   .    .    .        /* Next flush the (full) buffer. */
 12    0    0   4    0    0   2    0    0        if (_IO_OVERFLOW (f, EOF) == EOF)
  .    .    .   .    .    .   .    .    .  	/* If nothing else has to be written we must not signal the
  .    .    .   .    .    .   .    .    .  	   caller that everything has been written.  */
  .    .    .   .    .    .   .    .    .  	return to_do == 0 ? EOF : n - to_do;
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Try to maintain alignment: write a whole number of blocks.  */
  4    0    0   4    0    0   0    0    0        block_size = f->_IO_buf_end - f->_IO_buf_base;
 12    0    0   0    0    0   0    0    0        do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);
  .    .    .   .    .    .   .    .    .  
  6    0    0   0    0    0   0    0    0        if (do_write)
  .    .    .   .    .    .   .    .    .  	{
  .    .    .   .    .    .   .    .    .  	  count = new_do_write (f, s, do_write);
  .    .    .   .    .    .   .    .    .  	  to_do -= count;
  .    .    .   .    .    .   .    .    .  	  if (count < do_write)
  .    .    .   .    .    .   .    .    .  	    return n - to_do;
  .    .    .   .    .    .   .    .    .  	}
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .        /* Now write out the remainder.  Normally, this will fit in the
  .    .    .   .    .    .   .    .    .  	 buffer, but it's somewhat messier for line-buffered files,
  .    .    .   .    .    .   .    .    .  	 so we let _IO_default_xsputn handle the general case. */
  4    0    0   0    0    0   0    0    0        if (to_do)
  6    0    0   0    0    0   1    0    0  	to_do -= _IO_default_xsputn (f, s+do_write, to_do);
  .    .    .   .    .    .   .    .    .      }
 28    0    0   0    0    0   0    0    0    return n - to_do;
160    1    1 140    0    0   0    0    0  }
  .    .    .   .    .    .   .    .    .  libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)
  .    .    .   .    .    .   .    .    .  
  .    .    .   .    .    .   .    .    .  _IO_size_t
  .    .    .   .    .    .   .    .    .  _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)
  .    .    .   .    .    .   .    .    .  {
  .    .    .   .    .    .   .    .    .    _IO_size_t want, have;
  .    .    .   .    .    .   .    .    .    _IO_ssize_t count;
  .    .    .   .    .    .   .    .    .    char *s = data;
-- line 1358 ----------------------------------------

--------------------------------------------------------------------------------
Ir      I1mr ILmr Dr     D1mr  DLmr  Dw     D1mw  DLmw  
--------------------------------------------------------------------------------
372,568  904  894 96,813 3,278 2,260 42,942 1,231 1,148  events annotated

